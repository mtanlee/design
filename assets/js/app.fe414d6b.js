(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,l=e[0],s=e[1],c=e[2],u=0,p=[];u<l.length;u++)o=l[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(d&&d(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,l=1;l<t.length;l++){var s=t[l];0!==i[s]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,l=document.createElement("script");l.charset="utf-8",l.timeout=120,o.nc&&l.setAttribute("nonce",o.nc),l.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"cc645ea8",3:"8724f783",4:"9edd854b",5:"cb726574",6:"200a5d71",7:"376b6f50",8:"8bcfd0d4",9:"124bc8b9",10:"7b891ec6",11:"294f3706",12:"1adbb286",13:"8cb56069",14:"87681b21",15:"85fa2121",16:"7f6c4236",17:"3052f197",18:"c88eaa8f",19:"3fa8bc10",20:"27512952",21:"fa5d9b9c",22:"ea66decc",23:"e9d932cc",24:"66029d38",25:"3b8cd57a",26:"0ae3cbaf",27:"fbee7f4e",28:"9b3a1edc",29:"c042b10e",30:"f05aa418",31:"a9d0dd9f",32:"871ab468",33:"e905f85d",34:"18e98a60",35:"4f24590f",36:"89feadfe",37:"48d783fe",38:"7aefaef0",39:"eb5e00a9",40:"2a3088c4",41:"29c6a2e6",42:"a9581e7e",43:"b4f44a41",44:"3fdf8367",45:"2c081029",46:"762f340e",47:"f4f2ab8b",48:"9125dfa4",49:"379b2ea9",50:"6dde474a",51:"1025f073",52:"9f70424e",53:"7a5dda27",54:"3187e6c8",55:"eaf2d346",56:"49ba6aeb",57:"de0e0824",58:"6f4491aa",59:"cd730f6e",60:"ba43f849",61:"8222308d",62:"3efbd6b8",63:"a2e71dba",64:"ee956060",65:"cadfa1e8",66:"00b9d156",67:"e271f086",68:"a707ca7f",69:"ea9a10ea",70:"1dc9b6f8",71:"92ea8a16",72:"426c46b2",73:"74ef37fc",74:"028665aa",75:"48c3e856"}[n]+".js"}(n);var s=new Error;a=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",s.name="ChunkLoadError",s.type=r,s.request=a,t[1](s)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:l})}),12e4);l.onerror=l.onload=a,document.head.appendChild(l)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/design/",o.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;a.push([104,0]),t()}([function(n,e,t){var r=t(56),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(29),i=Function.prototype,a=i.call,o=r&&i.bind.bind(a,a);n.exports=r?o:function(n){return function(){return a.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=s):i&&(s=l?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(1),i=t(32),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(70),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){var r=t(0),i=t(56),a=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===a}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(164),i=t(167);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(17);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(r,"").replace(i,"")}function s(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(s(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=l(n);return a.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return l(n.path)===l(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=l(e);for(let e=0;e<n.length;e++)if(l(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:i,themeConfig:a}=t,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return g(n);const l=o.sidebar||a.sidebar;if(l){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,l);return"auto"===r?g(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function g(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(5),i=t(65),a=t(100),o=t(28),l=t(55),s=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(o(n),e=l(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=l(e),o(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw s("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(16),i=t(149),a=t(150),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(5),i=t(13),a=t(35);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(8).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(18),i=t(32),a=t(33),o=t(129),l=t(131);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=a(e),r=arguments.length;l(t+r);for(var s=0;s<r;s++)e[t]=arguments[s],t++;return o(e,t),t}})},function(n,e,t){var r=t(2),i=t(52).f,a=t(15),o=t(112),l=t(37),s=t(66),c=t(125);n.exports=function(n,e){var t,d,u,p,m,h=n.target,g=n.global,v=n.stat;if(t=g?r:v?r[h]||l(h,{}):(r[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=i(t,d))&&m.value:t[d],!c(g?d:h+(v?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){var r=t(1),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(2),i=t(62),a=t(7),o=t(64),l=t(60),s=t(59),c=r.Symbol,d=i("wks"),u=s?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return a(d,n)||(d[n]=l&&a(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){var r=t(154),i=t(155),a=t(156),o=t(157),l=t(158);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(176);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(45);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(r.barSelector),d=r.speed,u=r.easing;return s.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),s=n?"-100":a(t.status||0),d=document.querySelector(r.parent);return l(o,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;s(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);s(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/design/design","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var r=t(9),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not an object")}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(47),i=t(53);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(2),i=t(0),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(53),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){var r=t(123);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(29),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),i=t(37),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(2),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(148),i=t(12),a=Object.prototype,o=a.hasOwnProperty,l=a.propertyIsEnumerable,s=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var r=t(10)(t(8),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(168),i=t(175),a=t(177),o=t(178),l=t(179);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(6),i=t(45),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(14),i=t(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),i=t(3),a=t(19),o=Object,l=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?l(n,""):o(n)}:o},function(n,e,t){var r=t(0),i=t(110),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=i.test(n);return l||a.test(n)?o(n.slice(2),l?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,l,s,c=0,d=!1,v=!1,f=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function y(n){return c=n,l=setTimeout(w,e),d?b(n):o}function x(n){var t=n-s;return void 0===s||t>=e||t<0||v&&n-c>=a}function w(){var n=m();if(x(n))return T(n);l=setTimeout(w,function(n){var t=e-(n-s);return v?p(t,a-(n-c)):t}(n))}function T(n){return l=void 0,f&&r?b(n):(r=i=void 0,o)}function C(){var n=m(),t=x(n);if(r=arguments,i=this,s=n,t){if(void 0===l)return y(s);if(v)return l=setTimeout(w,e),b(s)}return void 0===l&&(l=setTimeout(w,e)),o}return e=g(e)||0,h(t)&&(d=!!t.leading,a=(v="maxWait"in t)?u(g(t.maxWait)||0,e):a,f="trailing"in t?!!t.trailing:f),C.cancel=function(){void 0!==l&&clearTimeout(l),c=0,r=s=i=l=void 0},C.flush=function(){return void 0===l?o:T(m())},C}},function(n,e,t){var r=t(5),i=t(34),a=t(106),o=t(35),l=t(30),s=t(55),c=t(7),d=t(65),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=l(n),e=s(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(54),i=TypeError;n.exports=function(n){if(r(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(107),i=t(57);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(31),i=t(0),a=t(58),o=t(59),l=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,l(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(60);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(61),i=t(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(2),o=t(108),l=a.process,s=a.Deno,c=l&&l.versions||s&&s.version,d=c&&c.v8;d&&(i=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(63),i=t(36);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.2",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(5),i=t(3),a=t(99);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(7),i=t(118),a=t(52),o=t(13);n.exports=function(n,e,t){for(var l=i(e),s=o.f,c=a.f,d=0;d<l.length;d++){var u=l[d];r(n,u)||t&&r(t,u)||s(n,u,c(e,u))}}},function(n,e,t){var r=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(1),i=t(28),a=t(135);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(21),i=t(159),a=t(160),o=t(161),l=t(162),s=t(163);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(14),i=t(40);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(180),i=t(12);n.exports=function n(e,t,a,o,l){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,l))}},function(n,e,t){var r=t(77),i=t(183),a=t(78);n.exports=function(n,e,t,o,l,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,v=2&t?new r:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var f=n[h],b=e[h];if(o)var y=c?o(b,f,h,e,n,s):o(f,b,h,n,e,s);if(void 0!==y){if(y)continue;g=!1;break}if(v){if(!i(e,(function(n,e){if(!a(v,e)&&(f===n||l(f,n,t,o,s)))return v.push(e)}))){g=!1;break}}else if(f!==b&&!l(f,b,t,o,s)){g=!1;break}}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(41),i=t(181),a=t(182);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(193),i=t(199),a=t(83);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(8),i=t(195),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===a?r.Buffer:void 0,s=(l?l.isBuffer:void 0)||i;n.exports=s}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(196),i=t(197),a=t(198),o=a&&a.isTypedArray,l=o?i(o):r;n.exports=l},function(n,e,t){var r=t(73),i=t(43);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(8),"Set");n.exports=r},function(n,e,t){var r=t(40);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(88),i=t(25);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(6),i=t(44),a=t(210),o=t(213);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(146),i=t(151),a=t(222),o=t(230),l=t(239),s=t(103),c=a((function(n){var e=s(n);return l(e)&&(e=void 0),o(r(n,1,l,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,l=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==o&&(a+=t.substring(l,o)),l=o+1,a+=e}return l!==o?a+t.substring(l,o):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(248),i=t(249),a=t(250),o=!1,l=t(251).version,s=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=s.concat("cache"),d=/^\uFEFF/;function u(n,t){var i,a,o=t.views,l=/^[A-Za-z]+:\\|^\//.exec(n);if(l&&l.length)i=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(i=a)),i||Array.isArray(o)&&o.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(i=a),!i)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return i}function p(n,t){var r,i=n.filename,a=arguments.length>1;if(n.cache){if(!i)throw new Error("cache option requires a filename");if(r=e.cache.get(i))return r;a||(t=h(i).toString().replace(d,""))}else if(!a){if(!i)throw new Error("Internal EJS error: no file name or template provided");t=h(i).toString().replace(d,"")}return r=e.compile(t,n),n.cache&&e.cache.set(i,r),r}function m(n,t,r){var i;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(i=p(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{i=p(n)(t)}catch(n){return r(n)}r(null,i)}function h(n){return e.fileLoader(n)}function g(n,e,t,r,i){var a=e.split("\n"),o=Math.max(r-3,0),l=Math.min(a.length,r+3),s=i(t),c=a.slice(o,l).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=s,n.message=(s||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function v(n){return n.replace(/;(\s*$)/,"$1")}function f(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=i.dirname,a=i.extname,o=(0,i.resolve)(t?e:r(e),n);return a(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new f(n,e).compile()},e.render=function(n,e,t){var r=e||{},i=t||{};return 2==arguments.length&&a.shallowCopyFromList(i,r,s),p(i,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),i=r.shift(),o={filename:i};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(o,t)),a.shallowCopyFromList(o,e,c)),o.filename=i):e={},m(o,e,n)},e.Template=f,e.clearCache=function(){e.cache.reset()},f.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},f.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",l="",s=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",d=0;d<r.destructuredLocals.length;d++){var m=r.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}o+=c+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",l+="  }\n"),l+="  return __output;\n",this.source=o+this.source+l}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+s.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},s,function(e,t){var i=a.shallowCopy({},n);return t&&(i=a.shallowCopy(i,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,r)(i)},g])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var v=r.filename,f=i.basename(v,i.extname(v));try{Object.defineProperty(h,"name",{value:f,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),i=this.opts.delimiter,o=this.opts.openDelimiter,l=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(s,c){var p,m,g,v,b,y;if(0===s.indexOf(o+i)&&0!==s.indexOf(o+i+i)&&(m=r[c+2])!=i+l&&m!="-"+i+l&&m!="_"+i+l)throw new Error('Could not find matching close tag for "'+s+'".');if(n.legacyInclude&&(g=s.match(/^\s*include\s+(\S+)/))&&(p=r[c-1])&&(p==o+i||p==o+i+"-"||p==o+i+"_"))return v=a.shallowCopy({},t.opts),b=function(n,e){var t,r,i=a.shallowCopy({},e);r=h(t=u(n,i)).toString().replace(d,""),i.filename=t;var o=new f(r,i);return o.generateSource(),{source:o.source,filename:t,template:r}}(g[1],v),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(g[1],v.filename));t.scanLine(s)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),i=[];r;)0!==(n=r.index)&&(i.push(e.substring(0,n)),e=e.slice(n)),i.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&i.push(e),i},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,i=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=f.modes.EVAL;break;case r+t+"=":this.mode=f.modes.ESCAPED;break;case r+t+"-":this.mode=f.modes.RAW;break;case r+t+"#":this.mode=f.modes.COMMENT;break;case r+t+t:this.mode=f.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+i:this.mode=f.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+i,t+i)+'")\n';break;case t+i:case"-"+t+i:case"_"+t+i:this.mode==f.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case f.modes.EVAL:case f.modes.ESCAPED:case f.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case f.modes.EVAL:this.source+="    ; "+n+"\n";break;case f.modes.ESCAPED:this.source+="    ; __append(escapeFn("+v(n)+"))\n";break;case f.modes.RAW:this.source+="    ; __append("+v(n)+")\n";break;case f.modes.COMMENT:break;case f.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=l,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(242),t(4)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(243),t(4)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),i=t(9),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(5),i=t(3);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(62),i=t(64),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(1),i=t(7),a=t(30),o=t(120).indexOf,l=t(49),s=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,d=[];for(t in r)!i(l,t)&&i(r,t)&&s(d,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(d,t)||s(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(254)},function(n,e,t){"use strict";var r=t(18),i=t(126).left,a=t(127),o=t(61);r({target:"Array",proto:!0,forced:!t(128)&&o>79&&o<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(34),i=t(9),a=t(57),o=t(109),l=t(111),s=t(20),c=TypeError,d=s("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,s=o(n,d);if(s){if(void 0===e&&(e="default"),t=r(s,n,e),!i(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(48),i=t(54);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(34),i=t(0),a=t(9),o=TypeError;n.exports=function(n,e){var t,l;if("string"===e&&i(t=n.toString)&&!a(l=r(t,n)))return l;if(i(t=n.valueOf)&&!a(l=r(t,n)))return l;if("string"!==e&&i(t=n.toString)&&!a(l=r(t,n)))return l;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),i=t(13),a=t(113),o=t(37);n.exports=function(n,e,t,l){l||(l={});var s=l.enumerable,c=void 0!==l.name?l.name:e;if(r(t)&&a(t,c,l),l.global)s?n[e]=t:o(e,t);else{try{l.unsafe?n[e]&&(s=!0):delete n[e]}catch(n){}s?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!l.nonConfigurable,writable:!l.nonWritable})}return n}},function(n,e,t){var r=t(1),i=t(3),a=t(0),o=t(7),l=t(5),s=t(114).CONFIGURABLE,c=t(115),d=t(116),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,g=r("".slice),v=r("".replace),f=r([].join),b=l&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+v(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||s&&n.name!==e)&&(l?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?l&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return o(r,"source")||(r.source=f(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var r=t(5),i=t(7),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,l=i(a,"name"),s=l&&"something"===function(){}.name,c=l&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var r=t(1),i=t(0),a=t(36),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){var r,i,a,o=t(117),l=t(2),s=t(9),c=t(15),d=t(7),u=t(36),p=t(101),m=t(49),h=l.TypeError,g=l.WeakMap;if(o||u.state){var v=u.state||(u.state=new g);v.get=v.get,v.has=v.has,v.set=v.set,r=function(n,e){if(v.has(n))throw h("Object already initialized");return e.facade=n,v.set(n,e),e},i=function(n){return v.get(n)||{}},a=function(n){return v.has(n)}}else{var f=p("state");m[f]=!0,r=function(n,e){if(d(n,f))throw h("Object already initialized");return e.facade=n,c(n,f,e),e},i=function(n){return d(n,f)?n[f]:{}},a=function(n){return d(n,f)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!s(e)||(t=i(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),i=t(0),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){var r=t(31),i=t(1),a=t(119),o=t(124),l=t(28),s=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(l(n)),t=o.f;return t?s(e,t(n)):e}},function(n,e,t){var r=t(102),i=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(30),i=t(121),a=t(33),o=function(n){return function(e,t,o){var l,s=r(e),c=a(s),d=i(o,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(67),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(67),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),i=t(0),a=/#|\.prototype\./,o=function(n,e){var t=s[l(n)];return t==d||t!=c&&(i(e)?r(e):!!e)},l=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(48),i=t(32),a=t(47),o=t(33),l=TypeError,s=function(n){return function(e,t,s,c){r(t);var d=i(e),u=a(d),p=o(d),m=n?p-1:0,h=n?-1:1;if(s<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(19);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(5),i=t(130),a=TypeError,o=Object.getOwnPropertyDescriptor,l=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=l?function(n,e){if(i(n)&&!o(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(19);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(18),i=t(2),a=t(133),o=t(134),l=i.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,s),r({global:!0,constructor:!0,arity:1,forced:s},t)},d=function(n,e){if(l&&l[n]){var t={};t[n]=o("WebAssembly."+n,e,s),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:s},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(29),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(31),i=t(7),a=t(15),o=t(58),l=t(68),s=t(66),c=t(136),d=t(137),u=t(138),p=t(142),m=t(143),h=t(5),g=t(63);n.exports=function(n,e,t,v){var f=v?2:1,b=n.split("."),y=b[b.length-1],x=r.apply(null,b);if(x){var w=x.prototype;if(!g&&i(w,"cause")&&delete w.cause,!t)return x;var T=r("Error"),C=e((function(n,e){var t=u(v?e:n,void 0),r=v?new x(n):new x;return void 0!==t&&a(r,"message",t),m(r,C,r.stack,2),this&&o(w,this)&&d(r,this,C),arguments.length>f&&p(r,arguments[f]),r}));if(C.prototype=w,"Error"!==y?l?l(C,T):s(C,T,{name:!0}):h&&"stackTraceLimit"in x&&(c(C,x,"stackTraceLimit"),c(C,x,"prepareStackTrace")),s(C,x),!g)try{w.name!==y&&a(w,"name",y),w.constructor=C}catch(n){}return C}}},function(n,e,t){var r=t(0),i=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),i=t(9),a=t(68);n.exports=function(n,e,t){var o,l;return a&&r(o=e.constructor)&&o!==t&&i(l=o.prototype)&&l!==t.prototype&&a(n,l),n}},function(n,e,t){var r=t(139);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(140),i=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var r=t(141),i=t(0),a=t(19),o=t(20)("toStringTag"),l=Object,s="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),o))?t:s?a(e):"Object"==(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(20)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),i=t(15);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(15),i=t(144),a=t(145),o=Error.captureStackTrace;n.exports=function(n,e,t,l){a&&(o?o(n,e):r(n,"stack",i(t,l)))}},function(n,e,t){var r=t(1),i=Error,a=r("".replace),o=String(i("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(o);n.exports=function(n,e){if(s&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,l,"");return n}},function(n,e,t){var r=t(3),i=t(35);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(69),i=t(147);n.exports=function n(e,t,a,o,l){var s=-1,c=e.length;for(a||(a=i),l||(l=[]);++s<c;){var d=e[s];t>0&&a(d)?t>1?n(d,t-1,a,o,l):r(l,d):o||(l[l.length]=d)}return l}},function(n,e,t){var r=t(16),i=t(38),a=t(6),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(14),i=t(12);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(16),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,l=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,l),t=n[l];try{n[l]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[l]=t:delete n[l]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(152),i=t(208),a=t(46),o=t(6),l=t(219);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):l(n)}},function(n,e,t){var r=t(153),i=t(207),a=t(86);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(71),i=t(75);n.exports=function(n,e,t,a){var o=t.length,l=o,s=!a;if(null==n)return!l;for(n=Object(n);o--;){var c=t[o];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<l;){var d=(c=t[o])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new r;if(a)var h=a(u,p,d,n,e,m);if(!(void 0===h?i(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(22),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(22);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(21),i=t(39),a=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(73),i=t(165),a=t(40),o=t(74),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:l).test(o(n))}},function(n,e,t){var r,i=t(166),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(8)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(169),i=t(21),a=t(39);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(170),i=t(171),a=t(172),o=t(173),l=t(174);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(23);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(23),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(23),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(24);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(24);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(71),i=t(76),a=t(184),o=t(187),l=t(203),s=t(6),c=t(80),d=t(82),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var v=s(n),f=s(e),b=v?"[object Array]":l(n),y=f?"[object Array]":l(e),x=(b="[object Arguments]"==b?u:b)==u,w=(y="[object Arguments]"==y?u:y)==u,T=b==y;if(T&&c(n)){if(!c(e))return!1;v=!0,x=!1}if(T&&!x)return g||(g=new r),v||d(n)?i(n,e,t,m,h,g):a(n,e,b,t,m,h,g);if(!(1&t)){var C=x&&p.call(n,"__wrapped__"),I=w&&p.call(e,"__wrapped__");if(C||I){var E=C?n.value():n,S=I?e.value():e;return g||(g=new r),h(E,S,t,m,g)}}return!!T&&(g||(g=new r),o(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(16),i=t(185),a=t(72),o=t(76),l=t(186),s=t(42),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&r;if(m||(m=s),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;r|=2,p.set(n,e);var v=o(m(n),m(e),r,c,u,p);return p.delete(n),v;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(8).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(188),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,l){var s=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:i.call(e,p)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var g=!0;l.set(n,e),l.set(e,n);for(var v=s;++u<d;){var f=n[p=c[u]],b=e[p];if(a)var y=s?a(b,f,p,e,n,l):a(f,b,p,n,e,l);if(!(void 0===y?f===b||o(f,b,t,a,l):y)){g=!1;break}v||(v="constructor"==p)}if(g&&!v){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(g=!1)}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(189),i=t(190),a=t(79);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(69),i=t(6);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(191),i=t(192),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,l=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(194),i=t(38),a=t(6),o=t(80),l=t(81),s=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&i(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&s(n),m=t||d||u||p,h=m?r(n.length,String):[],g=h.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||u&&("offset"==v||"parent"==v)||p&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||l(v,g))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(14),i=t(43),a=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(70),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,l=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=l}).call(this,t(50)(n))},function(n,e,t){var r=t(200),i=t(201),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(202)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(204),i=t(39),a=t(205),o=t(84),l=t(206),s=t(14),c=t(74),d=c(r),u=c(i),p=c(a),m=c(o),h=c(l),g=s;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||a&&"[object Promise]"!=g(a.resolve())||o&&"[object Set]"!=g(new o)||l&&"[object WeakMap]"!=g(new l))&&(g=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(10)(t(8),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(8),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(8),"WeakMap");n.exports=r},function(n,e,t){var r=t(85),i=t(79);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(75),i=t(209),a=t(216),o=t(44),l=t(85),s=t(86),c=t(25);n.exports=function(n,e){return o(n)&&l(e)?s(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(87);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(211),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(212);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(41);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(214);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(16),i=t(215),a=t(6),o=t(45),l=r?r.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(217),i=t(218);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(88),i=t(38),a=t(6),o=t(81),l=t(43),s=t(25);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&l(d)&&o(p,d)&&(a(n)||i(n))}},function(n,e,t){var r=t(220),i=t(221),a=t(44),o=t(25);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(87);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(46),i=t(223),a=t(225);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(224),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,l=i(a.length-e,0),s=Array(l);++o<l;)s[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(s),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(226),i=t(229)(r);n.exports=i},function(n,e,t){var r=t(227),i=t(228),a=t(46),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(77),i=t(231),a=t(236),o=t(78),l=t(237),s=t(42);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=a;else if(u>=200){var g=e?null:l(n);if(g)return s(g);p=!1,d=o,h=new r}else h=e?[]:m;n:for(;++c<u;){var v=n[c],f=e?e(v):v;if(v=t||0!==v?v:0,p&&f==f){for(var b=h.length;b--;)if(h[b]===f)continue n;e&&h.push(f),m.push(v)}else d(h,f,t)||(h!==m&&h.push(f),m.push(v))}return m}},function(n,e,t){var r=t(232);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(233),i=t(234),a=t(235);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(84),i=t(238),a=t(42),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(83),i=t(12);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(18),i=t(2),a=t(247);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,e,t){var r=t(13).f,i=t(7),a=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var i=n[r];"."===i?n.splice(r,1):".."===i?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var a=i>=0?arguments[i]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),o="/"===i(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&o&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var i=r(n.split("/")),a=r(t.split("/")),o=Math.min(i.length,a.length),l=o,s=0;s<o;s++)if(i[s]!==a[s]){l=s;break}var c=[];for(s=l;s<i.length;s++)c.push("..");return(c=c.concat(a.slice(l))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,i=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!i){r=a;break}}else i=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,i=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!i){t=e+1;break}}else-1===r&&(i=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,i=!0,a=0,o=n.length-1;o>=0;--o){var l=n.charCodeAt(o);if(47!==l)-1===r&&(i=!1,r=o+1),46===l?-1===e?e=o:1!==a&&(a=1):-1!==e&&(a=-1);else if(!i){t=o+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var i="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function o(n){return i[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var i=t[r];void 0!==e[i]&&(n[i]=e[i])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/design/design/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function o(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function T(n,e){return w.call(n,e)}function C(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var I=/-(\w)/g,E=C((function(n){return n.replace(I,(function(n,e){return e?e.toUpperCase():""}))})),S=C((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),k=/\B([A-Z])/g,z=C((function(n){return n.replace(k,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function _(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function j(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function B(n,e,t){}var O=function(n,e,t){return!1},D=function(n){return n};function M(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),l=Object.keys(e);return o.length===l.length&&o.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function L(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function U(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:B,parsePlatformTagName:D,mustUseProp:O,async:!0,_lifecycleHooks:q},$=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function W(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat($.source,".$_\\d]"));var G="__proto__"in{},J="undefined"!=typeof window,Q=J&&window.navigator.userAgent.toLowerCase(),Z=Q&&/msie|trident/.test(Q),X=Q&&Q.indexOf("msie 9.0")>0,K=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var Y=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var nn,en=Q&&Q.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!J&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},ln=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);cn="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,i,a,o,l){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function vn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var fn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=fn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function Tn(){xn.pop(),yn.target=xn[xn.length-1]}var Cn=Array.prototype,In=Object.create(Cn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Cn[n];W(In,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var En=Object.getOwnPropertyNames(In),Sn={},kn=!0;function zn(n){kn=n}var An={notify:B,depend:B,addSub:B,removeSub:B},_n=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?An:new yn,this.vmCount=0,W(n,"__ob__",this),i(n)){if(!t)if(G)n.__proto__=In;else for(var r=0,a=En.length;r<a;r++){W(n,l=En[r],In[l])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var l;jn(n,l=o[r],Sn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&T(n,"__ob__")&&n.__ob__ instanceof _n?n.__ob__:!kn||!t&&on()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Un(n)||n instanceof mn?void 0:new _n(n,e,t)}function jn(n,e,t,r,a,o){var l=new yn,s=Object.getOwnPropertyDescriptor(n,e);if(!s||!1!==s.configurable){var c=s&&s.get,d=s&&s.set;c&&!d||t!==Sn&&2!==arguments.length||(t=n[e]);var u=!a&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(l.depend(),u&&(u.dep.depend(),i(e)&&Dn(e))),Un(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(U(r,e)){if(d)d.call(n,e);else{if(c)return;if(!a&&Un(r)&&!Un(e))return void(r.value=e);t=e}u=!a&&Pn(e,!1,o),l.notify()}}}),l}}function Bn(n,e,t){if(!Ln(n)){var r=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(jn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function On(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Ln(n)||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Dn(e)}function Mn(n){return Rn(n,!0),W(n,"__v_isShallow",!0),n}function Rn(n,e){if(!Ln(n)){Pn(n,e,on());0}}function Ln(n){return!(!n||!n.__v_isReadonly)}function Un(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Un(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Un(r)&&!Un(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var qn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=qn,!n&&qn&&(this.index=(qn.scopes||(qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=qn;try{return qn=this,n()}finally{qn=e}}else 0},n.prototype.on=function(){qn=this},n.prototype.off=function(){qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function $n(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=C((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Wn(n,e){function t(){var n=t.fns;if(!i(n))return ke(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)ke(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,r,i,o){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=Hn(s),a(c)||(a(d)?(a(c.fns)&&(c=n[s]=Wn(c,o)),l(u.once)&&(c=n[s]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)a(n[s])&&r((u=Hn(s)).name,e[s],u.capture)}function Gn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function s(){t.apply(this,arguments),x(r.fns,s)}a(i)?r=Wn([s]):o(i.fns)&&l(i.merged)?(r=i).fns.push(s):r=Wn([i,s]),r.merged=!0,n[e]=r}function Jn(n,e,t,r,i){if(o(e)){if(T(e,t))return n[t]=e[t],i||delete e[t],!0;if(T(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Qn(n){return s(n)?[gn(n)]:i(n)?function n(e,t){var r,c,d,u,p=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(d=p.length-1,u=p[d],i(c)?c.length>0&&(Zn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Zn(u)&&(p[d]=gn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):s(c)?Zn(u)?p[d]=gn(u.text+c):""!==c&&p.push(gn(c)):Zn(c)&&Zn(u)?p[d]=gn(u.text+c.text):(l(e._isVList)&&o(c.tag)&&a(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Zn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Xn(n,e){var t,r,a,l,s=null;if(i(n)||"string"==typeof n)for(s=new Array(n.length),t=0,r=n.length;t<r;t++)s[t]=e(n[t],t);else if("number"==typeof n)for(s=new Array(n),t=0;t<n;t++)s[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){s=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)s.push(e(u.value,s.length)),u=c.next()}else for(a=Object.keys(n),s=new Array(a.length),t=0,r=a.length;t<r;t++)l=a[t],s[t]=e(n[l],l,t);return o(s)||(s=[]),s._isVList=!0,s}function Kn(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=P(P({},r),t)),i=a(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Yn(n){return _t(this.$options,"filters",n,!0)||D}function ne(n,e){return i(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,i){var a=N.keyCodes[e]||t;return i&&r&&!N.keyCodes[e]?ne(i,r):a?ne(a,n):r?z(r)!==e:void 0===n}function te(n,e,t,r,a){if(t)if(d(t)){i(t)&&(t=j(t));var o=void 0,l=function(i){if("class"===i||"style"===i||y(i))o=n;else{var l=n.attrs&&n.attrs.type;o=r||N.mustUseProp(e,l,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=E(i),c=z(i);s in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var s in t)l(s)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ie(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function se(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];i(o)?se(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ie,n._n=f,n._s=v,n._l=Xn,n._t=Kn,n._q=M,n._i=R,n._m=re,n._f=Yn,n._k=ee,n._b=te,n._v=gn,n._e=hn,n._u=se,n._g=le,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var l=o.slot,s=t[l]||(t[l]=[]);"template"===a.tag?s.push.apply(s,a.children||[]):s.push(a)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,i){var a,o=Object.keys(t).length>0,l=e?!!e.$stable:!o,s=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(l&&i&&i!==r&&s===i.$key&&!o&&!i.$hasNormal)return i;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ve(n,t,c,e[c]))}else a={};for(var d in t)d in a||(a[d]=fe(t,d));return e&&Object.isExtensible(e)&&(e._normalized=a),W(a,"$stable",l),W(a,"$key",s),W(a,"$hasNormal",o),a}function ve(n,e,t,r){var a=function(){var e=un;pn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:Qn(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function fe(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};W(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:A(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function ye(n,e,t,r,i){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,xe(n,o,r,i));for(var o in n)o in e||(a=!0,delete n[o]);return a}function xe(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Te=null;function Ce(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Ie(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function Ee(n,e,t,r,u,p){return(i(t)||s(t))&&(u=r,r=t,t=void 0),l(p)&&(u=2),function(n,e,t,r,s){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===s?r=Qn(r):1===s&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),u=N.isReservedTag(e)?new mn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(m=_t(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):xt(m,t,n,r,e)}else u=xt(e,t,n,r);return i(u)?u:o(u)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,s=e.children.length;i<s;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,p),o(t)&&function(n){d(n.style)&&Ne(n.style);d(n.class)&&Ne(n.class)}(t),u):hn()}(n,e,t,r,u)}function Se(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){ze(n,r,"errorCaptured hook")}}ze(n,e,t)}finally{Tn()}}function ke(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&g(a)&&!a._handled&&(a.catch((function(n){return Se(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Se(n,r,i)}return a}function ze(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ae(e,null,"config.errorHandler")}Ae(n,e,t)}function Ae(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var _e,Pe=!1,je=[],Be=!1;function Oe(){Be=!1;var n=je.slice(0);je.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var De=Promise.resolve();_e=function(){De.then(Oe),Y&&setTimeout(B)},Pe=!0}else if(Z||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())_e="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Oe)}:function(){setTimeout(Oe,0)};else{var Me=1,Re=new MutationObserver(Oe),Le=document.createTextNode(String(Me));Re.observe(Le,{characterData:!0}),_e=function(){Me=(Me+1)%2,Le.data=String(Me)},Pe=!0}function Ue(n,e){var t;if(je.push((function(){if(n)try{n.call(e)}catch(n){Se(n,e,"nextTick")}else t&&t(e)})),Be||(Be=!0,_e()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=St(r[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var qe=new cn;function Ne(n){return function n(e,t){var r,a,o=i(e);if(!o&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var l=e.__ob__.dep.id;if(t.has(l))return;t.add(l)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Un(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,qe),qe.clear(),n}var $e,He=0,We=function(){function n(n,e,t,r,i){var a,o;a=this,void 0===(o=qn&&!qn._vm?qn:n?n._scope:void 0)&&(o=qn),o&&o.active&&o.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=B)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Se(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');ke(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){$e.$on(n,e)}function Ge(n,e){$e.$off(n,e)}function Je(n,e){var t=$e;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Qe(n,e,t){$e=n,Vn(e,t||{},Ve,Ge,Je,n),$e=void 0}var Ze=null;function Xe(n){var e=Ze;return Ze=n,function(){Ze=e}}function Ke(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Ke(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),wn();var i=un;r&&pn(n);var a=n.$options[e],o="".concat(e," hook");if(a)for(var l=0,s=a.length;l<s;l++)ke(a[l],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&pn(i),Tn()}var et=[],tt=[],rt={},it=!1,at=!1,ot=0;var lt=0,st=Date.now;if(J&&!Z){var ct=window.performance;ct&&"function"==typeof ct.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(lt=st(),at=!0,et.sort(dt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();ot=et.length=tt.length=0,rt={},it=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),ln&&N.devtools&&ln.emit("flush")}function pt(n){var e=n.id;if(null==rt[e]&&(n!==yn.target||!n.noRecurse)){if(rt[e]=!0,at){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);it||(it=!0,Ue(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var o=n[a].from;if(o in e._provided)t[a]=e._provided[o];else if("default"in n[a]){var l=n[a].default;t[a]=c(l)?l.call(e):l}else 0}}return t}}function ht(n,e,t,a,o){var s,c=this,d=o.options;T(a,"_uid")?(s=Object.create(a))._original=a:(s=a,a=a._original);var u=l(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=mt(d.inject,a),this.slots=function(){return c.$slots||ge(a,n.scopedSlots,c.$slots=pe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,r){var o=Ee(s,n,e,t,r,p);return o&&!i(o)&&(o.fnScopeId=d._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return Ee(s,n,e,t,r,p)}}function gt(n,e,t,r,i){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function vt(n,e){for(var t in e)n[E(t)]=e[t]}function ft(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var o=i.data.scopedSlots,l=n.$scopedSlots,s=!!(o&&!o.$stable||l!==r&&!l.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||s),d=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var u=i.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,u,d.data&&d.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,p),e&&n.$options.props){zn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var v=h[g],f=n.$options.props;m[v]=Pt(v,f,e,n)}zn(!0),n.$options.propsData=e}c&&(n.$slots=pe(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ye(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ke(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function xt(n,e,t,s,c){if(!a(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Te;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),l(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,s=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==s&&(clearTimeout(s),s=null),null!==c&&(clearTimeout(c),c=null))},p=L((function(t){n.resolved=Ce(t,e),i?r.length=0:u(!0)})),m=L((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(g(h)?a(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),o(h.error)&&(n.errorComp=Ce(h.error,e)),o(h.loading)&&(n.loadingComp=Ce(h.loading,e),0===h.delay?n.loading=!0:s=setTimeout((function(){s=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,r,i){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(p,e,t,s,c);e=e||{},Wt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),l=a[r],s=e.model.callback;o(l)?(i(l)?-1===l.indexOf(s):l!==s)&&(a[r]=[s].concat(l)):a[r]=s}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},l=n.attrs,s=n.props;if(o(l)||o(s))for(var c in r){var d=z(c);Jn(i,s,c,d,!0)||Jn(i,l,c,d,!1)}return i}}(e,n);if(l(n.options.functional))return function(n,e,t,a,l){var s=n.options,c={},d=s.props;if(o(d))for(var u in d)c[u]=Pt(u,d,e||r);else o(t.attrs)&&vt(c,t.attrs),o(t.props)&&vt(c,t.props);var p=new ht(t,c,l,a,n),m=s.render.call(null,p._c,p);if(m instanceof mn)return gt(m,t,p.parent,s,p);if(i(m)){for(var h=Qn(m)||[],g=new Array(h.length),v=0;v<h.length;v++)g[v]=gt(h[v],t,p.parent,s,p);return g}}(n,m,e,t,s);var h=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],i=e[r],a=bt[r];i===a||i&&i._merged||(e[r]=i?wt(a,i):a)}}(e);var f=ft(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(f?"-".concat(f):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:s},p)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Tt=B,Ct=N.optionMergeStrategies;function It(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,o=dn?Reflect.ownKeys(e):Object.keys(e),l=0;l<o.length;l++)"__ob__"!==(r=o[l])&&(i=n[r],a=e[r],t&&T(n,r)?i!==a&&p(i)&&p(a)&&It(i,a):Bn(n,r,a));return n}function Et(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?It(r,i):i}:e?n?function(){return It(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function St(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function kt(n,e,t,r){var i=Object.create(n||null);return e?P(i,e):i}Ct.data=function(n,e,t){return t?Et(n,e,t):e&&"function"!=typeof e?n:Et(n,e)},q.forEach((function(n){Ct[n]=St})),F.forEach((function(n){Ct[n+"s"]=kt})),Ct.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in P(a,n),e){var l=a[o],s=e[o];l&&!i(l)&&(l=[l]),a[o]=l?l.concat(s):i(s)?s:[s]}return a},Ct.props=Ct.methods=Ct.inject=Ct.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return P(i,n),e&&P(i,e),i},Ct.provide=function(n,e){return n?function(){var t=Object.create(null);return It(t,c(n)?n.call(this):n),e&&It(t,c(e)?e.call(this):e,!1),t}:e};var zt=function(n,e){return void 0===e?n:e};function At(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[E(a)]={type:null});else if(p(t))for(var l in t)a=t[l],o[E(l)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var l=t[o];r[o]=p(l)?P({from:o},l):{from:l}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=At(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=At(n,e.mixins[r],t);var o,l={};for(o in n)s(o);for(o in e)T(n,o)||s(o);function s(r){var i=Ct[r]||zt;l[r]=i(n[r],e[r],t,r)}return l}function _t(n,e,t,r){if("string"==typeof t){var i=n[e];if(T(i,t))return i[t];var a=E(t);if(T(i,a))return i[a];var o=S(a);return T(i,o)?i[o]:i[t]||i[a]||i[o]}}function Pt(n,e,t,r){var i=e[n],a=!T(t,n),o=t[n],l=Dt(Boolean,i.type);if(l>-1)if(a&&!T(i,"default"))o=!1;else if(""===o||o===z(n)){var s=Dt(String,i.type);(s<0||l<s)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!T(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Bt(e.type)?r.call(n):r}(r,i,n);var d=kn;zn(!0),Pn(o),zn(d)}return o}var jt=/^\s*function (\w+)/;function Bt(n){var e=n&&n.toString().match(jt);return e?e[1]:""}function Ot(n,e){return Bt(n)===Bt(e)}function Dt(n,e){if(!i(e))return Ot(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Ot(e[t],n))return t;return-1}var Mt={enumerable:!0,configurable:!0,get:B,set:B};function Rt(n,e,t){Mt.get=function(){return this[e][t]},Mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Mt)}function Lt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Mn({}),i=n.$options._propKeys=[];n.$parent&&zn(!1);var a=function(a){i.push(a);var o=Pt(a,e,t,n);jn(r,a,o),a in n||Rt(n,"_props",a)};for(var o in e)a(o);zn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);pn(n),wn();var i=ke(t,null,[n._props||Mn({}),r],n,"setup");if(Tn(),pn(),c(i))e.render=i;else if(d(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var o in i)"__sfc"!==o&&Fn(a,i,o)}else for(var o in i)H(o)||Fn(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?B:A(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Se(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&T(r,a)||H(a)||Rt(n,"_data",a)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var i in e){var a=e[i],o=c(a)?a:a.get;0,r||(t[i]=new We(n,o||B,B,Ut)),i in n||Ft(n,i,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)$t(n,t,r[a]);else $t(n,t,r)}}(n,e.watch)}var Ut={lazy:!0};function Ft(n,e,t){var r=!on();c(t)?(Mt.get=r?qt(e):Nt(t),Mt.set=B):(Mt.get=t.get?r&&!1!==t.cache?qt(e):Nt(t.get):B,Mt.set=t.set||B),Object.defineProperty(n,e,Mt)}function qt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function $t(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ht=0;function Wt(n){var e=n.options;if(n.super){var t=Wt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=At(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Gt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=ft(n)||ft(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=At(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Rt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=P({},o.options),i[r]=o,o}}function Jt(n){return n&&(ft(n.Ctor.options)||n.tag)}function Qt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Zt(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var l=o.name;l&&!e(l)&&Xt(t,a,r,i)}}}function Xt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=At(Wt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=pe(e._renderChildren,i),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return Ee(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Ee(n,e,t,r,i,!0)};var a=t&&t.data;jn(n,"$attrs",a&&a.attrs||r,null,!0),jn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(zn(!1),Object.keys(e).forEach((function(t){jn(n,t,e[t])})),zn(!0))}(e),Lt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var r=$n(n),i=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var o=i[a];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Bn,n.prototype.$delete=On,n.prototype.$watch=function(n,e,t){if(p(e))return $t(this,n,e,t);(t=t||{}).user=!0;var r=new We(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');wn(),ke(e,this,[r.value],this,i),Tn()}return function(){r.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,l=t._events[n];if(!l)return t;if(!e)return t._events[n]=null,t;for(var s=l.length;s--;)if((o=l[s])===e||o.fn===e){l.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?_(t):t;for(var r=_(arguments,1),i='event handler for "'.concat(n,'"'),a=0,o=t.length;a<o;a++)ke(t[a],e,r,e,i)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Xe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Ue(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),Te=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Se(t,e,"render"),n=e._vnode}finally{Te=null,pn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=a,n}}(Vt);var Kt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kt,exclude:Kt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Jt(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Zt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Zt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ie(n),t=e&&e.componentOptions;if(t){var r=Jt(t),i=this.include,a=this.exclude;if(i&&(!r||!Qt(i,r))||a&&r&&Qt(a,r))return e;var o=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[s]?(e.componentInstance=o[s].componentInstance,x(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:Tt,extend:P,mergeOptions:At,defineReactive:jn},n.set=Bn,n.delete=On,n.nextTick=Ue,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=_(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=At(this.options,n),this}}(n),Gt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.14";var nr=b("style,class"),er=b("input,textarea,option,select,progress"),tr=b("contenteditable,draggable,spellcheck"),rr=b("events,caret,typing,plaintext-only"),ir=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return or(n)?n.slice(6,n.length):""},sr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return ur(n,pr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function pr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=pr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return hr(n)||gr(n)};var fr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xr={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,l=e?null:a,s=e?void 0:a;if(c(t))ke(t,r,[l],r,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Un(t),m=r.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?i(h)&&x(h,a):i(h)?h.includes(a)||h.push(a):u?(m[t]=[a],Tr(r,t,m[t])):t.value=[a]}else if(u){if(e&&m[t]!==a)return;m[t]=s,Tr(r,t,l)}else if(p){if(e&&t.value!==a)return;t.value=l}else 0}}}function Tr(n,e,t){var r=n._setupState;r&&T(r,e)&&(Un(r[e])?r[e].value=t:r[e]=t)}var Cr=new mn("",{},[]),Ir=["create","activate","update","remove","destroy"];function Er(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||br(r)&&br(i)}(n,e)||l(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Sr(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var kr={create:zr,update:zr,destroy:function(n){zr(n,Cr)}};function zr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===Cr,o=e===Cr,l=_r(n.data.directives,n.context),s=_r(e.data.directives,e.context),c=[],d=[];for(t in s)r=l[t],i=s[t],r?(i.oldValue=r.value,i.oldArg=r.arg,jr(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(jr(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)jr(c[t],"inserted",e,n)};a?Gn(e,"insert",u):u()}d.length&&Gn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)jr(d[t],"componentUpdated",e,n)}));if(!a)for(t in l)s[t]||jr(l[t],"unbind",n,n,o)}(n,e)}var Ar=Object.create(null);function _r(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Ar),i[Pr(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||_t(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||_t(e.$options,"directives",r.name)}return i}function Pr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function jr(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Se(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Br=[xr,kr];function Or(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,s=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(r in(o(d.__ob__)||l(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)i=d[r],c[r]!==i&&Dr(s,r,i,e.data.pre);for(r in(Z||K)&&d.value!==c.value&&Dr(s,"value",d.value),c)a(d[r])&&(or(r)?s.removeAttributeNS(ar,lr(r)):tr(r)||s.removeAttribute(r))}}function Dr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Mr(n,e,t):ir(e)?sr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return sr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):or(e)?sr(t)?n.removeAttributeNS(ar,lr(e)):n.setAttributeNS(ar,e,t):Mr(n,e,t)}function Mr(n,e,t){if(sr(t))n.removeAttribute(e);else{if(Z&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Rr={create:Or,update:Or};function Lr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var l=cr(e),s=t._transitionClasses;o(s)&&(l=ur(l,pr(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var Ur,Fr={create:Lr,update:Lr};function qr(n,e,t){var r=Ur;return function i(){var a=e.apply(null,arguments);null!==a&&Hr(n,i,t,r)}}var Nr=Pe&&!(en&&Number(en[1])<=53);function $r(n,e,t,r){if(Nr){var i=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Ur.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Hr(n,e,t,r){(r||Ur).removeEventListener(n,e._wrapper||e,t)}function Wr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Ur=e.elm||n.elm,function(n){if(o(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,r,$r,Hr,qr,e.context),Ur=void 0}}var Vr,Gr={create:Wr,update:Wr,destroy:function(n){return Wr(n,Cr)}};function Jr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,s=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||l(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),s)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var d=a(r)?"":String(r);Qr(i,d)&&(i.value=d)}else if("innerHTML"===t&&gr(i.tagName)&&a(i.innerHTML)){(Vr=Vr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Vr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(r!==s[t])try{i[t]=r}catch(n){}}}}function Qr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return f(t)!==f(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Zr={create:Jr,update:Jr},Xr=C((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Kr(n){var e=Yr(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Yr(n){return Array.isArray(n)?j(n):"string"==typeof n?Xr(n):n}var ni,ei=/^--/,ti=/\s*!important$/,ri=function(n,e,t){if(ei.test(e))n.style.setProperty(e,t);else if(ti.test(t))n.style.setProperty(z(e),t.replace(ti,""),"important");else{var r=ai(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ii=["Webkit","Moz","ms"],ai=C((function(n){if(ni=ni||document.createElement("div").style,"filter"!==(n=E(n))&&n in ni)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ii.length;t++){var r=ii[t]+e;if(r in ni)return r}}));function oi(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,l,s=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Yr(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?P({},p):p;var m=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Kr(i.data))&&P(r,t);(t=Kr(n.data))&&P(r,t);for(var a=n;a=a.parent;)a.data&&(t=Kr(a.data))&&P(r,t);return r}(e,!0);for(l in u)a(m[l])&&ri(s,l,"");for(l in m)(i=m[l])!==u[l]&&ri(s,l,null==i?"":i)}}var li={create:oi,update:oi},si=/\s+/;function ci(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(si).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(si).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ui(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,pi(n.name||"v")),P(e,n),e}return"string"==typeof n?pi(n):void 0}}var pi=C((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mi=J&&!X,hi="transition",gi="transitionend",vi="animation",fi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vi="WebkitAnimation",fi="webkitAnimationEnd"));var bi=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yi(n){bi((function(){bi(n)}))}function xi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ci(n,e))}function wi(n,e){n._transitionClasses&&x(n._transitionClasses,e),di(n,e)}function Ti(n,e,t){var r=Ii(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var l="transition"===i?gi:fi,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=o&&c()};setTimeout((function(){s<o&&c()}),a+1),n.addEventListener(l,d)}var Ci=/\b(transform|all)(,|$)/;function Ii(n,e){var t,r=window.getComputedStyle(n),i=(r[hi+"Delay"]||"").split(", "),a=(r[hi+"Duration"]||"").split(", "),o=Ei(i,a),l=(r[vi+"Delay"]||"").split(", "),s=(r[vi+"Duration"]||"").split(", "),c=Ei(l,s),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&Ci.test(r[hi+"Property"])}}function Ei(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Si(e)+Si(n[t])})))}function Si(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ki(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ui(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,l=r.type,s=r.enterClass,u=r.enterToClass,p=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,g=r.appearActiveClass,v=r.beforeEnter,b=r.enter,y=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,T=r.appear,C=r.afterAppear,I=r.appearCancelled,E=r.duration,S=Ze,k=Ze.$vnode;k&&k.parent;)S=k.context,k=k.parent;var z=!S._isMounted||!n.isRootInsert;if(!z||T||""===T){var A=z&&m?m:s,_=z&&g?g:p,P=z&&h?h:u,j=z&&w||v,B=z&&c(T)?T:b,O=z&&C||y,D=z&&I||x,M=f(d(E)?E.enter:E);0;var R=!1!==i&&!X,U=_i(B),F=t._enterCb=L((function(){R&&(wi(t,P),wi(t,_)),F.cancelled?(R&&wi(t,A),D&&D(t)):O&&O(t),t._enterCb=null}));n.data.show||Gn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),B&&B(t,F)})),j&&j(t),R&&(xi(t,A),xi(t,_),yi((function(){wi(t,A),F.cancelled||(xi(t,P),U||(Ai(M)?setTimeout(F,M):Ti(t,l,F)))}))),n.data.show&&(e&&e(),B&&B(t,F)),R||U||F()}}}function zi(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ui(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,l=r.type,s=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,g=r.leaveCancelled,v=r.delayLeave,b=r.duration,y=!1!==i&&!X,x=_i(m),w=f(d(b)?b.leave:b);0;var T=t._leaveCb=L((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(wi(t,c),wi(t,u)),T.cancelled?(y&&wi(t,s),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(C):C()}function C(){T.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(xi(t,s),xi(t,u),yi((function(){wi(t,s),T.cancelled||(xi(t,c),x||(Ai(w)?setTimeout(T,w):Ti(t,l,T)))}))),m&&m(t,T),y||x||T())}}function Ai(n){return"number"==typeof n&&!isNaN(n)}function _i(n){if(a(n))return!1;var e=n.fns;return o(e)?_i(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pi(n,e){!0!==e.data.show&&ki(e)}var ji=function(n){var e,t,r={},c=n.modules,d=n.nodeOps;for(e=0;e<Ir.length;++e)for(r[Ir[e]]=[],t=0;t<c.length;++t)o(c[t][Ir[e]])&&r[Ir[e]].push(c[t][Ir[e]]);function u(n){var e=d.parentNode(n);o(e)&&d.removeChild(e,n)}function p(n,e,t,i,a,s,c){if(o(n.elm)&&o(s)&&(n=s[c]=vn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var s=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,i),l(s)&&function(n,e,t,i){var a,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,o(a=l.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Cr,l);e.push(l);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,p=n.children,v=n.tag;o(v)?(n.elm=n.ns?d.createElementNS(n.ns,v):d.createElement(v,n),y(n),g(n,p,e),o(u)&&f(n,e),h(t,n.elm,i)):l(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,i)):(n.elm=d.createTextNode(n.text),h(t,n.elm,i))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(f(n,e),y(n)):(wr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function g(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function f(n,t){for(var i=0;i<r.create.length;++i)r.create[i](Cr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Cr,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;o(e=Ze)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,r,i,a){for(;r<=i;++r)p(t[r],a,n,e,!1,t,r)}function w(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function T(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(C(r),w(r)):u(r.elm))}}function C(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&C(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function I(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&Er(n,a))return i}}function E(n,e,t,i,s,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[s]=vn(e));var u=e.elm=n.elm;if(l(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?z(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var g=n.children,f=e.children;if(o(h)&&v(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(g)&&o(f)?g!==f&&function(n,e,t,r,i){var l,s,c,u=0,m=0,h=e.length-1,g=e[0],v=e[h],f=t.length-1,b=t[0],y=t[f],w=!i;for(0;u<=h&&m<=f;)a(g)?g=e[++u]:a(v)?v=e[--h]:Er(g,b)?(E(g,b,r,t,m),g=e[++u],b=t[++m]):Er(v,y)?(E(v,y,r,t,f),v=e[--h],y=t[--f]):Er(g,y)?(E(g,y,r,t,f),w&&d.insertBefore(n,g.elm,d.nextSibling(v.elm)),g=e[++u],y=t[--f]):Er(v,b)?(E(v,b,r,t,m),w&&d.insertBefore(n,v.elm,g.elm),v=e[--h],b=t[++m]):(a(l)&&(l=Sr(e,u,h)),a(s=o(b.key)?l[b.key]:I(b,e,u,h))?p(b,r,n,g.elm,!1,t,m):Er(c=e[s],b)?(E(c,b,r,t,m),e[s]=void 0,w&&d.insertBefore(n,c.elm,g.elm)):p(b,r,n,g.elm,!1,t,m),b=t[++m]);u>h?x(n,a(t[f+1])?null:t[f+1].elm,t,m,f,r):m>f&&T(e,u,h)}(u,g,f,t,c):o(f)?(o(n.text)&&d.setTextContent(u,""),x(u,null,f,0,f.length-1,t)):o(g)?T(g,0,g.length-1):o(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function S(n,e,t){if(l(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var k=b("attrs,class,staticClass,staticStyle,key");function z(n,e,t,r){var i,a=e.tag,s=e.data,c=e.children;if(r=r||s&&s.pre,e.elm=n,l(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(s)&&(o(i=s.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return m(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=s)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!z(u,c[p],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else g(e,c,t);if(o(s)){var h=!1;for(var v in s)if(!k(v)){h=!0,f(e,t);break}!h&&s.class&&Ne(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var s,c=!1,u=[];if(a(n))c=!0,p(e,u);else{var m=o(n.nodeType);if(!m&&Er(n,e))E(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&z(n,e,u))return S(e,u,!0),n;s=n,n=new mn(d.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,g=d.parentNode(h);if(p(e,u,h._leaveCb?null:g,d.nextSibling(h)),o(e.parent))for(var f=e.parent,b=v(e);f;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](f);if(f.elm=e.elm,b){for(var x=0;x<r.create.length;++x)r.create[x](Cr,f);var C=f.data.hook.insert;if(C.merged)for(var I=1;I<C.fns.length;I++)C.fns[I]()}else wr(f);f=f.parent}o(g)?T([n],0,0):o(n.tag)&&w(n)}}return S(e,u,c),e.elm}o(n)&&w(n)}}({nodeOps:yr,modules:[Rr,Fr,Gr,Zr,li,J?{create:Pi,activate:Pi,remove:function(n,e){!0!==n.data.show?zi(n,e):e()}}:{}].concat(Br)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fi(n,"input")}));var Bi={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Gn(t,"postpatch",(function(){Bi.componentUpdated(n,e,t)})):Oi(n,e,t.context),n._vOptions=[].map.call(n.options,Ri)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Li),n.addEventListener("compositionend",Ui),n.addEventListener("change",Ui),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Oi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Ri);if(i.some((function(n,e){return!M(n,r[e])})))(n.multiple?e.value.some((function(n){return Mi(n,i)})):e.value!==e.oldValue&&Mi(e.value,i))&&Fi(n,"change")}}};function Oi(n,e,t){Di(n,e,t),(Z||K)&&setTimeout((function(){Di(n,e,t)}),0)}function Di(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,l=0,s=n.options.length;l<s;l++)if(o=n.options[l],i)a=R(r,Ri(o))>-1,o.selected!==a&&(o.selected=a);else if(M(Ri(o),r))return void(n.selectedIndex!==l&&(n.selectedIndex=l));i||(n.selectedIndex=-1)}}function Mi(n,e){return e.every((function(e){return!M(e,n)}))}function Ri(n){return"_value"in n?n._value:n.value}function Li(n){n.target.composing=!0}function Ui(n){n.target.composing&&(n.target.composing=!1,Fi(n.target,"input"))}function Fi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function qi(n){return!n.componentInstance||n.data&&n.data.transition?n:qi(n.componentInstance._vnode)}var Ni={model:Bi,show:{bind:function(n,e,t){var r=e.value,i=(t=qi(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,ki(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=qi(t)).data&&t.data.transition?(t.data.show=!0,r?ki(t,(function(){n.style.display=n.__vOriginalDisplay})):zi(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},$i={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Hi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Hi(Ie(e.children)):n}function Wi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[E(r)]=i[r];return e}function Vi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Gi=function(n){return n.tag||he(n)},Ji=function(n){return"show"===n.name},Qi={name:"transition",props:$i,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Gi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Hi(i);if(!a)return i;if(this._leaving)return Vi(n,i);var o="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?o+"comment":o+a.tag:s(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var l=(a.data||(a.data={})).transition=Wi(this),c=this._vnode,d=Hi(c);if(a.data.directives&&a.data.directives.some(Ji)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=P({},l);if("out-in"===r)return this._leaving=!0,Gn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vi(n,i);if("in-out"===r){if(he(a))return c;var p,m=function(){p()};Gn(l,"afterEnter",m),Gn(l,"enterCancelled",m),Gn(u,"delayLeave",(function(n){p=n}))}}return i}}},Zi=P({tag:String,moveClass:String},$i);function Xi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ki(n){n.data.newPos=n.elm.getBoundingClientRect()}function Yi(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete Zi.mode;var na={Transition:Qi,TransitionGroup:{props:Zi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Wi(this),l=0;l<i.length;l++){if((d=i[l]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))a.push(d),t[d.key]=d,(d.data||(d.data={})).transition=o;else;}if(r){var s=[],c=[];for(l=0;l<r.length;l++){var d;(d=r[l]).data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?s.push(d):c.push(d)}this.kept=n(e,null,s),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xi),n.forEach(Ki),n.forEach(Yi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xi(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(gi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(gi,n),t._moveCb=null,wi(t,e))})}})))},methods:{hasMove:function(n,e){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),ci(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ii(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ea(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=vr,Vt.config.isReservedAttr=nr,Vt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!J)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=fr[n])return fr[n];var e=document.createElement(n);return n.indexOf("-")>-1?fr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fr[n]=/HTMLUnknownElement/.test(e.toString())},P(Vt.options.directives,Ni),P(Vt.options.components,na),Vt.prototype.__patch__=J?ji:B,Vt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new We(n,r,B,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){N.devtools&&ln&&ln.emit("init",Vt)}),0);var ta=/[!'()*]/g,ra=function(n){return"%"+n.charCodeAt(0).toString(16)},ia=/%2C/g,aa=function(n){return encodeURIComponent(n).replace(ta,ra).replace(ia,",")};function oa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var la=function(n){return null==n||"object"==typeof n?n:String(n)};function sa(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=oa(t.shift()),i=t.length>0?oa(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function ca(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return aa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(aa(e)):r.push(aa(e)+"="+aa(n)))})),r.join("&")}return aa(e)+"="+aa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function ua(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=pa(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ga(e,i),matched:n?ha(n):[]};return t&&(o.redirectedFrom=ga(t,i)),Object.freeze(o)}function pa(n){if(Array.isArray(n))return n.map(pa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pa(n[t]);return e}return n}var ma=ua(null,{path:"/"});function ha(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ga(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||ca)(r)+i}function va(n,e,t){return e===ma?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&fa(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&fa(n.query,e.query)&&fa(n.params,e.params))))}function fa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?fa(a,o):String(a)===String(o)}))}function ba(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,l=t.name,s=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(a.routerViewDepth=d,u){var m=c[l],h=m&&m.component;return h?(m.configProps&&xa(h,a,m.route,m.configProps),o(h,a,r)):o()}var g=s.matched[d],v=g&&g.components[l];if(!g||!v)return c[l]=null,o();c[l]={component:v},a.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),ba(s)};var f=g.props&&g.props[l];return f&&(ea(c[l],{route:s,configProps:f}),xa(v,a,s,f)),o(v,a,r)}};function xa(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ea({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function wa(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var l=a[o];".."===l?i.pop():"."!==l&&i.push(l)}return""!==i[0]&&i.unshift(""),i.join("/")}function Ta(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ca=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ia=La,Ea=_a,Sa=function(n,e){return ja(_a(n,e),e)},ka=ja,za=Ra,Aa=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function _a(n,e){for(var t,r=[],i=0,a=0,o="",l=e&&e.delimiter||"/";null!=(t=Aa.exec(n));){var s=t[0],c=t[1],d=t.index;if(o+=n.slice(a,d),a=d+s.length,c)o+=c[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],g=t[5],v=t[6],f=t[7];o&&(r.push(o),o="");var b=null!=p&&null!=u&&u!==p,y="+"===v||"*"===v,x="?"===v||"*"===v,w=t[2]||l,T=h||g;r.push({name:m||i++,prefix:p||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!f,pattern:T?Oa(T):f?".*":"[^"+Ba(w)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function Pa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ja(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Ma(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?Pa:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=a[s.name];if(null==d){if(s.optional){s.partial&&(i+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(Ca(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');i+=s.prefix+c}}else i+=s}return i}}function Ba(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Oa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Da(n,e){return n.keys=e,n}function Ma(n){return n&&n.sensitive?"":"i"}function Ra(n,e,t){Ca(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var l=n[o];if("string"==typeof l)a+=Ba(l);else{var s=Ba(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),a+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=Ba(t.delimiter||"/"),u=a.slice(-d.length)===d;return r||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=i?"$":r&&u?"":"(?="+d+"|$)",Da(new RegExp("^"+a,Ma(t)),e)}function La(n,e,t){return Ca(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Da(n,e)}(n,e):Ca(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(La(n[i],e,t).source);return Da(new RegExp("(?:"+r.join("|")+")",Ma(t)),e)}(n,e,t):function(n,e,t){return Ra(_a(n,t),e,t)}(n,e,t)}Ia.parse=Ea,Ia.compile=Sa,Ia.tokensToFunction=ka,Ia.tokensToRegExp=za;var Ua=Object.create(null);function Fa(n,e,t){e=e||{};try{var r=Ua[n]||(Ua[n]=Ia.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function qa(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ea({},n)).params;return a&&"object"==typeof a&&(i.params=ea({},a)),i}if(!i.path&&i.params&&e){(i=ea({},i))._normalized=!0;var o=ea(ea({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;i.path=Fa(l,o,e.path)}else 0;return i}var s=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=s.path?wa(s.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var r,i=t||sa;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(la):la(o)}return r}(s.query,i.query,r&&r.options.parseQuery),p=i.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Na,$a=function(){},Ha={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,l=i.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=o.redirectedFrom?ua(null,qa(o.redirectedFrom),null,t):o;s[h]=va(r,g,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var v=s[h]?this.ariaCurrentValue:null,f=function(n){Wa(n)&&(e.replace?t.replace(a,$a):t.push(a,$a))},b={click:Wa};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=f})):b[this.event]=f;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:o,navigate:f,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":v};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var T=w.data=ea({},w.data);for(var C in T.on=T.on||{},T.on){var I=T.on[C];C in b&&(T.on[C]=Array.isArray(I)?I:[I])}for(var E in b)E in T.on?T.on[E].push(b[E]):T.on[E]=f;var S=w.data.attrs=ea({},w.data.attrs);S.href=l,S["aria-current"]=v}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Wa(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Va="undefined"!=typeof window;function Ga(n,e,t,r,i){var a=e||[],o=t||Object.create(null),l=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var l=i.path,s=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ta(e.path+"/"+n)}(l,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:Ja(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:s,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?Ta(o+"/"+i.path):void 0;n(e,t,r,i,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,r,h,a,u.path||"/")}s&&(r[s]||(r[s]=u))}(a,o,l,n,i)}));for(var s=0,c=a.length;s<c;s++)"*"===a[s]&&(a.push(a.splice(s,1)[0]),c--,s--);return{pathList:a,pathMap:o,nameMap:l}}function Ja(n,e){return Ia(n,[],e)}function Qa(n,e){var t=Ga(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var l=qa(n,t,!1,e),c=l.name;if(c){var d=a[c];if(!d)return s(null,l);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&u.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=Fa(d.path,l.params),s(d,l,o)}if(l.path){l.params={};for(var m=0;m<r.length;m++){var h=r[m],g=i[h];if(Za(g.regex,l.path,l.params))return s(g,l,o)}}return s(null,l)}function l(n,t){var r=n.redirect,i="function"==typeof r?r(ua(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return s(null,t);var l=i,c=l.name,d=l.path,u=t.query,p=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,p=l.hasOwnProperty("hash")?l.hash:p,m=l.hasOwnProperty("params")?l.params:m,c){a[c];return o({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return wa(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:Fa(h,m),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,r){return n&&n.redirect?l(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Fa(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,s(a,e)}return s(null,e)}(0,t,n.matchAs):ua(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ga([e||n],r,i,a,t),t&&t.alias.length&&Ga(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Ga(n,r,i,a)}}}function Za(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?oa(r[i]):r[i])}return!0}var Xa=Va&&window.performance&&window.performance.now?window.performance:Date;function Ka(){return Xa.now().toFixed(3)}var Ya=Ka();function no(){return Ya}function eo(n){return Ya=n}var to=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ea({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function io(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=no();if(n)return to[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){po(n,a)})).catch((function(n){0})):po(o,a))}))}}function ao(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){ao(),n.state&&n.state.key&&eo(n.state.key)}function lo(n){return co(n.x)||co(n.y)}function so(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var uo=/^#\d/;function po(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:co((t=a).x)?t.x:0,y:co(t.y)?t.y:0})}else lo(n)&&(e=so(n))}else r&&lo(n)&&(e=so(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,ho=Va&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){ao();var t=window.history;try{if(e){var r=ea({},t.state);r.key=no(),t.replaceState(r,"",n)}else t.pushState({key:eo(Ka())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vo(n){go(n,!0)}var fo={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return xo(n,e,fo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,fo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var wo=["params","query","hash"];function To(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Co(n,e){return To(n)&&n._isRouter&&(null==e||n.type===e)}function Io(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Eo(n){return function(e,t,r){var i=!1,a=0,o=null;So(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var s,c=Ao((function(e){var i;((i=e).__esModule||zo&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Na.extend(e),t.components[l]=e,--a<=0&&r()})),d=Ao((function(n){var e="Failed to resolve async component "+l+": "+n;o||(o=To(n)?n:new Error(e),r(o))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||r()}}function So(n,e){return ko(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ko(n){return Array.prototype.concat.apply([],n)}var zo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ao(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var _o=function(n,e){this.router=n,this.base=function(n){if(!n)if(Va){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ma,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,r){var i=So(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=Na.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return ko(r?i.reverse():i)}function jo(n,e){if(e)return function(){return n.apply(e,arguments)}}_o.prototype.listen=function(n){this.cb=n},_o.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},_o.prototype.onError=function(n){this.errorCbs.push(n)},_o.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(Co(n,fo.redirected)&&a===ma||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},_o.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,l=function(n){!Co(n)&&To(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=i.matched.length-1;if(va(n,i)&&s===c&&n.matched[s]===i.matched[c])return this.ensureURL(),n.hash&&io(this.router,i,n,!1),l(((o=xo(a=i,n,fo.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Po(n,"beforeRouteLeave",jo,!0)}(p),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",jo)}(u),m.map((function(n){return n.beforeEnter})),Eo(m)),g=function(e,t){if(r.pending!==n)return l(yo(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),l(function(n,e){return xo(n,e,fo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):To(e)?(r.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(bo(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){l(n)}};Io(h,g,(function(){Io(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return l(yo(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){ba(n)}))}))}))},_o.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},_o.prototype.setupListeners=function(){},_o.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ma,this.pending=null};var Bo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Oo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=ho&&t;r&&this.listeners.push(ro());var i=function(){var t=n.current,i=Oo(n.base);n.current===ma&&i===n._startLocation||n.transitionTo(i,(function(n){r&&io(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){go(Ta(r.base+n.fullPath)),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){vo(Ta(r.base+n.fullPath)),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Oo(this.base)!==this.current.fullPath){var e=Ta(this.base+this.current.fullPath);n?go(e):vo(e)}},e.prototype.getCurrentLocation=function(){return Oo(this.base)},e}(_o);function Oo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Do=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Oo(n);if(!/^\/#/.test(e))return window.location.replace(Ta(n+"/#"+e)),!0}(this.base)||Mo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ro());var r=function(){var e=n.current;Mo()&&n.transitionTo(Ro(),(function(r){t&&io(n.router,r,e,!0),ho||Fo(r.fullPath)}))},i=ho?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Uo(n.fullPath),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ro()!==e&&(n?Uo(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Ro()},e}(_o);function Mo(){var n=Ro();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Ro(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Lo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Uo(n){ho?go(Lo(n)):window.location.hash=n}function Fo(n){ho?vo(Lo(n)):window.location.replace(Lo(n))}var qo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Co(n,fo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(_o),No=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Va||(e="abstract"),this.mode=e,e){case"history":this.history=new Bo(this,n.base);break;case"hash":this.history=new Do(this,n.base,this.fallback);break;case"abstract":this.history=new qo(this,n.base);break;default:0}},$o={currentRoute:{configurable:!0}};No.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},$o.currentRoute.get=function(){return this.history&&this.history.current},No.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Bo||t instanceof Do){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;ho&&i&&"fullPath"in n&&io(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},No.prototype.beforeEach=function(n){return Wo(this.beforeHooks,n)},No.prototype.beforeResolve=function(n){return Wo(this.resolveHooks,n)},No.prototype.afterEach=function(n){return Wo(this.afterHooks,n)},No.prototype.onReady=function(n,e){this.history.onReady(n,e)},No.prototype.onError=function(n){this.history.onError(n)},No.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},No.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},No.prototype.go=function(n){this.history.go(n)},No.prototype.back=function(){this.go(-1)},No.prototype.forward=function(){this.go(1)},No.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},No.prototype.resolve=function(n,e,t){var r=qa(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},No.prototype.getRoutes=function(){return this.matcher.getRoutes()},No.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},No.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(No.prototype,$o);var Ho=No;function Wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}No.install=function n(e){if(!n.installed||Na!==e){n.installed=!0,Na=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ya),e.component("RouterLink",Ha);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},No.version="3.6.5",No.isNavigationFailure=Co,No.NavigationFailureType=fo,No.START_LOCATION=ma,Va&&window.Vue&&window.Vue.use(No);t(105);t(17),t(132);var Vo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,338)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,337))},Go={"v-7c44097c":()=>t.e(5).then(t.bind(null,339)),"v-cbce72d4":()=>t.e(6).then(t.bind(null,340)),"v-1057bb3a":()=>t.e(7).then(t.bind(null,341)),"v-2443e46d":()=>t.e(8).then(t.bind(null,342)),"v-19adc5ec":()=>t.e(9).then(t.bind(null,343)),"v-19e0ab98":()=>t.e(10).then(t.bind(null,344)),"v-7771b23d":()=>t.e(11).then(t.bind(null,345)),"v-6c350cd6":()=>t.e(12).then(t.bind(null,346)),"v-1cf67f56":()=>t.e(13).then(t.bind(null,347)),"v-c62a590a":()=>t.e(14).then(t.bind(null,348)),"v-58986cb9":()=>t.e(15).then(t.bind(null,349)),"v-121637aa":()=>t.e(16).then(t.bind(null,350)),"v-717c7df2":()=>t.e(17).then(t.bind(null,351)),"v-0d3720dc":()=>t.e(18).then(t.bind(null,352)),"v-04b48643":()=>t.e(19).then(t.bind(null,353)),"v-b45bd736":()=>t.e(20).then(t.bind(null,354)),"v-f4f72696":()=>t.e(21).then(t.bind(null,355)),"v-f104e8ee":()=>t.e(22).then(t.bind(null,356)),"v-569eca3f":()=>t.e(23).then(t.bind(null,357)),"v-6f5cbd38":()=>t.e(24).then(t.bind(null,358)),"v-5430ebce":()=>t.e(25).then(t.bind(null,359)),"v-fd8744e6":()=>t.e(26).then(t.bind(null,360)),"v-8da1bcae":()=>t.e(27).then(t.bind(null,361)),"v-4bd3e31c":()=>t.e(28).then(t.bind(null,362)),"v-33b23c84":()=>t.e(29).then(t.bind(null,363)),"v-13d9f031":()=>t.e(30).then(t.bind(null,364)),"v-a097a3be":()=>t.e(31).then(t.bind(null,365)),"v-3a239cb0":()=>t.e(32).then(t.bind(null,366)),"v-1bdc9712":()=>t.e(33).then(t.bind(null,367)),"v-68de8656":()=>t.e(34).then(t.bind(null,368)),"v-72ea5972":()=>t.e(35).then(t.bind(null,369)),"v-b5457c16":()=>t.e(36).then(t.bind(null,370)),"v-0569b6f8":()=>t.e(37).then(t.bind(null,371)),"v-4e6d8200":()=>t.e(38).then(t.bind(null,372)),"v-2c19e87c":()=>t.e(39).then(t.bind(null,373)),"v-25c50554":()=>t.e(40).then(t.bind(null,374)),"v-6e2d857c":()=>t.e(41).then(t.bind(null,375)),"v-51d6ac9c":()=>t.e(42).then(t.bind(null,376)),"v-f82d5ee0":()=>t.e(43).then(t.bind(null,377)),"v-e65aab34":()=>t.e(44).then(t.bind(null,378)),"v-637f7ff4":()=>t.e(45).then(t.bind(null,379)),"v-07d9254f":()=>t.e(46).then(t.bind(null,380)),"v-cc527b5a":()=>t.e(47).then(t.bind(null,381)),"v-04ae6228":()=>t.e(48).then(t.bind(null,382)),"v-1a6137e8":()=>t.e(49).then(t.bind(null,383)),"v-ca584e06":()=>t.e(50).then(t.bind(null,384)),"v-f0251290":()=>t.e(51).then(t.bind(null,385)),"v-0f7af49e":()=>t.e(52).then(t.bind(null,386)),"v-1457855d":()=>t.e(53).then(t.bind(null,387)),"v-3f96c8d8":()=>t.e(54).then(t.bind(null,388)),"v-0893d5c3":()=>t.e(55).then(t.bind(null,389)),"v-79c78335":()=>t.e(56).then(t.bind(null,390)),"v-c5ef3042":()=>t.e(57).then(t.bind(null,391)),"v-ce0e8fd4":()=>t.e(58).then(t.bind(null,392)),"v-38d3c9ce":()=>t.e(59).then(t.bind(null,393)),"v-5d9b4816":()=>t.e(60).then(t.bind(null,394)),"v-3a98d9f2":()=>t.e(61).then(t.bind(null,395)),"v-45cada9f":()=>t.e(62).then(t.bind(null,396)),"v-1add83e9":()=>t.e(63).then(t.bind(null,397)),"v-90dacde0":()=>t.e(64).then(t.bind(null,398)),"v-7781c0b6":()=>t.e(65).then(t.bind(null,399)),"v-5f40daea":()=>t.e(66).then(t.bind(null,400)),"v-de1804e0":()=>t.e(67).then(t.bind(null,401)),"v-34e3a8ae":()=>t.e(68).then(t.bind(null,402)),"v-02e2a776":()=>t.e(69).then(t.bind(null,403)),"v-20b770b6":()=>t.e(70).then(t.bind(null,404)),"v-0480d1c5":()=>t.e(71).then(t.bind(null,405)),"v-7e5bbd14":()=>t.e(72).then(t.bind(null,406))};function Jo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Zo=Jo(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Xo=/\B([A-Z])/g,Ko=Jo(n=>n.replace(Xo,"-$1").toLowerCase()),Yo=Jo(n=>n.charAt(0).toUpperCase()+n.slice(1));function nl(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yo(Zo(e))):n(Yo(e))||n(Ko(e))}const el=Object.assign({},Vo,Go),tl=n=>el[n],rl=n=>Go[n],il=n=>Vo[n],al=n=>Vt.component(n);function ol(n){return nl(rl,n)}function ll(n){return nl(il,n)}function sl(n){return nl(tl,n)}function cl(n){return nl(al,n)}function dl(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cl(n)&&sl(n)){const e=await sl(n)();Vt.component(n,e.default)}}))}function ul(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var pl=t(93),ml=t.n(pl),hl=t(94),gl=t.n(hl),vl={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gl()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bl(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=yl(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ml()([{name:"description",content:this.$description}],n,this.siteMeta,xl)},updateCanonicalLink(){fl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bl(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){yl(null,this.currentMetaTags),fl()}};function fl(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bl(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function yl(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xl(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var wl=t(51),Tl={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(wl)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],l=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),s=decodeURIComponent(this.$route.hash);if(l&&s!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(s===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Cl=t(26),Il=t.n(Cl),El={mounted(){Il.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||Il.a.start(),t()}),this.$router.afterEach(()=>{Il.a.done(),this.isSidebarOpen=!1})}};t(240),t(241);class Sl{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var kl={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Sl).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var zl={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Al={},_l=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Pl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:zl[n]},jl=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;i.appendChild(n(t,r,a))})),i},Bl=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},Ol=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=_l(l.html),l.jsTpl=(t=l.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=e,a}(l.js,l.html);var s=Pl("vue");return l.jsLib.unshift(s),l},Dl=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ml=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Rl(){var n=Bl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Bl(n,"vuepress-plugin-demo-block__code"),t=Bl(n,"vuepress-plugin-demo-block__display"),r=Bl(n,"vuepress-plugin-demo-block__footer"),i=Bl(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ml(n),htmlTpl:_l("")},o=Pl("react"),l=Pl("reactDOM");return a.jsLib.unshift(o,l),a}(a,o):"vanilla"===l?Dl(a,o):Ol(a,o),d=jl("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",Ll.bind(null,d,s,e,r)),Pl("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(Pl("cssLib")).concat(Pl("jsLib")).join(",");return jl("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Pl("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(Pl("jsLib")).join(";"),css_external:a.concat(Pl("cssLib")).join(";"),layout:Pl("codepenLayout"),js_pre_processor:Pl("codepenJsProcessor"),editors:Pl("codepenEditors")});return jl("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Pl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Al[n]){var e=jl("style",{innerHTML:n});document.body.appendChild(e),Al[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),i);else if("vue"===l){var p=(new(Vue.extend(c.script))).$mount();i.appendChild(p.$el)}else"vanilla"===l&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Rl()}),300)}function Ll(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Ul={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Rl()},updated:function(){Rl()}},Fl="auto",ql="zoom-in",Nl="zoom-out",$l="grab",Hl="move";function Wl(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Vl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Gl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Jl(n,e,t){!function(n){var e=Ql,t=Zl;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Ql="transition",Zl="transform",Xl="transform",Kl="transitionend";var Yl=function(){},ns={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Yl,onClose:Yl,onGrab:Yl,onMove:Yl,onRelease:Yl,onBeforeOpen:Yl,onBeforeClose:Yl,onBeforeGrab:Yl,onBeforeRelease:Yl,onImageLoading:Yl,onImageLoaded:Yl},es={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(ts(n)&&!rs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){ts(n)&&!rs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function ts(n){return 0===n.button}function rs(n){return n.metaKey||n.ctrlKey}var is={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Jl(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Wl(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Jl(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},as="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},os=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),ls=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ss={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Gl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?$l:Nl,transition:Xl+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Jl(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Jl(this.el,{transform:"none"})},grab:function(n,e,t){var r=cs(),i=r.x-n,a=r.y-e;Jl(this.el,{cursor:Hl,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cs(),i=r.x-n,a=r.y-e;Jl(this.el,{transition:Xl,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Jl(this.el,this.styleClose)},restoreOpenStyle:function(){Jl(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":as(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,l=this.rect.height/2,s=cs(),c={x:s.x-o,y:s.y-l},d=c.x/o,u=c.y/l,p=a+Math.min(d,u);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(i)*m/(100*this.rect.width),v=parseFloat(i)*h/(100*this.rect.height);if(p>g||p>v)return{x:g,y:v}}return{x:p,y:p}}};function cs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function ds(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Wl(n,r,e[r],t)}))}var us=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ss),this.overlay=Object.create(is),this.handler=Object.create(es),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ls({},ns,e),this.overlay.init(this),this.handler.init(this)}return os(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=ql,Wl(n,"click",this.handler.click),this.options.preloadImage&&Vl(Gl(n)));return this}},{key:"config",value:function(n){return n?(ls(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Vl(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Wl(document,"scroll",this.handler.scroll),Wl(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Wl(window,"resize",this.handler.resizeWindow);var a=function n(){Wl(r,Kl,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&ds(document,e.handler,!0),t(r)};return Wl(r,Kl,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fl,this.overlay.fadeOut(),this.target.zoomOut(),Wl(document,"scroll",this.handler.scroll,!1),Wl(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Wl(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Wl(t,Kl,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&ds(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Wl(t,Kl,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){Wl(i,Kl,n,!1),r(i)};return Wl(i,Kl,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Hl,this.target.move(n,e,t);var i=this.target.el,a=function n(){Wl(i,Kl,n,!1),r(i)};return Wl(i,Kl,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fl,this.target.restoreOpenStyle();var r=function r(){Wl(t,Kl,r,!1),n.lock=!1,n.released=!0,e(t)};return Wl(t,Kl,r),this}}}]),n}();const ps=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ms=Number("500");class hs{constructor(){this.instance=new us(ps)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ms){setTimeout(()=>this.update(n),e)}}var gs=[vl,Tl,El,kl,Ul,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hs,this.$vuepress.zooming.updateDelay()}}],vs={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ul("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},fs=t(4),bs=Object(fs.a)(vs,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bs,"mixins",gs);const ys=[{name:"v-7c44097c",path:"/pages/0a89f3/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7c44097c").then(t)}},{path:"/pages/0a89f3/index.html",redirect:"/pages/0a89f3/"},{path:"/03.设计/01.架构/00.综合/00.如何设计系统.html",redirect:"/pages/0a89f3/"},{name:"v-cbce72d4",path:"/pages/000a7b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-cbce72d4").then(t)}},{path:"/pages/000a7b/index.html",redirect:"/pages/000a7b/"},{path:"/03.设计/01.架构/00.综合/01.系统架构面试.html",redirect:"/pages/000a7b/"},{name:"v-1057bb3a",path:"/pages/db2390/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1057bb3a").then(t)}},{path:"/pages/db2390/index.html",redirect:"/pages/db2390/"},{path:"/03.设计/01.架构/00.综合/02.系统架构概述.html",redirect:"/pages/db2390/"},{name:"v-2443e46d",path:"/pages/a49605/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-2443e46d").then(t)}},{path:"/pages/a49605/index.html",redirect:"/pages/a49605/"},{path:"/03.设计/01.架构/00.综合/03.系统高性能架构.html",redirect:"/pages/a49605/"},{name:"v-19adc5ec",path:"/pages/9a462f/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-19adc5ec").then(t)}},{path:"/pages/9a462f/index.html",redirect:"/pages/9a462f/"},{path:"/03.设计/01.架构/00.综合/04.系统高可用架构.html",redirect:"/pages/9a462f/"},{name:"v-19e0ab98",path:"/pages/1e5251/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-19e0ab98").then(t)}},{path:"/pages/1e5251/index.html",redirect:"/pages/1e5251/"},{path:"/03.设计/01.架构/00.综合/05.系统伸缩性架构.html",redirect:"/pages/1e5251/"},{name:"v-7771b23d",path:"/pages/943670/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7771b23d").then(t)}},{path:"/pages/943670/index.html",redirect:"/pages/943670/"},{path:"/03.设计/01.架构/00.综合/06.系统扩展性架构.html",redirect:"/pages/943670/"},{name:"v-6c350cd6",path:"/pages/a1adcf/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6c350cd6").then(t)}},{path:"/pages/a1adcf/index.html",redirect:"/pages/a1adcf/"},{path:"/03.设计/01.架构/00.综合/07.系统安全性架构.html",redirect:"/pages/a1adcf/"},{name:"v-1cf67f56",path:"/pages/8cbae8/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1cf67f56").then(t)}},{path:"/pages/8cbae8/index.html",redirect:"/pages/8cbae8/"},{path:"/03.设计/01.架构/00.综合/08.大型系统核心技术.html",redirect:"/pages/8cbae8/"},{name:"v-c62a590a",path:"/pages/641e5c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-c62a590a").then(t)}},{path:"/pages/641e5c/index.html",redirect:"/pages/641e5c/"},{path:"/03.设计/01.架构/00.综合/09.系统测试架构.html",redirect:"/pages/641e5c/"},{name:"v-58986cb9",path:"/pages/012075/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-58986cb9").then(t)}},{path:"/pages/012075/index.html",redirect:"/pages/012075/"},{path:"/03.设计/01.架构/01.微服务/01.微服务简介.html",redirect:"/pages/012075/"},{name:"v-121637aa",path:"/pages/aa7497/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-121637aa").then(t)}},{path:"/pages/aa7497/index.html",redirect:"/pages/aa7497/"},{path:"/03.设计/01.架构/01.微服务/02.微服务基本原理.html",redirect:"/pages/aa7497/"},{name:"v-717c7df2",path:"/pages/559360/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-717c7df2").then(t)}},{path:"/pages/559360/index.html",redirect:"/pages/559360/"},{path:"/03.设计/01.架构/01.微服务/",redirect:"/pages/559360/"},{name:"v-0d3720dc",path:"/pages/7ac4c5/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0d3720dc").then(t)}},{path:"/pages/7ac4c5/index.html",redirect:"/pages/7ac4c5/"},{path:"/03.设计/01.架构/02.安全/01.认证和授权.html",redirect:"/pages/7ac4c5/"},{name:"v-04b48643",path:"/pages/21bd0a/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-04b48643").then(t)}},{path:"/pages/21bd0a/index.html",redirect:"/pages/21bd0a/"},{path:"/03.设计/01.架构/02.安全/02.OAuth2.0.html",redirect:"/pages/21bd0a/"},{name:"v-b45bd736",path:"/pages/3f25aa/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-b45bd736").then(t)}},{path:"/pages/3f25aa/index.html",redirect:"/pages/3f25aa/"},{path:"/03.设计/01.架构/99.解决方案/Cinchcast的架构.html",redirect:"/pages/3f25aa/"},{name:"v-f4f72696",path:"/pages/c38eff/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f4f72696").then(t)}},{path:"/pages/c38eff/index.html",redirect:"/pages/c38eff/"},{path:"/03.设计/01.架构/99.解决方案/",redirect:"/pages/c38eff/"},{name:"v-f104e8ee",path:"/pages/940342/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f104e8ee").then(t)}},{path:"/pages/940342/index.html",redirect:"/pages/940342/"},{path:"/03.设计/01.架构/99.解决方案/亚马逊的架构.html",redirect:"/pages/940342/"},{name:"v-569eca3f",path:"/pages/f90553/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-569eca3f").then(t)}},{path:"/pages/f90553/index.html",redirect:"/pages/f90553/"},{path:"/03.设计/01.架构/99.解决方案/低代码平台.html",redirect:"/pages/f90553/"},{name:"v-6f5cbd38",path:"/pages/d63886/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6f5cbd38").then(t)}},{path:"/pages/d63886/index.html",redirect:"/pages/d63886/"},{path:"/03.设计/01.架构/99.解决方案/海量数据处理.html",redirect:"/pages/d63886/"},{name:"v-5430ebce",path:"/pages/4ae6a4/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5430ebce").then(t)}},{path:"/pages/4ae6a4/index.html",redirect:"/pages/4ae6a4/"},{path:"/03.设计/01.架构/99.解决方案/电商.html",redirect:"/pages/4ae6a4/"},{name:"v-fd8744e6",path:"/pages/c72587/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-fd8744e6").then(t)}},{path:"/pages/c72587/index.html",redirect:"/pages/c72587/"},{path:"/03.设计/01.架构/99.解决方案/短地址服务.html",redirect:"/pages/c72587/"},{name:"v-8da1bcae",path:"/pages/a963f0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-8da1bcae").then(t)}},{path:"/pages/a963f0/index.html",redirect:"/pages/a963f0/"},{path:"/03.设计/01.架构/99.解决方案/秒杀系统设计.html",redirect:"/pages/a963f0/"},{name:"v-4bd3e31c",path:"/pages/d9e5d2/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4bd3e31c").then(t)}},{path:"/pages/d9e5d2/index.html",redirect:"/pages/d9e5d2/"},{path:"/03.设计/01.架构/",redirect:"/pages/d9e5d2/"},{name:"v-33b23c84",path:"/pages/9a2452/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-33b23c84").then(t)}},{path:"/pages/9a2452/index.html",redirect:"/pages/9a2452/"},{path:"/03.设计/02.设计模式/00.设计模式概述.html",redirect:"/pages/9a2452/"},{name:"v-13d9f031",path:"/pages/ff930b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-13d9f031").then(t)}},{path:"/pages/ff930b/index.html",redirect:"/pages/ff930b/"},{path:"/03.设计/02.设计模式/01.简单工厂模式.html",redirect:"/pages/ff930b/"},{name:"v-a097a3be",path:"/pages/65724c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-a097a3be").then(t)}},{path:"/pages/65724c/index.html",redirect:"/pages/65724c/"},{path:"/03.设计/02.设计模式/02.工厂方法模式.html",redirect:"/pages/65724c/"},{name:"v-3a239cb0",path:"/pages/340aa0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-3a239cb0").then(t)}},{path:"/pages/340aa0/index.html",redirect:"/pages/340aa0/"},{path:"/03.设计/02.设计模式/03.抽象工厂模式.html",redirect:"/pages/340aa0/"},{name:"v-1bdc9712",path:"/pages/bf03f3/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1bdc9712").then(t)}},{path:"/pages/bf03f3/index.html",redirect:"/pages/bf03f3/"},{path:"/03.设计/02.设计模式/04.建造者模式.html",redirect:"/pages/bf03f3/"},{name:"v-68de8656",path:"/pages/1af8ee/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-68de8656").then(t)}},{path:"/pages/1af8ee/index.html",redirect:"/pages/1af8ee/"},{path:"/03.设计/02.设计模式/05.原型模式.html",redirect:"/pages/1af8ee/"},{name:"v-72ea5972",path:"/pages/cf046f/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-72ea5972").then(t)}},{path:"/pages/cf046f/index.html",redirect:"/pages/cf046f/"},{path:"/03.设计/02.设计模式/06.单例模式.html",redirect:"/pages/cf046f/"},{name:"v-b5457c16",path:"/pages/2115cf/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-b5457c16").then(t)}},{path:"/pages/2115cf/index.html",redirect:"/pages/2115cf/"},{path:"/03.设计/02.设计模式/07.适配器模式.html",redirect:"/pages/2115cf/"},{name:"v-0569b6f8",path:"/pages/b05f5f/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0569b6f8").then(t)}},{path:"/pages/b05f5f/index.html",redirect:"/pages/b05f5f/"},{path:"/03.设计/02.设计模式/08.桥接模式.html",redirect:"/pages/b05f5f/"},{name:"v-4e6d8200",path:"/pages/85c0a3/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4e6d8200").then(t)}},{path:"/pages/85c0a3/index.html",redirect:"/pages/85c0a3/"},{path:"/03.设计/02.设计模式/09.组合模式.html",redirect:"/pages/85c0a3/"},{name:"v-2c19e87c",path:"/pages/2e24a8/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-2c19e87c").then(t)}},{path:"/pages/2e24a8/index.html",redirect:"/pages/2e24a8/"},{path:"/03.设计/02.设计模式/10.装饰模式.html",redirect:"/pages/2e24a8/"},{name:"v-25c50554",path:"/pages/ea331b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-25c50554").then(t)}},{path:"/pages/ea331b/index.html",redirect:"/pages/ea331b/"},{path:"/03.设计/02.设计模式/11.外观模式.html",redirect:"/pages/ea331b/"},{name:"v-6e2d857c",path:"/pages/9147e7/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6e2d857c").then(t)}},{path:"/pages/9147e7/index.html",redirect:"/pages/9147e7/"},{path:"/03.设计/02.设计模式/12.享元模式.html",redirect:"/pages/9147e7/"},{name:"v-51d6ac9c",path:"/pages/5a865c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-51d6ac9c").then(t)}},{path:"/pages/5a865c/index.html",redirect:"/pages/5a865c/"},{path:"/03.设计/02.设计模式/13.代理模式.html",redirect:"/pages/5a865c/"},{name:"v-f82d5ee0",path:"/pages/6eaeb4/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f82d5ee0").then(t)}},{path:"/pages/6eaeb4/index.html",redirect:"/pages/6eaeb4/"},{path:"/03.设计/02.设计模式/14.模板方法模式.html",redirect:"/pages/6eaeb4/"},{name:"v-e65aab34",path:"/pages/22353c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-e65aab34").then(t)}},{path:"/pages/22353c/index.html",redirect:"/pages/22353c/"},{path:"/03.设计/02.设计模式/15.命令模式.html",redirect:"/pages/22353c/"},{name:"v-637f7ff4",path:"/pages/09d5af/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-637f7ff4").then(t)}},{path:"/pages/09d5af/index.html",redirect:"/pages/09d5af/"},{path:"/03.设计/02.设计模式/16.迭代器模式.html",redirect:"/pages/09d5af/"},{name:"v-07d9254f",path:"/pages/056e1d/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-07d9254f").then(t)}},{path:"/pages/056e1d/index.html",redirect:"/pages/056e1d/"},{path:"/03.设计/02.设计模式/17.观察者模式.html",redirect:"/pages/056e1d/"},{name:"v-cc527b5a",path:"/pages/48e5aa/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-cc527b5a").then(t)}},{path:"/pages/48e5aa/index.html",redirect:"/pages/48e5aa/"},{path:"/03.设计/02.设计模式/18.解释器模式.html",redirect:"/pages/48e5aa/"},{name:"v-04ae6228",path:"/pages/3b1f47/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-04ae6228").then(t)}},{path:"/pages/3b1f47/index.html",redirect:"/pages/3b1f47/"},{path:"/03.设计/02.设计模式/19.中介者模式.html",redirect:"/pages/3b1f47/"},{name:"v-1a6137e8",path:"/pages/b25735/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1a6137e8").then(t)}},{path:"/pages/b25735/index.html",redirect:"/pages/b25735/"},{path:"/03.设计/02.设计模式/20.职责链模式.html",redirect:"/pages/b25735/"},{name:"v-ca584e06",path:"/pages/5ae0d5/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-ca584e06").then(t)}},{path:"/pages/5ae0d5/index.html",redirect:"/pages/5ae0d5/"},{path:"/03.设计/02.设计模式/21.备忘录模式.html",redirect:"/pages/5ae0d5/"},{name:"v-f0251290",path:"/pages/dc8ecd/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f0251290").then(t)}},{path:"/pages/dc8ecd/index.html",redirect:"/pages/dc8ecd/"},{path:"/03.设计/02.设计模式/22.策略模式.html",redirect:"/pages/dc8ecd/"},{name:"v-0f7af49e",path:"/pages/671352/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0f7af49e").then(t)}},{path:"/pages/671352/index.html",redirect:"/pages/671352/"},{path:"/03.设计/02.设计模式/23.访问者模式.html",redirect:"/pages/671352/"},{name:"v-1457855d",path:"/pages/d77095/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1457855d").then(t)}},{path:"/pages/d77095/index.html",redirect:"/pages/d77095/"},{path:"/03.设计/02.设计模式/24.状态模式.html",redirect:"/pages/d77095/"},{name:"v-3f96c8d8",path:"/pages/9703b1/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-3f96c8d8").then(t)}},{path:"/pages/9703b1/index.html",redirect:"/pages/9703b1/"},{path:"/03.设计/02.设计模式/25.面向对象原则.html",redirect:"/pages/9703b1/"},{name:"v-0893d5c3",path:"/pages/81b0f2/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0893d5c3").then(t)}},{path:"/pages/81b0f2/index.html",redirect:"/pages/81b0f2/"},{path:"/03.设计/02.设计模式/",redirect:"/pages/81b0f2/"},{name:"v-79c78335",path:"/pages/d86872/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-79c78335").then(t)}},{path:"/pages/d86872/index.html",redirect:"/pages/d86872/"},{path:"/03.设计/03.重构/01.代码的坏味道和重构.html",redirect:"/pages/d86872/"},{name:"v-c5ef3042",path:"/pages/49d5ae/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-c5ef3042").then(t)}},{path:"/pages/49d5ae/index.html",redirect:"/pages/49d5ae/"},{path:"/03.设计/03.重构/02.代码坏味道之代码臃肿.html",redirect:"/pages/49d5ae/"},{name:"v-ce0e8fd4",path:"/pages/65ee05/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-ce0e8fd4").then(t)}},{path:"/pages/65ee05/index.html",redirect:"/pages/65ee05/"},{path:"/03.设计/03.重构/03.代码坏味道之滥用面向对象.html",redirect:"/pages/65ee05/"},{name:"v-38d3c9ce",path:"/pages/56ca63/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-38d3c9ce").then(t)}},{path:"/pages/56ca63/index.html",redirect:"/pages/56ca63/"},{path:"/03.设计/03.重构/04.代码坏味道之变革的障碍.html",redirect:"/pages/56ca63/"},{name:"v-5d9b4816",path:"/pages/47acb5/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5d9b4816").then(t)}},{path:"/pages/47acb5/index.html",redirect:"/pages/47acb5/"},{path:"/03.设计/03.重构/05.代码坏味道之非必要的.html",redirect:"/pages/47acb5/"},{name:"v-3a98d9f2",path:"/pages/630e7a/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-3a98d9f2").then(t)}},{path:"/pages/630e7a/index.html",redirect:"/pages/630e7a/"},{path:"/03.设计/03.重构/06.代码坏味道之耦合.html",redirect:"/pages/630e7a/"},{name:"v-45cada9f",path:"/pages/d200c3/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-45cada9f").then(t)}},{path:"/pages/d200c3/index.html",redirect:"/pages/d200c3/"},{path:"/03.设计/03.重构/",redirect:"/pages/d200c3/"},{name:"v-1add83e9",path:"/pages/86db92/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1add83e9").then(t)}},{path:"/pages/86db92/index.html",redirect:"/pages/86db92/"},{path:"/03.设计/04.DDD/01.领域驱动设计简介.html",redirect:"/pages/86db92/"},{name:"v-90dacde0",path:"/pages/ae1396/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-90dacde0").then(t)}},{path:"/pages/ae1396/index.html",redirect:"/pages/ae1396/"},{path:"/03.设计/11.UML/01.UML快速入门.html",redirect:"/pages/ae1396/"},{name:"v-7781c0b6",path:"/pages/dd5922/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7781c0b6").then(t)}},{path:"/pages/dd5922/index.html",redirect:"/pages/dd5922/"},{path:"/03.设计/11.UML/02.UML结构建模图.html",redirect:"/pages/dd5922/"},{name:"v-5f40daea",path:"/pages/0b8e4b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5f40daea").then(t)}},{path:"/pages/0b8e4b/index.html",redirect:"/pages/0b8e4b/"},{path:"/03.设计/11.UML/03.UML行为建模图.html",redirect:"/pages/0b8e4b/"},{name:"v-de1804e0",path:"/pages/13ccb0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-de1804e0").then(t)}},{path:"/pages/13ccb0/index.html",redirect:"/pages/13ccb0/"},{path:"/03.设计/11.UML/",redirect:"/pages/13ccb0/"},{name:"v-34e3a8ae",path:"/pages/8ea43c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-34e3a8ae").then(t)}},{path:"/pages/8ea43c/index.html",redirect:"/pages/8ea43c/"},{path:"/03.设计/",redirect:"/pages/8ea43c/"},{name:"v-02e2a776",path:"/archives/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-02e2a776").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-20b770b6",path:"/categories/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-20b770b6").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-0480d1c5",path:"/tags/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0480d1c5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-7e5bbd14",path:"/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7e5bbd14").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bs}],xs={title:"DESIGN",description:"Design 是个人的架构设计心得",base:"/design/",headTags:[["link",{rel:"icon",href:"/design/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"如何设计系统",frontmatter:{title:"如何设计系统",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","综合"],tags:["架构","设计"],permalink:"/pages/0a89f3/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/00.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F.html",relativePath:"03.设计/01.架构/00.综合/00.如何设计系统.md",key:"v-7c44097c",path:"/pages/0a89f3/",headers:[{level:2,title:"系统设计过程",slug:"系统设计过程",normalizedTitle:"系统设计过程",charIndex:13},{level:3,title:"步骤一、约束和用例",slug:"步骤一、约束和用例",normalizedTitle:"步骤一、约束和用例",charIndex:24},{level:3,title:"步骤二、顶层设计",slug:"步骤二、顶层设计",normalizedTitle:"步骤二、顶层设计",charIndex:322},{level:3,title:"步骤三、分析瓶颈",slug:"步骤三、分析瓶颈",normalizedTitle:"步骤三、分析瓶颈",charIndex:454},{level:3,title:"步骤四、扩展设计",slug:"步骤四、扩展设计",normalizedTitle:"步骤四、扩展设计",charIndex:776},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1405}],headersStr:"系统设计过程 步骤一、约束和用例 步骤二、顶层设计 步骤三、分析瓶颈 步骤四、扩展设计 参考资料",content:"# 如何设计系统\n\n\n# 系统设计过程\n\n\n# 步骤一、约束和用例\n\n对于任何系统设计，第一件应该做的事是：阐明系统的约束并确定系统需要满足哪些用例。\n\n永远不要假设没有明确说明的事情。一定要尽力收集、理解需求，并设计一个很好地涵盖这些要求的解决方案。\n\n例如，URL 缩短服务可能只为几千个用户提供服务，但每个用户都可能共享数百万个 URL。它可能旨在处理对缩短的 URL 的数百万次点击或数十次点击。该服务可能必须提供有关每个缩短的 URL 的大量统计信息（这会增加您的数据大小），或者可能根本不需要统计信息。\n\n您还必须考虑预期会发生的用例。您的系统将根据其预期功能进行设计。不要忘记确保你知道面试官一开始没有告诉你的所有要求。\n\n\n# 步骤二、顶层设计\n\n一旦确定了要设计的系统的范围，接下来就要做顶层设计：概述系统架构中所需的所有重要组件。\n\n此时，应该绘制出主要组件以及它们之间的连接。通常，这种顶层设计是基于主流技术的组合。这就要求设计必须熟悉这些技术，了解其利弊以及适合使用的场景。\n\n\n# 步骤三、分析瓶颈\n\n顶层设计很可能会遇到一个或多个瓶颈。这完全没问题，不要指望一个新系统可以立即处理世界上的所有负载。它只需要可扩展，以便您能够使用一些标准工具和技术对其进行改进。\n\n现在有了顶层设计，就要考虑这些组件在系统扩展时面临的瓶颈。也许，系统需要一个负载均衡器和集群来处理用户请求。或者，由于数据容量庞大，以至于需要将数据库分库分表（分布在多台机器上）。这些方案有什么利弊，是否适用？数据库是否太慢，是否需要一些内存缓存？\n\n通常每个解决方案都是某种权衡和取舍。改变某事会使其他事情恶化。然而，重要的是能够讨论这些权衡，并根据定义的约束和用例来衡量它们对系统的影响。\n\n一旦分析清楚核心瓶颈，就可以着手在下一步中去解决它们。\n\n\n# 步骤四、扩展设计\n\n首先，你需要了解以下技术手段：\n\n * 垂直扩展\n * 水平罗占\n * 缓存\n * 负载均衡\n * 数据库复制\n * 数据库分区\n * 异步\n * NoSql\n\n在系统设计方面，回顾现实中的架构非常有用。注意使用了哪些技术。继续研究每一项新技术，看看它解决了什么问题，它的替代品是什么，它擅长的地方，以及失败的地方。\n\n一切都是权衡的结果——这是系统设计中最基本的概念之一。\n\n一些推荐的学习资料\n\n * 生产中的深度学习：关于 EyeEm 如何构建在大量图像上运行多个深度学习模型的生产系统的精彩故事\n * Uber：一篇关于 Uber 如何快速扩展的好文章，关于将您的服务分解为分布在许多存储库中的许多微服务。\n * Facebook：Facebook 如何在直播中同时处理 800,000 名观众\n * Kraken.io：如何大规模缩放图像优化，本文将更详细地看一些具体使用的硬件方案，以及部署、监控等重要方面\n * Twitter：Twitter 如何处理每秒 3,000 张图片上传以及为什么它使用的旧方式现在行不通\n * 最后，Twitter 子组件的一些很好的例子：存储数据（video | text）和时间轴（video | text）。\n * 有关更高级的示例，请查看 Google、Youtube（video | text）、Tumblr、StackOverflow 和 Datashift 上的这些帖子。\n\n\n# 参考资料\n\n * system-design-primer\n * System Design for Tech Interviews",normalizedContent:"# 如何设计系统\n\n\n# 系统设计过程\n\n\n# 步骤一、约束和用例\n\n对于任何系统设计，第一件应该做的事是：阐明系统的约束并确定系统需要满足哪些用例。\n\n永远不要假设没有明确说明的事情。一定要尽力收集、理解需求，并设计一个很好地涵盖这些要求的解决方案。\n\n例如，url 缩短服务可能只为几千个用户提供服务，但每个用户都可能共享数百万个 url。它可能旨在处理对缩短的 url 的数百万次点击或数十次点击。该服务可能必须提供有关每个缩短的 url 的大量统计信息（这会增加您的数据大小），或者可能根本不需要统计信息。\n\n您还必须考虑预期会发生的用例。您的系统将根据其预期功能进行设计。不要忘记确保你知道面试官一开始没有告诉你的所有要求。\n\n\n# 步骤二、顶层设计\n\n一旦确定了要设计的系统的范围，接下来就要做顶层设计：概述系统架构中所需的所有重要组件。\n\n此时，应该绘制出主要组件以及它们之间的连接。通常，这种顶层设计是基于主流技术的组合。这就要求设计必须熟悉这些技术，了解其利弊以及适合使用的场景。\n\n\n# 步骤三、分析瓶颈\n\n顶层设计很可能会遇到一个或多个瓶颈。这完全没问题，不要指望一个新系统可以立即处理世界上的所有负载。它只需要可扩展，以便您能够使用一些标准工具和技术对其进行改进。\n\n现在有了顶层设计，就要考虑这些组件在系统扩展时面临的瓶颈。也许，系统需要一个负载均衡器和集群来处理用户请求。或者，由于数据容量庞大，以至于需要将数据库分库分表（分布在多台机器上）。这些方案有什么利弊，是否适用？数据库是否太慢，是否需要一些内存缓存？\n\n通常每个解决方案都是某种权衡和取舍。改变某事会使其他事情恶化。然而，重要的是能够讨论这些权衡，并根据定义的约束和用例来衡量它们对系统的影响。\n\n一旦分析清楚核心瓶颈，就可以着手在下一步中去解决它们。\n\n\n# 步骤四、扩展设计\n\n首先，你需要了解以下技术手段：\n\n * 垂直扩展\n * 水平罗占\n * 缓存\n * 负载均衡\n * 数据库复制\n * 数据库分区\n * 异步\n * nosql\n\n在系统设计方面，回顾现实中的架构非常有用。注意使用了哪些技术。继续研究每一项新技术，看看它解决了什么问题，它的替代品是什么，它擅长的地方，以及失败的地方。\n\n一切都是权衡的结果——这是系统设计中最基本的概念之一。\n\n一些推荐的学习资料\n\n * 生产中的深度学习：关于 eyeem 如何构建在大量图像上运行多个深度学习模型的生产系统的精彩故事\n * uber：一篇关于 uber 如何快速扩展的好文章，关于将您的服务分解为分布在许多存储库中的许多微服务。\n * facebook：facebook 如何在直播中同时处理 800,000 名观众\n * kraken.io：如何大规模缩放图像优化，本文将更详细地看一些具体使用的硬件方案，以及部署、监控等重要方面\n * twitter：twitter 如何处理每秒 3,000 张图片上传以及为什么它使用的旧方式现在行不通\n * 最后，twitter 子组件的一些很好的例子：存储数据（video | text）和时间轴（video | text）。\n * 有关更高级的示例，请查看 google、youtube（video | text）、tumblr、stackoverflow 和 datashift 上的这些帖子。\n\n\n# 参考资料\n\n * system-design-primer\n * system design for tech interviews",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统架构面试",frontmatter:{title:"系统架构面试",date:"2020-08-10T10:59:18.000Z",categories:["设计","架构","综合"],tags:["架构","面试"],permalink:"/pages/000a7b/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/01.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%9D%A2%E8%AF%95.html",relativePath:"03.设计/01.架构/00.综合/01.系统架构面试.md",key:"v-cbce72d4",path:"/pages/000a7b/",headers:[{level:2,title:"如何设计一个秒杀系统？",slug:"如何设计一个秒杀系统",normalizedTitle:"如何设计一个秒杀系统？",charIndex:13},{level:3,title:"秒杀系统的挑战",slug:"秒杀系统的挑战",normalizedTitle:"秒杀系统的挑战",charIndex:29},{level:3,title:"秒杀系统的解决思路",slug:"秒杀系统的解决思路",normalizedTitle:"秒杀系统的解决思路",charIndex:111},{level:3,title:"秒杀系统的解决方案",slug:"秒杀系统的解决方案",normalizedTitle:"秒杀系统的解决方案",charIndex:359},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1038}],headersStr:"如何设计一个秒杀系统？ 秒杀系统的挑战 秒杀系统的解决思路 秒杀系统的解决方案 参考资料",content:'# 系统架构面试\n\n\n# 如何设计一个秒杀系统？\n\n\n# 秒杀系统的挑战\n\n秒杀的核心问题就是极高并发处理，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的核心思路是限流和缓存。\n\n\n# 秒杀系统的解决思路\n\n * 系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。\n * 充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%），非常适合使用缓存。\n\n\n# 秒杀系统的解决方案\n\n秒杀系统具体方案如下：\n\n（1）浏览器、客户端拦截重复请求\n\n * 用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。\n * JS 代码中限制用户在限定时间内只允许提交一次请求\n\n基于此，大部分流量已被拦截。\n\n（2）应用层拦截请求\n\n浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：\n\n以页面缓存的方式，针对短时间内的同一个访问源（如同一个 IP、同一个 Session、同一个用户 ID 多次发送 HTTP 请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。\n\n如此限流，又有大部分的流量被拦截\n\n（3）服务层请求拦截与数据缓存\n\n加入有黑客，控制了 10w 台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？\n\n * 读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒 10w 个请求应该没什么问题。\n\n * 写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回"已售罄"的结果。\n\n> 参考：\n> \n>  * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n>  * 如何设计秒杀系统？ - 网易云的回答 - 知乎\n\n\n# 参考资料\n\n * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n * 如何设计秒杀系统？ - 网易云的回答 - 知乎',normalizedContent:'# 系统架构面试\n\n\n# 如何设计一个秒杀系统？\n\n\n# 秒杀系统的挑战\n\n秒杀的核心问题就是极高并发处理，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的核心思路是限流和缓存。\n\n\n# 秒杀系统的解决思路\n\n * 系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。\n * 充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%），非常适合使用缓存。\n\n\n# 秒杀系统的解决方案\n\n秒杀系统具体方案如下：\n\n（1）浏览器、客户端拦截重复请求\n\n * 用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。\n * js 代码中限制用户在限定时间内只允许提交一次请求\n\n基于此，大部分流量已被拦截。\n\n（2）应用层拦截请求\n\n浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：\n\n以页面缓存的方式，针对短时间内的同一个访问源（如同一个 ip、同一个 session、同一个用户 id 多次发送 http 请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。\n\n如此限流，又有大部分的流量被拦截\n\n（3）服务层请求拦截与数据缓存\n\n加入有黑客，控制了 10w 台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？\n\n * 读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒 10w 个请求应该没什么问题。\n\n * 写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回"已售罄"的结果。\n\n> 参考：\n> \n>  * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n>  * 如何设计秒杀系统？ - 网易云的回答 - 知乎\n\n\n# 参考资料\n\n * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n * 如何设计秒杀系统？ - 网易云的回答 - 知乎',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统架构概述",frontmatter:{title:"系统架构概述",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构"],permalink:"/pages/db2390/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/02.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0.html",relativePath:"03.设计/01.架构/00.综合/02.系统架构概述.md",key:"v-1057bb3a",path:"/pages/db2390/",headers:[{level:2,title:"大型系统架构演化",slug:"大型系统架构演化",normalizedTitle:"大型系统架构演化",charIndex:13},{level:3,title:"单机架构",slug:"单机架构",normalizedTitle:"单机架构",charIndex:250},{level:3,title:"应用服务和数据服务分离",slug:"应用服务和数据服务分离",normalizedTitle:"应用服务和数据服务分离",charIndex:432},{level:3,title:"使用缓存改善性能",slug:"使用缓存改善性能",normalizedTitle:"使用缓存改善性能",charIndex:666},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:931},{level:3,title:"数据库读写分离",slug:"数据库读写分离",normalizedTitle:"数据库读写分离",charIndex:1128},{level:3,title:"多级缓存",slug:"多级缓存",normalizedTitle:"多级缓存",charIndex:1481},{level:3,title:"业务拆分",slug:"业务拆分",normalizedTitle:"业务拆分",charIndex:1733},{level:3,title:"分库分表",slug:"分库分表",normalizedTitle:"分库分表",charIndex:2082},{level:3,title:"分布式组件",slug:"分布式组件",normalizedTitle:"分布式组件",charIndex:2256},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:2409},{level:2,title:"架构设计的考量",slug:"架构设计的考量",normalizedTitle:"架构设计的考量",charIndex:2641},{level:3,title:"什么是架构",slug:"什么是架构",normalizedTitle:"什么是架构",charIndex:2709},{level:3,title:"架构设计的目标",slug:"架构设计的目标",normalizedTitle:"架构设计的目标",charIndex:2876},{level:3,title:"架构设计的原则",slug:"架构设计的原则",normalizedTitle:"架构设计的原则",charIndex:3319},{level:4,title:"合适原则",slug:"合适原则",normalizedTitle:"合适原则",charIndex:3356},{level:4,title:"简单原则",slug:"简单原则",normalizedTitle:"简单原则",charIndex:3459},{level:4,title:"演化原则",slug:"演化原则",normalizedTitle:"演化原则",charIndex:3499},{level:4,title:"墨菲定律",slug:"墨菲定律",normalizedTitle:"墨菲定律",charIndex:3541},{level:4,title:"康威定律",slug:"康威定律",normalizedTitle:"康威定律",charIndex:3630},{level:4,title:"二八定律",slug:"二八定律",normalizedTitle:"二八定律",charIndex:727},{level:3,title:"高性能",slug:"高性能",normalizedTitle:"高性能",charIndex:3002},{level:4,title:"性能指标",slug:"性能指标",normalizedTitle:"性能指标",charIndex:3782},{level:4,title:"性能提升手段",slug:"性能提升手段",normalizedTitle:"性能提升手段",charIndex:3970},{level:3,title:"高可用",slug:"高可用",normalizedTitle:"高可用",charIndex:3006},{level:4,title:"无状态应用的高可用",slug:"无状态应用的高可用",normalizedTitle:"无状态应用的高可用",charIndex:4532},{level:4,title:"有状态应用的高可用",slug:"有状态应用的高可用",normalizedTitle:"有状态应用的高可用",charIndex:4826},{level:4,title:"高可用手段",slug:"高可用手段",normalizedTitle:"高可用手段",charIndex:5006},{level:3,title:"扩展性",slug:"扩展性",normalizedTitle:"扩展性",charIndex:3749},{level:3,title:"伸缩性",slug:"伸缩性",normalizedTitle:"伸缩性",charIndex:3753},{level:3,title:"安全性",slug:"安全性",normalizedTitle:"安全性",charIndex:6973},{level:2,title:"常见架构模型",slug:"常见架构模型",normalizedTitle:"常见架构模型",charIndex:7205},{level:3,title:"分层架构",slug:"分层架构",normalizedTitle:"分层架构",charIndex:5832},{level:3,title:"事件驱动架构",slug:"事件驱动架构",normalizedTitle:"事件驱动架构",charIndex:7700},{level:3,title:"微核架构",slug:"微核架构",normalizedTitle:"微核架构",charIndex:8217},{level:3,title:"微服务架构",slug:"微服务架构",normalizedTitle:"微服务架构",charIndex:8592},{level:3,title:"云架构",slug:"云架构",normalizedTitle:"云架构",charIndex:9292},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:10014}],headersStr:"大型系统架构演化 单机架构 应用服务和数据服务分离 使用缓存改善性能 负载均衡 数据库读写分离 多级缓存 业务拆分 分库分表 分布式组件 微服务 架构设计的考量 什么是架构 架构设计的目标 架构设计的原则 合适原则 简单原则 演化原则 墨菲定律 康威定律 二八定律 高性能 性能指标 性能提升手段 高可用 无状态应用的高可用 有状态应用的高可用 高可用手段 扩展性 伸缩性 安全性 常见架构模型 分层架构 事件驱动架构 微核架构 微服务架构 云架构 参考资料",content:'# 系统架构概述\n\n\n# 大型系统架构演化\n\n一个大型系统的架构是一个渐进的演化过程。罗马不是一天建成的，同理，微信、淘宝等大型系统绝不是一蹴而就的。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。\n\n了解大型系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。\n\n大型系统架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。\n\n\n# 单机架构\n\n * 问题：网站运营初期，访问用户少，一台服务器绰绰有余。\n * 特征：应用程序、数据库、文件等所有的资源都在一台服务器上。\n * 描述：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。\n\n\n# 应用服务和数据服务分离\n\n * 问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。\n * 特征：应用服务器、数据库服务器、文件服务器分别独立部署。\n * 描述：三台服务器对性能要求各不相同：\n   * 应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；\n   * 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；\n   * 文件服务器需要存储大量文件，因此需要更大容量的硬盘。\n\n\n# 使用缓存改善性能\n\n * 问题：随着用户逐渐增多，数据库压力太大导致访问延迟。\n * 特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。\n * 描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。\n   * 本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。\n   * 分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。\n\n\n# 负载均衡\n\n * 问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。\n * 特征：多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。\n * 描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。\n\n\n# 数据库读写分离\n\n * 问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。\n * 特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。\n * 描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。\n\n\n# 多级缓存\n\n * 问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。\n * 特征：采用 CDN 和反向代理加快系统的静态资源访问速度。\n * 描述：CDN 和反向代理的基本原理都是缓存，区别在于：\n   * CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；\n   * 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n\n# 业务拆分\n\n * 问题：大型网站的业务场景日益复杂，分为多个产品线。\n * 特征：采用分而治之的手段将整个网站业务分成不同的产品线。系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。\n * 描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n   * 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。\n   * 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。\n\n\n# 分库分表\n\n * 问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。\n * 特征：数据库采用分布式数据库。\n * 描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。\n\n\n# 分布式组件\n\n * 问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。\n * 特征：系统引入 NoSQL 数据库及搜索引擎。\n * 描述：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n\n# 微服务\n\n * 问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。\n * 特征：公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。\n * 描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。\n\n\n# 架构设计的考量\n\n> 每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作。\n\n\n# 什么是架构\n\n架构是一个非常抽象的概念，每个人由于技术的深度、思维的视角等差异，对于架构的理解，各不相同。\n\n这里摘抄网上某段比较精髓的定义：\n\n * 架构是软件系统的顶层设计。\n * 框架是面向编程或配置的半成品。\n * 组件是从技术维度上的复用。\n * 模块是从业务维度上职责的划分。\n * 系统是相互协同可运行的实体。\n\n\n# 架构设计的目标\n\n架构设计的主要目的是为了解决软件系统复杂度带来的问题。\n\n架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n\n关于架构设计的目的，常见的误区有：\n\n * 因为架构很重要，所以要做架构设计\n * 为了高性能、高可用、可扩展，所以要做架构设计\n * 大厂都是这么做的，所以我们也这么做\n * 这种新技术很牛逼，我们也一定要引入\n\n架构的原则：\n\n * 架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n * 驱动技术发展的主要力量是业务发展。\n * 不要盲目跟风大公司的解决方案。\n * 不要盲目追求流行技术，而脱离了业务发展的实际情况。\n * 不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。\n\n\n# 架构设计的原则\n\n> 合适优于先进>演化优于一步到位>简单优于复杂\n\n# 合适原则\n\n没那么多人，却想干那么多活，是失败的第一个主要原因。\n\n没有那么多积累，却想一步登天，是失败的第二个主要原因。\n\n没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。\n\n# 简单原则\n\n再高大上的解决方案如果不能落地，也是白扯。\n\n所以，应对需求\n\n# 演化原则\n\n演化优于一步到位。\n\n不要妄图设计一个一步到位，永久不变的架构。\n\n# 墨菲定律\n\n * 任何事都没有表面看起来那么简单；\n * 所有的事都会比你预计的时间长；\n * 会出错的事总会出错；\n * 如果你担心某种情况发生，那么它就更有可能发生。\n\n# 康威定律\n\n系统设计(产品结构)等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构（简单点说就是，系统的设计受限于设计系统的组织的人员架构形式。\n\n# 二八定律\n\n\n# 高性能\n\n> 性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。\n\n# 性能指标\n\n响应延时、并发处理能力、内存、CPU、IO 开销等都可以视为系统的性能指标。\n\n分析用户体量、日访问量的峰值，估算出为了平稳应对峰值访问流量所需的并发量、吞吐量。如果是应用型系统，性能够用就好，没必要一味追求高性能。比如：用户体量可能还不过万，一天总访问量可能也就一两千 PV，峰值也就几百 QPS，这样的系统如果要考虑每秒几万的 QPS，显然有些多虑了。\n\n# 性能提升手段\n\n常见的性能提升手段有：\n\n * 前端\n   * 浏览器缓存\n   * 静态资源压缩\n   * 合理布局页面\n   * 减少 cookie 传输\n   * CDN\n * 应用服务\n   * 负载均衡和反向代理\n   * 本地缓存\n   * 分布式缓存\n   * 异步消息队列\n   * 集群\n   * 代码层面：使用多线程、改善内存管理\n * 数据库\n   * 索引\n   * 数据库缓存\n   * SQL 优化\n\n> 注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。\n> \n> 使用缓存有两个前提：\n> \n>  * 数据访问热点不均匀，频繁访问的数据应该放在缓存中。\n>  * 数据在某个时间段有效，不会很快过期，否则缓存数据会因已经失效而产生脏读。\n\n\n# 高可用\n\n> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。\n\n高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。\n\n单点系统，是无法保证高可用的。系统自身故障、断电、硬件故障、网络等等，都可能导致服务不可用。高可用方案五花八门，本质上都是通过“冗余”来实现高可用。\n\n# 无状态应用的高可用\n\n无状态应用一般具有幂等性，即**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。**所以，计算在任意节点服务器上执行，结果都一样。\n\n无状态应用的高可用：\n\n * 需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。\n * 任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。\n * 任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。\n\n# 有状态应用的高可用\n\n有状态应用，是指需要存储数据的系统，比如各种分布式存储。和无状态应用相比，有一个本质上的区别：各节点需要通过同步保持数据一致。分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。\n\n# 高可用手段\n\n高可用的常用手段：\n\n * 负载均衡 - 通过负载均衡设备建立集群共同对外提供服务。\n * 备份 - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。\n   * 冷备份 - 数据应该定期备份；\n   * 热备份 - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。\n   * 灾备 - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 灾备数据中心。网站程序和数据定期同步到多个灾备数据中心。\n * 自动化 - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：\n   * 发布过程自动化\n     * 自动化代码管理\n     * 自动化测试\n     * 自动化安全监测\n     * 自动化部署\n   * 运维自动化\n     * 自动化监控\n     * 自动化报警\n     * 自动化失效转移\n     * 自动化失效恢复\n     * 自动化降级\n     * 自动化分配资源\n\n\n# 扩展性\n\n> 可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。\n> \n> 衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。\n> \n> 软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。\n\n主要手段有：\n\n * 分层 - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。\n   \n   * 分层架构的约束：禁止跨层次的调用及逆向调用。\n   * 即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。\n\n * 分割 - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。\n\n * 异步 - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。\n   \n   * 在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；\n   * 在分布式系统中，多个服务器集群通过分布式消息队列实现异步。\n\n * 分布式 - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 CPU、内存、IO 等资源，从而提高系统整体的吞吐量和并发处理能力。\n   \n   * 常用的分布式方案：\n     * 分布式应用和服务\n     * 分布式静态资源\n     * 分布式数据和存储\n     * 分布式计算\n   * 分布式也引入了一些问题：\n     * 服务调用必须通过网络，网络延迟会影响性能。\n     * 服务器越多，宕机概率也越大，导致可用性降低。\n     * 数据一致性非常困难，分布式事务也难以保证。\n     * 网站依赖错综复杂，开发管理维护困难。\n\n\n# 伸缩性\n\n> 衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。\n\n伸缩性是指通过增/减服务器节点数，来灵活的提高/降低系统处理能力。\n\n主要手段有:\n\n * 应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可\n * 缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。\n * 关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。\n * Nosql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。\n\n\n# 安全性\n\n安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。\n\n * 密码 和 手机校验码 进行身份认证\n * 登录、交易等重要操作需要对网络通信进行 加密，存储的敏感数据如用户信息等也进行加密处理\n * 防止机器人程序攻击网站，使用 验证码 进行识别\n * 对常见用于 攻击 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理\n * 对垃圾信息、敏感信息进行 过滤\n * 对交易转账等重要操作根据交易模式和交易信息进行 风险控制\n\n\n# 常见架构模型\n\n\n# 分层架构\n\n分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。\n\n这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。\n\n四层的结构最常见。\n\n\n * 表现层（presentation）：用户界面，负责视觉和用户互动\n * 业务层（business）：实现业务逻辑\n * 持久层（persistence）：提供数据，SQL 语句就放在这一层\n * 数据库（database） ：保存数据\n\n优点\n\n * 结构简单，容易理解和开发\n * 不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构\n * 每一层都可以独立测试，其他层的接口通过模拟解决\n\n缺点\n\n * 一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时\n * 部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布\n * 软件升级时，可能需要整个服务暂停\n * 扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难\n\n\n# 事件驱动架构\n\n事件（event）是状态发生变化时，软件发出的通知。\n\n事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。\n\n\n * 事件队列（event queue）：接收事件的入口\n * 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n * 事件通道（event channel）：分发器与处理器之间的联系渠道\n * 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。\n\n\n\n优点\n\n * 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好\n * 适用性广，各种类型的项目都可以用\n * 性能较好，因为事件的异步本质，软件不易产生堵塞\n * 事件处理器可以独立地加载和卸载，容易部署\n\n缺点\n\n * 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂\n * 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚\n * 分布式和异步特性导致这个架构较难测试\n\n\n# 微核架构\n\n微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。\n\n内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。\n\n\n\n优点\n\n * 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可\n * 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，\n * 可定制性高，适应不同的开发需要\n * 可以渐进式地开发，逐步增加功能\n\n缺点\n\n * 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式\n * 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制\n\n\n# 微服务架构\n\n微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。\n\n每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 REST、SOAP）联系。\n\n\n\n微服务架构分成三种实现模式。\n\n * RESTful API 模式：服务通过 API 提供，云服务就属于这一类\n * RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部\n * 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群\n\n优点\n\n * 扩展性好，各个服务之间低耦合\n * 容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元\n * 容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级\n * 易于测试，可以单独测试每一个服务\n\n缺点\n\n * 由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。\n * 一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。\n * 分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。\n\n\n# 云架构\n\n云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。\n\n它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。\n\n\n\n这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。\n\n * 处理单元：实现业务逻辑\n * 虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。\n\n虚拟中间件又包含四个组件。\n\n>  * 消息中间件（Messaging Grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。\n>  * 数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。\n>  * 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元\n>  * 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。\n\n优点\n\n * 高负载，高扩展性\n * 动态部署\n\n缺点\n\n * 实现复杂，成本较高\n * 主要适合网站类应用，不合适大量数据吞吐的大型数据库应用\n * 较难测试\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《从 0 开始学架构》\n * 软件架构入门- 阮一峰的网络日志',normalizedContent:'# 系统架构概述\n\n\n# 大型系统架构演化\n\n一个大型系统的架构是一个渐进的演化过程。罗马不是一天建成的，同理，微信、淘宝等大型系统绝不是一蹴而就的。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。\n\n了解大型系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。\n\n大型系统架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。\n\n\n# 单机架构\n\n * 问题：网站运营初期，访问用户少，一台服务器绰绰有余。\n * 特征：应用程序、数据库、文件等所有的资源都在一台服务器上。\n * 描述：通常服务器操作系统使用 linux，应用程序使用 php 开发，然后部署在 apache 上，数据库使用 mysql，通俗称为 lamp。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。\n\n\n# 应用服务和数据服务分离\n\n * 问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。\n * 特征：应用服务器、数据库服务器、文件服务器分别独立部署。\n * 描述：三台服务器对性能要求各不相同：\n   * 应用服务器要处理大量业务逻辑，因此需要更快更强大的 cpu；\n   * 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；\n   * 文件服务器需要存储大量文件，因此需要更大容量的硬盘。\n\n\n# 使用缓存改善性能\n\n * 问题：随着用户逐渐增多，数据库压力太大导致访问延迟。\n * 特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。\n * 描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。\n   * 本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。\n   * 分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。\n\n\n# 负载均衡\n\n * 问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。\n * 特征：多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。\n * 描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。\n\n\n# 数据库读写分离\n\n * 问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。\n * 特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。\n * 描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。\n\n\n# 多级缓存\n\n * 问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。\n * 特征：采用 cdn 和反向代理加快系统的静态资源访问速度。\n * 描述：cdn 和反向代理的基本原理都是缓存，区别在于：\n   * cdn 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；\n   * 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n\n# 业务拆分\n\n * 问题：大型网站的业务场景日益复杂，分为多个产品线。\n * 特征：采用分而治之的手段将整个网站业务分成不同的产品线。系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。\n * 描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n   * 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。\n   * 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。\n\n\n# 分库分表\n\n * 问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。\n * 特征：数据库采用分布式数据库。\n * 描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。\n\n\n# 分布式组件\n\n * 问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。\n * 特征：系统引入 nosql 数据库及搜索引擎。\n * 描述：nosql 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n\n# 微服务\n\n * 问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。\n * 特征：公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。\n * 描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。\n\n\n# 架构设计的考量\n\n> 每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作。\n\n\n# 什么是架构\n\n架构是一个非常抽象的概念，每个人由于技术的深度、思维的视角等差异，对于架构的理解，各不相同。\n\n这里摘抄网上某段比较精髓的定义：\n\n * 架构是软件系统的顶层设计。\n * 框架是面向编程或配置的半成品。\n * 组件是从技术维度上的复用。\n * 模块是从业务维度上职责的划分。\n * 系统是相互协同可运行的实体。\n\n\n# 架构设计的目标\n\n架构设计的主要目的是为了解决软件系统复杂度带来的问题。\n\n架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n\n关于架构设计的目的，常见的误区有：\n\n * 因为架构很重要，所以要做架构设计\n * 为了高性能、高可用、可扩展，所以要做架构设计\n * 大厂都是这么做的，所以我们也这么做\n * 这种新技术很牛逼，我们也一定要引入\n\n架构的原则：\n\n * 架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n * 驱动技术发展的主要力量是业务发展。\n * 不要盲目跟风大公司的解决方案。\n * 不要盲目追求流行技术，而脱离了业务发展的实际情况。\n * 不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。\n\n\n# 架构设计的原则\n\n> 合适优于先进>演化优于一步到位>简单优于复杂\n\n# 合适原则\n\n没那么多人，却想干那么多活，是失败的第一个主要原因。\n\n没有那么多积累，却想一步登天，是失败的第二个主要原因。\n\n没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。\n\n# 简单原则\n\n再高大上的解决方案如果不能落地，也是白扯。\n\n所以，应对需求\n\n# 演化原则\n\n演化优于一步到位。\n\n不要妄图设计一个一步到位，永久不变的架构。\n\n# 墨菲定律\n\n * 任何事都没有表面看起来那么简单；\n * 所有的事都会比你预计的时间长；\n * 会出错的事总会出错；\n * 如果你担心某种情况发生，那么它就更有可能发生。\n\n# 康威定律\n\n系统设计(产品结构)等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构（简单点说就是，系统的设计受限于设计系统的组织的人员架构形式。\n\n# 二八定律\n\n\n# 高性能\n\n> 性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。\n\n# 性能指标\n\n响应延时、并发处理能力、内存、cpu、io 开销等都可以视为系统的性能指标。\n\n分析用户体量、日访问量的峰值，估算出为了平稳应对峰值访问流量所需的并发量、吞吐量。如果是应用型系统，性能够用就好，没必要一味追求高性能。比如：用户体量可能还不过万，一天总访问量可能也就一两千 pv，峰值也就几百 qps，这样的系统如果要考虑每秒几万的 qps，显然有些多虑了。\n\n# 性能提升手段\n\n常见的性能提升手段有：\n\n * 前端\n   * 浏览器缓存\n   * 静态资源压缩\n   * 合理布局页面\n   * 减少 cookie 传输\n   * cdn\n * 应用服务\n   * 负载均衡和反向代理\n   * 本地缓存\n   * 分布式缓存\n   * 异步消息队列\n   * 集群\n   * 代码层面：使用多线程、改善内存管理\n * 数据库\n   * 索引\n   * 数据库缓存\n   * sql 优化\n\n> 注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。\n> \n> 使用缓存有两个前提：\n> \n>  * 数据访问热点不均匀，频繁访问的数据应该放在缓存中。\n>  * 数据在某个时间段有效，不会很快过期，否则缓存数据会因已经失效而产生脏读。\n\n\n# 高可用\n\n> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。\n\n高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。\n\n单点系统，是无法保证高可用的。系统自身故障、断电、硬件故障、网络等等，都可能导致服务不可用。高可用方案五花八门，本质上都是通过“冗余”来实现高可用。\n\n# 无状态应用的高可用\n\n无状态应用一般具有幂等性，即**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。**所以，计算在任意节点服务器上执行，结果都一样。\n\n无状态应用的高可用：\n\n * 需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。\n * 任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。\n * 任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。\n\n# 有状态应用的高可用\n\n有状态应用，是指需要存储数据的系统，比如各种分布式存储。和无状态应用相比，有一个本质上的区别：各节点需要通过同步保持数据一致。分布式领域里面有一个著名的 cap 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。\n\n# 高可用手段\n\n高可用的常用手段：\n\n * 负载均衡 - 通过负载均衡设备建立集群共同对外提供服务。\n * 备份 - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。\n   * 冷备份 - 数据应该定期备份；\n   * 热备份 - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。\n   * 灾备 - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 灾备数据中心。网站程序和数据定期同步到多个灾备数据中心。\n * 自动化 - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：\n   * 发布过程自动化\n     * 自动化代码管理\n     * 自动化测试\n     * 自动化安全监测\n     * 自动化部署\n   * 运维自动化\n     * 自动化监控\n     * 自动化报警\n     * 自动化失效转移\n     * 自动化失效恢复\n     * 自动化降级\n     * 自动化分配资源\n\n\n# 扩展性\n\n> 可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。\n> \n> 衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。\n> \n> 软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。\n\n主要手段有：\n\n * 分层 - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。\n   \n   * 分层架构的约束：禁止跨层次的调用及逆向调用。\n   * 即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。\n\n * 分割 - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。\n\n * 异步 - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。\n   \n   * 在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；\n   * 在分布式系统中，多个服务器集群通过分布式消息队列实现异步。\n\n * 分布式 - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 cpu、内存、io 等资源，从而提高系统整体的吞吐量和并发处理能力。\n   \n   * 常用的分布式方案：\n     * 分布式应用和服务\n     * 分布式静态资源\n     * 分布式数据和存储\n     * 分布式计算\n   * 分布式也引入了一些问题：\n     * 服务调用必须通过网络，网络延迟会影响性能。\n     * 服务器越多，宕机概率也越大，导致可用性降低。\n     * 数据一致性非常困难，分布式事务也难以保证。\n     * 网站依赖错综复杂，开发管理维护困难。\n\n\n# 伸缩性\n\n> 衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。\n\n伸缩性是指通过增/减服务器节点数，来灵活的提高/降低系统处理能力。\n\n主要手段有:\n\n * 应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可\n * 缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。\n * 关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。\n * nosql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。\n\n\n# 安全性\n\n安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。\n\n * 密码 和 手机校验码 进行身份认证\n * 登录、交易等重要操作需要对网络通信进行 加密，存储的敏感数据如用户信息等也进行加密处理\n * 防止机器人程序攻击网站，使用 验证码 进行识别\n * 对常见用于 攻击 网站的 xss 攻击、sql 注入、进行编码转换等相应处理\n * 对垃圾信息、敏感信息进行 过滤\n * 对交易转账等重要操作根据交易模式和交易信息进行 风险控制\n\n\n# 常见架构模型\n\n\n# 分层架构\n\n分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。\n\n这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。\n\n四层的结构最常见。\n\n\n * 表现层（presentation）：用户界面，负责视觉和用户互动\n * 业务层（business）：实现业务逻辑\n * 持久层（persistence）：提供数据，sql 语句就放在这一层\n * 数据库（database） ：保存数据\n\n优点\n\n * 结构简单，容易理解和开发\n * 不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构\n * 每一层都可以独立测试，其他层的接口通过模拟解决\n\n缺点\n\n * 一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时\n * 部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布\n * 软件升级时，可能需要整个服务暂停\n * 扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难\n\n\n# 事件驱动架构\n\n事件（event）是状态发生变化时，软件发出的通知。\n\n事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。\n\n\n * 事件队列（event queue）：接收事件的入口\n * 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n * 事件通道（event channel）：分发器与处理器之间的联系渠道\n * 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。\n\n\n\n优点\n\n * 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好\n * 适用性广，各种类型的项目都可以用\n * 性能较好，因为事件的异步本质，软件不易产生堵塞\n * 事件处理器可以独立地加载和卸载，容易部署\n\n缺点\n\n * 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂\n * 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚\n * 分布式和异步特性导致这个架构较难测试\n\n\n# 微核架构\n\n微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。\n\n内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。\n\n\n\n优点\n\n * 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可\n * 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，\n * 可定制性高，适应不同的开发需要\n * 可以渐进式地开发，逐步增加功能\n\n缺点\n\n * 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式\n * 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制\n\n\n# 微服务架构\n\n微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 soa）的升级。\n\n每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 rest、soap）联系。\n\n\n\n微服务架构分成三种实现模式。\n\n * restful api 模式：服务通过 api 提供，云服务就属于这一类\n * restful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部\n * 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群\n\n优点\n\n * 扩展性好，各个服务之间低耦合\n * 容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元\n * 容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级\n * 易于测试，可以单独测试每一个服务\n\n缺点\n\n * 由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。\n * 一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。\n * 分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。\n\n\n# 云架构\n\n云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。\n\n它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。\n\n\n\n这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。\n\n * 处理单元：实现业务逻辑\n * 虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。\n\n虚拟中间件又包含四个组件。\n\n>  * 消息中间件（messaging grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。\n>  * 数据中间件（data grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。\n>  * 处理中间件（processing grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元\n>  * 部署中间件（deployment manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。\n\n优点\n\n * 高负载，高扩展性\n * 动态部署\n\n缺点\n\n * 实现复杂，成本较高\n * 主要适合网站类应用，不合适大量数据吞吐的大型数据库应用\n * 较难测试\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《从 0 开始学架构》\n * 软件架构入门- 阮一峰的网络日志',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统高性能架构",frontmatter:{title:"系统高性能架构",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构","性能"],permalink:"/pages/a49605/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/03.%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/03.系统高性能架构.md",key:"v-2443e46d",path:"/pages/a49605/",headers:[{level:2,title:"性能简介",slug:"性能简介",normalizedTitle:"性能简介",charIndex:14},{level:3,title:"计算机资源",slug:"计算机资源",normalizedTitle:"计算机资源",charIndex:173},{level:3,title:"性能指标",slug:"性能指标",normalizedTitle:"性能指标",charIndex:92},{level:4,title:"响应时间",slug:"响应时间",normalizedTitle:"响应时间",charIndex:299},{level:4,title:"并发数",slug:"并发数",normalizedTitle:"并发数",charIndex:307},{level:4,title:"吞吐量",slug:"吞吐量",normalizedTitle:"吞吐量",charIndex:314},{level:4,title:"资源分配使用率",slug:"资源分配使用率",normalizedTitle:"资源分配使用率",charIndex:339},{level:3,title:"性能测试",slug:"性能测试",normalizedTitle:"性能测试",charIndex:283},{level:3,title:"性能优化策略",slug:"性能优化策略",normalizedTitle:"性能优化策略",charIndex:1321},{level:2,title:"应用服务性能优化",slug:"应用服务性能优化",normalizedTitle:"应用服务性能优化",charIndex:1487},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:1092},{level:3,title:"并发模型",slug:"并发模型",normalizedTitle:"并发模型",charIndex:1747},{level:4,title:"PPC",slug:"ppc",normalizedTitle:"ppc",charIndex:2013},{level:4,title:"prefork",slug:"prefork",normalizedTitle:"prefork",charIndex:2287},{level:4,title:"TPC",slug:"tpc",normalizedTitle:"tpc",charIndex:2868},{level:4,title:"prethread",slug:"prethread",normalizedTitle:"prethread",charIndex:3579},{level:4,title:"Reactor",slug:"reactor",normalizedTitle:"reactor",charIndex:4164},{level:3,title:"异步操作",slug:"异步操作",normalizedTitle:"异步操作",charIndex:4692},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:4849},{level:3,title:"代码优化",slug:"代码优化",normalizedTitle:"代码优化",charIndex:5021},{level:4,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:2005},{level:5,title:"线程安全问题",slug:"线程安全问题",normalizedTitle:"线程安全问题",charIndex:5303},{level:4,title:"资源复用",slug:"资源复用",normalizedTitle:"资源复用",charIndex:5462},{level:4,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:5546},{level:4,title:"垃圾回收",slug:"垃圾回收",normalizedTitle:"垃圾回收",charIndex:5573},{level:2,title:"存储性能优化",slug:"存储性能优化",normalizedTitle:"存储性能优化",charIndex:5672},{level:3,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:262},{level:4,title:"数据库读写分离",slug:"数据库读写分离",normalizedTitle:"数据库读写分离",charIndex:5690},{level:4,title:"数据库分库分表",slug:"数据库分库分表",normalizedTitle:"数据库分库分表",charIndex:5747},{level:4,title:"Nosql",slug:"nosql",normalizedTitle:"nosql",charIndex:5833},{level:3,title:"文件存储",slug:"文件存储",normalizedTitle:"文件存储",charIndex:6399},{level:4,title:"机械键盘和固态硬盘",slug:"机械键盘和固态硬盘",normalizedTitle:"机械键盘和固态硬盘",charIndex:6407},{level:4,title:"B+数和 LSM 树",slug:"b-数和-lsm-树",normalizedTitle:"b+数和 lsm 树",charIndex:6448},{level:4,title:"RAID 和 HDFS",slug:"raid-和-hdfs",normalizedTitle:"raid 和 hdfs",charIndex:6730},{level:2,title:"前端性能优化",slug:"前端性能优化",normalizedTitle:"前端性能优化",charIndex:1480},{level:3,title:"浏览器访问优化",slug:"浏览器访问优化",normalizedTitle:"浏览器访问优化",charIndex:7042},{level:3,title:"CDN",slug:"cdn",normalizedTitle:"cdn",charIndex:7603},{level:3,title:"反向代理",slug:"反向代理",normalizedTitle:"反向代理",charIndex:7688},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7921}],headersStr:"性能简介 计算机资源 性能指标 响应时间 并发数 吞吐量 资源分配使用率 性能测试 性能优化策略 应用服务性能优化 缓存 并发模型 PPC prefork TPC prethread Reactor 异步操作 负载均衡 代码优化 多线程 线程安全问题 资源复用 数据结构 垃圾回收 存储性能优化 数据库 数据库读写分离 数据库分库分表 Nosql 文件存储 机械键盘和固态硬盘 B+数和 LSM 树 RAID 和 HDFS 前端性能优化 浏览器访问优化 CDN 反向代理 参考资料",content:"# 系统高性能架构\n\n\n# 性能简介\n\n要设计高性能的系统架构，应该有以下的思维步骤：\n\n首先，要明确影响性能的因素有哪些？性能的指标有哪些？——做到有的放矢。\n\n其次，要了解如何测试性能指标？性能优化，必须要有前后的效果对比，才能证明性能确实有改善。\n\n接下来，学习针对不同场景下，不同性指标的优化策略以及具体实施方案。——见招拆招。\n\n\n# 计算机资源\n\n了解性能指标前，需要先知道哪些计算机资源会影响性能。一般来说，影响性能的计算机资源包括：\n\n * CPU\n * 内存\n * 磁盘 I/O\n * 网络 I/O\n * 数据库\n * 锁竞争\n\n\n# 性能指标\n\n性能测试的主要指标有：\n\n * 响应时间\n * 并发数\n * 吞吐量\n   * QPS\n   * TPS\n * 资源分配使用率\n\n# 响应时间\n\n响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。\n\n响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。\n\n响应时间可以进一步细分：\n\n * 客户端响应时间\n * 网络响应时间\n * 服务端响应时间\n * 数据库响应时间\n\n# 并发数\n\n并发数是指系统能同时处理的请求、事务数。\n\n系统自身的 CPU 处理能力、内存、以及系统自身的线程复用、锁竞争等都会影响并发数。\n\n# 吞吐量\n\n吞吐量计算公式：\n\n吞吐量 = 并发数 / 平均响应时间\n\n\n吞吐量越大，性能越好。\n\n一般，系统呈现给外部的最常见的吞吐量指标，就是：\n\n * QPS(每秒查询数) - 即系统每秒可以处理的读请求。\n * TPS(每秒事务数) - 即系统每秒可以处理的写请求。\n\n而在系统内部，存在以下吞吐量：\n\n * 磁盘吞吐量 - 体现了磁盘随机读写的性能。\n * 网络吞吐量 - 除了受限于网络带宽，CPU 的处理能力、网卡、防火墙、外部接口以及 I/O、系统 IO 算法都会影响到网络吞吐量。\n\n# 资源分配使用率\n\n通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 、对象与线程数来表示资源使用率。这些指标也是系统监控的重要参数。\n\n\n# 性能测试\n\n性能测试手段：\n\n * 性能测试\n * 负载测试\n * 压力测试\n * 稳定性测试\n\n对于 Java 应用而言，最简单的，可以使用 Jmeter 进行性能测试。\n\n性能测试报告示例：\n\n\n#### 性能测试的问题\n\n性能测试时，需要注意一些问题：\n\n * 热身问题 - 系统刚开始运行时，自身可能加载缓存，JVM 可能会优化热点代码等，这些行为都可能使得前后有较大的性能差异。所以，性能测试时，应该先跳过一段热身时间，等趋于稳定后，再开始性能测试。\n * 测试结果不稳定 - 性能测试中，有很多不稳定的因素，如环境、网络等，几乎不可能每次都是一样的结果。所以应该多次测试，求平均值。\n * 多 JVM 情况下的影响 - 应尽量避免一台机器部署多个 JVM 的情况。因为任意一个 JVM 都拥有整个系统的资源使用权，所以在性能测试时，可能会彼此干扰。\n\n\n# 性能优化策略\n\n 1. 性能分析 - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。\n 2. 性能优化 - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。\n\n\n# 应用服务性能优化\n\n\n# 缓存\n\n网站性能优化第一定律：第一优先考虑使用缓存提升性能。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。\n\n * 单点应用可以使用进程内缓存（如：ConcurrentHashMap、Caffeine）；\n * 分布式应用可以使用分布式缓存（如：Redis、Memcached），或进程缓存+分布式缓存的多级缓存方案。\n\n> 缓存解决方案请参考：缓存基本原理\n\n\n# 并发模型\n\n高并发需要根据两个条件划分：连接数量，请求数量。\n\n * 海量连接（成千上万）海量请求：例如抢购，双十一等\n * 常量连接（几十上百）海量请求：例如中间件\n * 海量连接常量请求：例如门户网站\n * 常量连接常量请求：例如内部运营系统，管理系统\n\n单服务器高性能的关键之一就是服务器采取的并发模型\n\n * 服务器如何管理连接。\n * 服务器如何处理请求。\n\n以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。\n\n * I/O 模型：阻塞、非阻塞、同步、异步。\n * 进程模型：单进程、多进程、多线程。\n\n# PPC\n\nPPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。基本的流程图是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程“fork”子进程（图中 fork）。\n * 子进程处理连接的读写请求（图中子进程 read、业务处理、write）。\n * 子进程关闭连接（图中子进程中的 close）。\n\n这种模式的缺点：\n\n * fork 代价高\n * 父子进程通信复杂\n * 支持的并发连接数量有限\n\n# prefork\n\nPPC 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。\n\n顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：\n\n\n\nprefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 Linux 2.6 版本后内核已经解决了 accept 惊群问题。\n\nprefork 模式和 PPC 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。Apache 服务器提供了 MPM prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。\n\n# TPC\n\nTPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。\n\nTPC 的基本流程是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程创建子线程（图中 pthread）。\n * 子线程处理连接的读写请求（图中子线程 read、业务处理、write）。\n * 子线程关闭连接（图中子线程中的 close）。\n\n注意，和 PPC 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。\n\nTPC 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：\n\n * 创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。\n * 无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。\n * 多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。\n\n除了引入了新的问题，TPC 还是存在 CPU 线程调度和切换代价的问题。因此，TPC 方案本质上和 PPC 方案基本类似，在并发几百连接的场景下，反而更多地是采用 PPC 的方案，因为 PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。\n\n# prethread\n\nTPC 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。\n\n和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。\n\n由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：\n\n * 主进程 accept，然后将连接交给某个线程处理。\n * 子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：\n\n\n\nApache 服务器的 MPM worker 模式本质上就是一种 prethread 方案，但稍微做了改进。Apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。\n\nprethread 理论上可以比 prefork 支持更多的并发连接，Apache 服务器 MPM worker 模式默认支持 16 × 25 = 400 个并发处理线程。\n\n# Reactor\n\nI/O 多路复用技术归纳起来有两个关键实现点：\n\n * 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。\n * 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。\n\nI/O 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题\n\nReactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。初看 Reactor 的实现是比较简单的，但实际上结合不同的业务场景，Reactor 模式的具体实现方案灵活多变，主要体现在：\n\n * Reactor 的数量可以变化：可以是一个 Reactor，也可以是多个 Reactor。\n * 资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。\n\n最终 Reactor 模式有这三种典型的实现方案：\n\n * 单 Reactor 单进程 / 线程。\n * 单 Reactor 多线程。\n * 多 Reactor 多进程 / 线程。\n\n\n# 异步操作\n\n异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。\n\n异步处理一般是通过分布式消息队列的方式。\n\n异步处理可以解决以下问题：\n\n * 异步响应\n * 应用解耦\n * 流量削锋\n * 日志处理\n * 消息通讯\n\n\n# 负载均衡\n\n在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。\n\n高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。\n\n> 缓存解决方案请参考：负载均衡\n\n\n# 代码优化\n\n# 多线程\n\n从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。\n\n线程数并非越多越好，那么启动多少线程合适呢？\n\n有个参考公式：\n\n启动线程数 = (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数\n\n\n最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。\n\n * 如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；\n * 相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并发，提高系统吞吐量。\n\n# 线程安全问题\n\n线程安全问题时指多个线程并发访问某个资源，导致数据混乱。\n\n解决手段有：\n\n * 将对象设计为无状态对象 - 典型应用：Servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。\n * 使用局部对象\n * 并发访问资源时使用锁 - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。\n\n# 资源复用\n\n应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。\n\n# 数据结构\n\n根据具体场景，选择合适的数据结构。\n\n# 垃圾回收\n\n如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。\n\n\n# 存储性能优化\n\n\n# 数据库\n\n# 数据库读写分离\n\n读写分离的基本原理是将数据库读写操作分散到不同的节点上\n\n> 详细解决方案参考：读写分离\n\n# 数据库分库分表\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。\n\n> 详细解决方案参考：分库分表\n\n# Nosql\n\n关系型数据库的优势在于：存储结构化数据，有利于进行各种复杂查询。\n\n但是，它也存在一些缺点：\n\n * 关系数据库存储的是行记录，无法存储数据结构\n * 关系数据库的 schema 扩展很不方便\n * 关系数据库在大数据场景下 I/O 较高\n * 关系数据库的全文搜索功能比较弱\n\n为了解决上述问题，分别诞生了解决不同问题的 Nosql 数据库。\n\n常见的 NoSQL 数据库可以分为四类：\n\n * K-V 数据库：KV 存储非常适合存储不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。以 Redis 为代表。\n * 列式数据库：适合于批量数据处理和即时查询，解决关系数据库大数据场景下的 I/O 问题。以 HBase 为代表。\n * 文档数据库：文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题。文档数据库通常以 JSON 或 XML 格式存储数据。以 MongoDB 为代表。\n * 全文搜索引擎：解决关系型数据库全文搜索功能较弱的问题。以 Elasticsearch 为代表。\n\n> 详情参考：Nosql 技术选型\n\n\n# 文件存储\n\n# 机械键盘和固态硬盘\n\n考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。\n\n# B+数和 LSM 树\n\n传统关系数据库的数据库索引一般都使用两级索引的 B+ 树 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。\n\n由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。\n\n许多 Nosql 数据库中的索引采用 LSM 树 作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树。\n\n# RAID 和 HDFS\n\nRAID 是 Redundant Array of Independent Disks 的缩写，中文简称为独立冗余磁盘阵列。\n\nRAID 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。\n\nHDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 MapReduce 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。\n\nHDFS 对数据存储空间的管理以数据块（Block）为单位，默认为 64 MB。所以，HDFS 更适合存储较大的文件。\n\n\n# 前端性能优化\n\n\n# 浏览器访问优化\n\n 1. 减少 HTTP 请求 - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。\n 2. 使用浏览器缓存 - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 Cache-Control 和 Expires 属性，可设定浏览器缓存。\n 3. 启用压缩 - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。\n 4. CSS 放在页面最上面，JavaScript 放在页面最下面 - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。\n 5. 减少 Cookie 传输 - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。\n\n\n# CDN\n\nCDN 一般缓存的是静态资源。\n\nCDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。\n\n\n\n\n# 反向代理\n\n传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。\n\n\n\n反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。\n\n反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。\n\n因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * Java 性能调优实战",normalizedContent:"# 系统高性能架构\n\n\n# 性能简介\n\n要设计高性能的系统架构，应该有以下的思维步骤：\n\n首先，要明确影响性能的因素有哪些？性能的指标有哪些？——做到有的放矢。\n\n其次，要了解如何测试性能指标？性能优化，必须要有前后的效果对比，才能证明性能确实有改善。\n\n接下来，学习针对不同场景下，不同性指标的优化策略以及具体实施方案。——见招拆招。\n\n\n# 计算机资源\n\n了解性能指标前，需要先知道哪些计算机资源会影响性能。一般来说，影响性能的计算机资源包括：\n\n * cpu\n * 内存\n * 磁盘 i/o\n * 网络 i/o\n * 数据库\n * 锁竞争\n\n\n# 性能指标\n\n性能测试的主要指标有：\n\n * 响应时间\n * 并发数\n * 吞吐量\n   * qps\n   * tps\n * 资源分配使用率\n\n# 响应时间\n\n响应时间(rt)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。\n\n响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。\n\n响应时间可以进一步细分：\n\n * 客户端响应时间\n * 网络响应时间\n * 服务端响应时间\n * 数据库响应时间\n\n# 并发数\n\n并发数是指系统能同时处理的请求、事务数。\n\n系统自身的 cpu 处理能力、内存、以及系统自身的线程复用、锁竞争等都会影响并发数。\n\n# 吞吐量\n\n吞吐量计算公式：\n\n吞吐量 = 并发数 / 平均响应时间\n\n\n吞吐量越大，性能越好。\n\n一般，系统呈现给外部的最常见的吞吐量指标，就是：\n\n * qps(每秒查询数) - 即系统每秒可以处理的读请求。\n * tps(每秒事务数) - 即系统每秒可以处理的写请求。\n\n而在系统内部，存在以下吞吐量：\n\n * 磁盘吞吐量 - 体现了磁盘随机读写的性能。\n * 网络吞吐量 - 除了受限于网络带宽，cpu 的处理能力、网卡、防火墙、外部接口以及 i/o、系统 io 算法都会影响到网络吞吐量。\n\n# 资源分配使用率\n\n通常由 cpu 占用率、内存使用率、磁盘 i/o、网络 i/o 、对象与线程数来表示资源使用率。这些指标也是系统监控的重要参数。\n\n\n# 性能测试\n\n性能测试手段：\n\n * 性能测试\n * 负载测试\n * 压力测试\n * 稳定性测试\n\n对于 java 应用而言，最简单的，可以使用 jmeter 进行性能测试。\n\n性能测试报告示例：\n\n\n#### 性能测试的问题\n\n性能测试时，需要注意一些问题：\n\n * 热身问题 - 系统刚开始运行时，自身可能加载缓存，jvm 可能会优化热点代码等，这些行为都可能使得前后有较大的性能差异。所以，性能测试时，应该先跳过一段热身时间，等趋于稳定后，再开始性能测试。\n * 测试结果不稳定 - 性能测试中，有很多不稳定的因素，如环境、网络等，几乎不可能每次都是一样的结果。所以应该多次测试，求平均值。\n * 多 jvm 情况下的影响 - 应尽量避免一台机器部署多个 jvm 的情况。因为任意一个 jvm 都拥有整个系统的资源使用权，所以在性能测试时，可能会彼此干扰。\n\n\n# 性能优化策略\n\n 1. 性能分析 - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、cpu，可能是代码或架构设计不合理，又或者是系统资源确实不足。\n 2. 性能优化 - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。\n\n\n# 应用服务性能优化\n\n\n# 缓存\n\n网站性能优化第一定律：第一优先考虑使用缓存提升性能。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。\n\n * 单点应用可以使用进程内缓存（如：concurrenthashmap、caffeine）；\n * 分布式应用可以使用分布式缓存（如：redis、memcached），或进程缓存+分布式缓存的多级缓存方案。\n\n> 缓存解决方案请参考：缓存基本原理\n\n\n# 并发模型\n\n高并发需要根据两个条件划分：连接数量，请求数量。\n\n * 海量连接（成千上万）海量请求：例如抢购，双十一等\n * 常量连接（几十上百）海量请求：例如中间件\n * 海量连接常量请求：例如门户网站\n * 常量连接常量请求：例如内部运营系统，管理系统\n\n单服务器高性能的关键之一就是服务器采取的并发模型\n\n * 服务器如何管理连接。\n * 服务器如何处理请求。\n\n以上两个设计点最终都和操作系统的 i/o 模型及进程模型相关。\n\n * i/o 模型：阻塞、非阻塞、同步、异步。\n * 进程模型：单进程、多进程、多线程。\n\n# ppc\n\nppc 是 process per connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 unix 网络服务器所采用的模型。基本的流程图是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程“fork”子进程（图中 fork）。\n * 子进程处理连接的读写请求（图中子进程 read、业务处理、write）。\n * 子进程关闭连接（图中子进程中的 close）。\n\n这种模式的缺点：\n\n * fork 代价高\n * 父子进程通信复杂\n * 支持的并发连接数量有限\n\n# prefork\n\nppc 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。\n\n顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：\n\n\n\nprefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 linux 2.6 版本后内核已经解决了 accept 惊群问题。\n\nprefork 模式和 ppc 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。apache 服务器提供了 mpm prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。\n\n# tpc\n\ntpc 是 thread per connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，tpc 实际上是解决或者弱化了 ppc fork 代价高的问题和父子进程通信复杂的问题。\n\ntpc 的基本流程是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程创建子线程（图中 pthread）。\n * 子线程处理连接的读写请求（图中子线程 read、业务处理、write）。\n * 子线程关闭连接（图中子线程中的 close）。\n\n注意，和 ppc 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。\n\ntpc 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：\n\n * 创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。\n * 无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。\n * 多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。\n\n除了引入了新的问题，tpc 还是存在 cpu 线程调度和切换代价的问题。因此，tpc 方案本质上和 ppc 方案基本类似，在并发几百连接的场景下，反而更多地是采用 ppc 的方案，因为 ppc 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。\n\n# prethread\n\ntpc 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。\n\n和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。\n\n由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：\n\n * 主进程 accept，然后将连接交给某个线程处理。\n * 子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：\n\n\n\napache 服务器的 mpm worker 模式本质上就是一种 prethread 方案，但稍微做了改进。apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。\n\nprethread 理论上可以比 prefork 支持更多的并发连接，apache 服务器 mpm worker 模式默认支持 16 × 25 = 400 个并发处理线程。\n\n# reactor\n\ni/o 多路复用技术归纳起来有两个关键实现点：\n\n * 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。\n * 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。\n\ni/o 多路复用结合线程池，完美地解决了 ppc 和 tpc 的问题\n\nreactor 模式的核心组成部分包括 reactor 和处理资源池（进程池或线程池），其中 reactor 负责监听和分配事件，处理资源池负责处理事件。初看 reactor 的实现是比较简单的，但实际上结合不同的业务场景，reactor 模式的具体实现方案灵活多变，主要体现在：\n\n * reactor 的数量可以变化：可以是一个 reactor，也可以是多个 reactor。\n * 资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。\n\n最终 reactor 模式有这三种典型的实现方案：\n\n * 单 reactor 单进程 / 线程。\n * 单 reactor 多线程。\n * 多 reactor 多进程 / 线程。\n\n\n# 异步操作\n\n异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。\n\n异步处理一般是通过分布式消息队列的方式。\n\n异步处理可以解决以下问题：\n\n * 异步响应\n * 应用解耦\n * 流量削锋\n * 日志处理\n * 消息通讯\n\n\n# 负载均衡\n\n在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。\n\n高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。\n\n> 缓存解决方案请参考：负载均衡\n\n\n# 代码优化\n\n# 多线程\n\n从资源利用的角度看，使用多线程的原因主要有两个：io 阻塞和多 cpu。\n\n线程数并非越多越好，那么启动多少线程合适呢？\n\n有个参考公式：\n\n启动线程数 = (任务执行时间 / (任务执行时间 - io 等待时间)) * cpu 内核数\n\n\n最佳启动线程数和 cpu 内核数成正比，和 io 阻塞时间成反比。\n\n * 如果任务都是 cpu 计算型任务，那么线程数最多不要超过 cpu 内核数，因为启动再多线程，cpu 也来不及调度；\n * 相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并发，提高系统吞吐量。\n\n# 线程安全问题\n\n线程安全问题时指多个线程并发访问某个资源，导致数据混乱。\n\n解决手段有：\n\n * 将对象设计为无状态对象 - 典型应用：servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。\n * 使用局部对象\n * 并发访问资源时使用锁 - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。\n\n# 资源复用\n\n应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。\n\n# 数据结构\n\n根据具体场景，选择合适的数据结构。\n\n# 垃圾回收\n\n如果 web 应用运行在 jvm 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。\n\n\n# 存储性能优化\n\n\n# 数据库\n\n# 数据库读写分离\n\n读写分离的基本原理是将数据库读写操作分散到不同的节点上\n\n> 详细解决方案参考：读写分离\n\n# 数据库分库分表\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。\n\n> 详细解决方案参考：分库分表\n\n# nosql\n\n关系型数据库的优势在于：存储结构化数据，有利于进行各种复杂查询。\n\n但是，它也存在一些缺点：\n\n * 关系数据库存储的是行记录，无法存储数据结构\n * 关系数据库的 schema 扩展很不方便\n * 关系数据库在大数据场景下 i/o 较高\n * 关系数据库的全文搜索功能比较弱\n\n为了解决上述问题，分别诞生了解决不同问题的 nosql 数据库。\n\n常见的 nosql 数据库可以分为四类：\n\n * k-v 数据库：kv 存储非常适合存储不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 sql 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。以 redis 为代表。\n * 列式数据库：适合于批量数据处理和即时查询，解决关系数据库大数据场景下的 i/o 问题。以 hbase 为代表。\n * 文档数据库：文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题。文档数据库通常以 json 或 xml 格式存储数据。以 mongodb 为代表。\n * 全文搜索引擎：解决关系型数据库全文搜索功能较弱的问题。以 elasticsearch 为代表。\n\n> 详情参考：nosql 技术选型\n\n\n# 文件存储\n\n# 机械键盘和固态硬盘\n\n考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。\n\n# b+数和 lsm 树\n\n传统关系数据库的数据库索引一般都使用两级索引的 b+ 树 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 id，然后再进行一次数据文件读操作及一次数据文件写操作）。\n\n由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。\n\n许多 nosql 数据库中的索引采用 lsm 树 作为主要数据结构。lsm 树可视为一个 n 阶合并树。数据写操作都在内存中进行。在 lsm 树上进行一次数据更新不需要磁盘访问，速度远快于 b+ 树。\n\n# raid 和 hdfs\n\nraid 是 redundant array of independent disks 的缩写，中文简称为独立冗余磁盘阵列。\n\nraid 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。\n\nhdfs(分布式文件系统) 更被大型网站所青睐。它可以配合 mapreduce 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 raid 支持。\n\nhdfs 对数据存储空间的管理以数据块（block）为单位，默认为 64 mb。所以，hdfs 更适合存储较大的文件。\n\n\n# 前端性能优化\n\n\n# 浏览器访问优化\n\n 1. 减少 http 请求 - http 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 http 请求数可以有效提高访问性能。减少 http 的主要手段是合并 css、javascript、图片。\n 2. 使用浏览器缓存 - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 http 头中的 cache-control 和 expires 属性，可设定浏览器缓存。\n 3. 启用压缩 - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 html、css、javascrip 进行压缩。\n 4. css 放在页面最上面，javascript 放在页面最下面 - 浏览器会在下载完全部的 css 后才对整个页面进行渲染，所以最好的做法是将 css 放在页面最上面，让浏览器尽快下载 css；javascript 则相反，浏览器加载 javascript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 javascript 最好放在页面最下面。\n 5. 减少 cookie 传输 - cookie 包含在 http 每次的请求和响应中，太大的 cookie 会严重影响数据传输。\n\n\n# cdn\n\ncdn 一般缓存的是静态资源。\n\ncdn 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。\n\n\n\n\n# 反向代理\n\n传统代理服务器位于浏览器一侧，代理浏览器将 http 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 http 请求。\n\n\n\n反向代理服务器可以配置缓存功能加速 web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。\n\n反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。\n\n因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 ip，达到保护网站安全的作用。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * java 性能调优实战",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统高可用架构",frontmatter:{title:"系统高可用架构",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构","高可用"],permalink:"/pages/9a462f/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/04.%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/04.系统高可用架构.md",key:"v-19adc5ec",path:"/pages/9a462f/",headers:[{level:2,title:"高可用架构简介",slug:"高可用架构简介",normalizedTitle:"高可用架构简介",charIndex:14},{level:3,title:"系统可用性的度量",slug:"系统可用性的度量",normalizedTitle:"系统可用性的度量",charIndex:26},{level:3,title:"故障原因",slug:"故障原因",normalizedTitle:"故障原因",charIndex:521},{level:3,title:"什么是高可用的系统架构",slug:"什么是高可用的系统架构",normalizedTitle:"什么是高可用的系统架构",charIndex:1003},{level:2,title:"高可用架构理论",slug:"高可用架构理论",normalizedTitle:"高可用架构理论",charIndex:1488},{level:2,title:"架构模式",slug:"架构模式",normalizedTitle:"架构模式",charIndex:2030},{level:3,title:"主备复制",slug:"主备复制",normalizedTitle:"主备复制",charIndex:2039},{level:3,title:"主从复制",slug:"主从复制",normalizedTitle:"主从复制",charIndex:2490},{level:3,title:"集群+分区",slug:"集群-分区",normalizedTitle:"集群+分区",charIndex:2924},{level:2,title:"高可用的应用",slug:"高可用的应用",normalizedTitle:"高可用的应用",charIndex:1388},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:1403},{level:3,title:"分布式 Session",slug:"分布式-session",normalizedTitle:"分布式 session",charIndex:3285},{level:2,title:"高可用的服务",slug:"高可用的服务",normalizedTitle:"高可用的服务",charIndex:1411},{level:3,title:"分级管理",slug:"分级管理",normalizedTitle:"分级管理",charIndex:1426},{level:3,title:"超时重试",slug:"超时重试",normalizedTitle:"超时重试",charIndex:1431},{level:3,title:"异步调用",slug:"异步调用",normalizedTitle:"异步调用",charIndex:1436},{level:3,title:"过载保护",slug:"过载保护",normalizedTitle:"过载保护",charIndex:4011},{level:4,title:"限流",slug:"限流",normalizedTitle:"限流",charIndex:1441},{level:5,title:"基于请求限流",slug:"基于请求限流",normalizedTitle:"基于请求限流",charIndex:4611},{level:5,title:"基于资源限流",slug:"基于资源限流",normalizedTitle:"基于资源限流",charIndex:4618},{level:4,title:"降级",slug:"降级",normalizedTitle:"降级",charIndex:4029},{level:4,title:"熔断",slug:"熔断",normalizedTitle:"熔断",charIndex:4501},{level:3,title:"幂等性设计",slug:"幂等性设计",normalizedTitle:"幂等性设计",charIndex:1450},{level:2,title:"高可用的存储",slug:"高可用的存储",normalizedTitle:"高可用的存储",charIndex:5822},{level:3,title:"数据备份",slug:"数据备份",normalizedTitle:"数据备份",charIndex:1474},{level:3,title:"失效转移",slug:"失效转移",normalizedTitle:"失效转移",charIndex:1244},{level:4,title:"失效确认",slug:"失效确认",normalizedTitle:"失效确认",charIndex:6334},{level:4,title:"访问转移",slug:"访问转移",normalizedTitle:"访问转移",charIndex:6467},{level:4,title:"数据恢复",slug:"数据恢复",normalizedTitle:"数据恢复",charIndex:6580},{level:2,title:"辅助手段",slug:"辅助手段",normalizedTitle:"辅助手段",charIndex:6700},{level:3,title:"异地多活",slug:"异地多活",normalizedTitle:"异地多活",charIndex:6709},{level:3,title:"发布流程",slug:"发布流程",normalizedTitle:"发布流程",charIndex:7248},{level:3,title:"系统监控",slug:"系统监控",normalizedTitle:"系统监控",charIndex:7317},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7981}],headersStr:"高可用架构简介 系统可用性的度量 故障原因 什么是高可用的系统架构 高可用架构理论 架构模式 主备复制 主从复制 集群+分区 高可用的应用 负载均衡 分布式 Session 高可用的服务 分级管理 超时重试 异步调用 过载保护 限流 基于请求限流 基于资源限流 降级 熔断 幂等性设计 高可用的存储 数据备份 失效转移 失效确认 访问转移 数据恢复 辅助手段 异地多活 发布流程 系统监控 参考资料",content:"# 系统高可用架构\n\n\n# 高可用架构简介\n\n\n# 系统可用性的度量\n\n系统不可用也被称作系统故障，业界通常用多个 9 来衡量系统的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。\n\n网站不可用时间 = 故障修复时间点 - 故障发现时间点\n网站年度可用性指标 = (1 - 网站不可用时间/年度总时间) * 100%\n\n\n可用性计量表：\n\n可用性级别   系统可用性%    宕机时间/年     宕机时间/月    宕机时间/周    宕机时间/天\n不可用     90%       36.5 天     73 小时     16.8 小时   144 分钟\n基本可用    99%       87.6 小时    7.3 小时    1.68 小时   14.4 分钟\n较高可用    99.9%     8.76 小时    43.8 分钟   10.1 分钟   1.44 分钟\n高可用     99.99%    52.56 分钟   4.38 分钟   1.01 秒    8.64 秒\n极高可用    99.999%   5.26 分钟    26.28 秒   6.06 秒    0.86 秒\n\n\n# 故障原因\n\n系统宕机原因主要有以下：\n\n无计划的\n\n * 系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。\n * 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。\n * 还有自然灾害、人为破坏，以及供电问题等。\n\n有计划的\n\n * 日常任务：备份，容量规划，用户和安全管理，后台批处理应用。\n * 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。\n * 升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。\n\n我们再给它们归个类。\n\n 1. 网络问题。网络链接出现问题，网络带宽出现拥塞……\n 2. 性能问题。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足……\n 3. 安全问题。被网络攻击，如 DDoS 等。\n 4. 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题……\n 5. 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……\n 6. 硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……\n\n\n# 什么是高可用的系统架构\n\n通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。\n\n互联网公司或一些初创型公司基于成本考虑，更多采用 PC 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。\n\n综上，硬件出现故障应视为必然的，而高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问。实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。\n\n大型系统的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。大致可以分为：\n\n * 高可用的应用 - 主要手段是：负载均衡\n * 高可用的服务 - 主要手段是：分级管理、超时重试、异步调用、限流、降解、断路、幂等性设计\n * 高可用的数据 - 主要手段是：数据备份和失效转移\n\n\n# 高可用架构理论\n\n学习高可用架构，首先需要了解分布式基础理论：CAP 和 BASE。\n\n然后，很多著名的分布式系统，都利用选举机制，来保证主节点宕机时的故障恢复。如果要深入理解选举机制，有必要了解：Paxos 算法 和 Raft 算法。Paxos 和 Raft 是为了实现分布式系统中高可用架构而提出的共识性算法，已经成为业界标准。\n\nCAP 定理又称为 CAP 原则，指的是：在一个分布式系统中， 一致性（C：Consistency）、可用性（A：Availability） 和 分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。\n\nBASE 是 基本可用（Basically Available）、软状态（Soft State） 和 最终一致性（Eventually Consistent） 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> CAP 和 BASE 理论的详细说明请参考：分布式一致性\n> \n> Paxos 和 Raft 的详细说明请参考：Paxos 算法 和 Raft 算法\n\n\n# 架构模式\n\n\n# 主备复制\n\n主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。\n\n主备复制要点：\n\n * 存在一主多备。\n * 主机负责读&写，并定期复制数据给备机。\n * 一旦主机宕机，可以通过人工手段，将其中一个备节点作为主节点。\n\n\n\n优点\n\n * 主备复制架构中，客户端可以不感知备机的存在。即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。\n * 主备复制架构中，主机和备机之间，只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。\n\n缺点\n\n * 主备复制架构中，故障后需要人工干预，无法自动恢复。\n\n适用场景\n\n综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。\n\n\n# 主从复制\n\n主从复制和主备复制只有一字之差，区别在于：主从复制模式中，从机要承担读操作。\n\n主从复制要点：\n\n * 存在一主多从。\n * 主机负责读&写，并定期复制数据给从机。\n * 从机只负责读。\n * 一旦主机宕机，可以通过人工手段，将其中一个从节点作为主节点。\n\n\n\n优点\n\n * 主从复制架构中，主机故障时，读操作相关的业务可以继续运行。\n * 主从复制架构中，从机提供读操作，发挥了硬件的性能。\n\n缺点\n\n * 主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。\n * 主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。\n * 主从复制架构中，故障时需要人工干预。\n\n适用场景\n\n综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。\n\n\n# 集群+分区\n\n在主备复制和主从复制模式中，都由一个共性问题：\n\n每个机器上存储的都是全量数据。但是，单机的数据存储量总是有上限的，当数据量上升为 TB 级甚至 PB 级数据，单机终究有无法支撑的时候。这时，就需要对数据进行分片（sharding）。\n\n分片后的节点可以视为一个独立的子集，针对子集，任然需要保证高可用。\n\n\n\n\n# 高可用的应用\n\n应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 无状态 性。\n\n所谓的 无状态 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。\n\n由于无状态应用，各实例之间不用考虑数据一致性问题，所以其高可用方案相对简单。主要手段是：\n\n * 负载均衡\n * 分布式 Session\n\n\n# 负载均衡\n\n负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。\n\n无状态应用的失效转移可以利用负载均衡来实现。\n\n无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。\n\n> 负载均衡原理可以参考：负载均衡基本原理\n\n\n# 分布式 Session\n\n应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。\n\n在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。\n\n为了解决分布式 Session 问题，常见的解决方案有：\n\n * 粘性 session\n * 应用服务器间的 session 复制共享\n * 基于缓存的 session 共享 ✅\n\n> 分布式会话原理可以参考：分布式会话基本原理\n\n\n# 高可用的服务\n\n可复用的服务为业务产品提供基础公共服务，大型系统中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，一般也是无状态的服务，因此，同样可以使用负载均衡的失效转移策略来实现高可用。\n\n除此以外，还有以下手段来保证服务的高可用：\n\n * 分级管理\n * 超时重试\n * 异步调用\n * 过载保护\n   * 限流\n   * 降级\n   * 断路\n * 幂等性设计\n\n\n# 分级管理\n\n将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。\n\n在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。\n\n\n# 超时重试\n\n由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。\n\n\n# 异步调用\n\n对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。\n\n\n# 过载保护\n\n过载保护的手段，一般有：限流、降级、熔断。\n\n# 限流\n\n降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。\n\n常见的限流方式可以分为两类：基于请求限流和基于资源限流。\n\n# 基于请求限流\n\n基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。\n\n限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。\n\n无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。\n\n# 基于资源限流\n\n基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。\n\n基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。\n\n# 降级\n\n降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。\n\n在服务访问的高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：\n\n拒绝服务 - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。\n\n关闭服务 - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。\n\n# 熔断\n\n熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。\n\n熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。\n\n\n# 幂等性设计\n\n服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如：向数据库写入两条记录。如果这个操作是比较敏感的交易操作，就会产生严重后果。\n\n服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。\n\n有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的 ID 去进行有效性验证，验证通过才能继续执行。\n\n\n# 高可用的存储\n\n对于绝大部分软件系统而言，数据都是最宝贵的虚拟资产，一旦丢失，可以说是毁灭性的打击。\n\n保证存储高可用的主要手段是：数据备份和失效转移。\n\n存储高可用架构的复杂性主要体现在：如何应对副本同步延迟和中断导致的数据一致性问题。\n\n> 提示：再开始学习这部分内容前，建议先学习 二、高可用架构理论\n\n\n# 数据备份\n\n数据备份是保证数据有多个副本，任意副本的丢失都不会导致数据的永久丢失。\n\n * 冷备份 - 定期将数据复制到某种存储介质。\n * 热备份\n   * 异步热备方式 - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。\n   * 同步热备方式 - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。\n\n\n# 失效转移\n\n失效转移是保证任意一个副本不可访问时，可以快速切换访问其他副本，保证系统整体可用。\n\n# 失效确认\n\n\n\n判断服务器宕机的手段有两种：心跳检测和访问失败报告。\n\n对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。\n\n# 访问转移\n\n确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。\n\n# 数据恢复\n\n因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。\n\n\n# 辅助手段\n\n\n# 异地多活\n\n异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。\n\n异地多活架构可以分为同城异区、跨城异地、跨国异地。\n\n异地多活架构的代价：\n\n * 系统复杂度会发生质的变化，需要设计复杂的异地多活架构。\n * 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。\n\n异地多活的设计原则：\n\n * 保证核心业务的异地多活\n * 保证核心数据最终一致性\n * 采用多种手段同步数据\n * 只保证绝大部分用户的异地多活\n\n异地多活设计步骤：\n\n * 业务分级 - 常见的分级标准有：\n   * 流量大的业务\n   * 核心业务\n   * 盈利业务\n * 数据分类 - 常见的数据分析维度有：\n   * 数据量\n   * 唯一性\n   * 实时性\n   * 可丢实性\n   * 可恢复性\n * 数据同步 - 常见的数据同步方案\n   * 存储系统同步\n   * 消息队列同步\n   * 重复生成\n * 异常处理 - 常见异常处理措施：\n   * 多通道同步\n   * 同步和访问结合\n   * 日志记录\n   * 用户补偿\n\n\n# 发布流程\n\n高可用的软件质量保证的手段：\n\n * 自动化测试\n * 预发布验证\n * 代码控制\n * 自动化发布\n * 灰度发布\n\n\n# 系统监控\n\n> 不允许没有监控的系统上线。\n\n * 监控数据采集\n   * 用户行为日志收集\n     * 服务端日志收集 - Apache、Nginx 等几乎所有 Web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 Elastic 来进行收集。\n     * 客户端日志收集 - 利用页面嵌入专门的 JavaScript 脚本可以收集用户真实的操作行为。\n     * 日志分析 - 可以利用 ElasticSearch 做语义分析及搜索；利用实时计算框架 Storm、Flink 等开发日志统计与分析工具。\n   * 服务器性能监控 - 收集服务器性能指标，如系统负载、内存占用、CPU 占用、磁盘 IO、网络 IO 等。常用的监控工具有：Apache SkyWalking 、Pinpoint 等。\n   * 运行数据报告 - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、TPS、QPS 等。\n * 监控管理\n   * 系统报警 - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。\n   * 失效转移 - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。\n   * 自动优雅降级\n     * 优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。\n     * 系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n * 左耳听风",normalizedContent:"# 系统高可用架构\n\n\n# 高可用架构简介\n\n\n# 系统可用性的度量\n\n系统不可用也被称作系统故障，业界通常用多个 9 来衡量系统的可用性。如 qq 的可用性为 4 个 9，即 99.99% 可用。\n\n网站不可用时间 = 故障修复时间点 - 故障发现时间点\n网站年度可用性指标 = (1 - 网站不可用时间/年度总时间) * 100%\n\n\n可用性计量表：\n\n可用性级别   系统可用性%    宕机时间/年     宕机时间/月    宕机时间/周    宕机时间/天\n不可用     90%       36.5 天     73 小时     16.8 小时   144 分钟\n基本可用    99%       87.6 小时    7.3 小时    1.68 小时   14.4 分钟\n较高可用    99.9%     8.76 小时    43.8 分钟   10.1 分钟   1.44 分钟\n高可用     99.99%    52.56 分钟   4.38 分钟   1.01 秒    8.64 秒\n极高可用    99.999%   5.26 分钟    26.28 秒   6.06 秒    0.86 秒\n\n\n# 故障原因\n\n系统宕机原因主要有以下：\n\n无计划的\n\n * 系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。\n * 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。\n * 还有自然灾害、人为破坏，以及供电问题等。\n\n有计划的\n\n * 日常任务：备份，容量规划，用户和安全管理，后台批处理应用。\n * 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。\n * 升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。\n\n我们再给它们归个类。\n\n 1. 网络问题。网络链接出现问题，网络带宽出现拥塞……\n 2. 性能问题。数据库慢 sql、java full gc、硬盘 io 过大、cpu 飙高、内存不足……\n 3. 安全问题。被网络攻击，如 ddos 等。\n 4. 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题……\n 5. 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……\n 6. 硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……\n\n\n# 什么是高可用的系统架构\n\n通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。\n\n互联网公司或一些初创型公司基于成本考虑，更多采用 pc 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。\n\n综上，硬件出现故障应视为必然的，而高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问。实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。\n\n大型系统的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。大致可以分为：\n\n * 高可用的应用 - 主要手段是：负载均衡\n * 高可用的服务 - 主要手段是：分级管理、超时重试、异步调用、限流、降解、断路、幂等性设计\n * 高可用的数据 - 主要手段是：数据备份和失效转移\n\n\n# 高可用架构理论\n\n学习高可用架构，首先需要了解分布式基础理论：cap 和 base。\n\n然后，很多著名的分布式系统，都利用选举机制，来保证主节点宕机时的故障恢复。如果要深入理解选举机制，有必要了解：paxos 算法 和 raft 算法。paxos 和 raft 是为了实现分布式系统中高可用架构而提出的共识性算法，已经成为业界标准。\n\ncap 定理又称为 cap 原则，指的是：在一个分布式系统中， 一致性（c：consistency）、可用性（a：availability） 和 分区容忍性（p：partition tolerance），最多只能同时满足其中两项。\n\nbase 是 基本可用（basically available）、软状态（soft state） 和 最终一致性（eventually consistent） 三个短语的缩写。base 理论是对 cap 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> cap 和 base 理论的详细说明请参考：分布式一致性\n> \n> paxos 和 raft 的详细说明请参考：paxos 算法 和 raft 算法\n\n\n# 架构模式\n\n\n# 主备复制\n\n主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 mysql、redis、mongodb 等。\n\n主备复制要点：\n\n * 存在一主多备。\n * 主机负责读&写，并定期复制数据给备机。\n * 一旦主机宕机，可以通过人工手段，将其中一个备节点作为主节点。\n\n\n\n优点\n\n * 主备复制架构中，客户端可以不感知备机的存在。即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。\n * 主备复制架构中，主机和备机之间，只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。\n\n缺点\n\n * 主备复制架构中，故障后需要人工干预，无法自动恢复。\n\n适用场景\n\n综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。\n\n\n# 主从复制\n\n主从复制和主备复制只有一字之差，区别在于：主从复制模式中，从机要承担读操作。\n\n主从复制要点：\n\n * 存在一主多从。\n * 主机负责读&写，并定期复制数据给从机。\n * 从机只负责读。\n * 一旦主机宕机，可以通过人工手段，将其中一个从节点作为主节点。\n\n\n\n优点\n\n * 主从复制架构中，主机故障时，读操作相关的业务可以继续运行。\n * 主从复制架构中，从机提供读操作，发挥了硬件的性能。\n\n缺点\n\n * 主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。\n * 主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。\n * 主从复制架构中，故障时需要人工干预。\n\n适用场景\n\n综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、bbs、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。\n\n\n# 集群+分区\n\n在主备复制和主从复制模式中，都由一个共性问题：\n\n每个机器上存储的都是全量数据。但是，单机的数据存储量总是有上限的，当数据量上升为 tb 级甚至 pb 级数据，单机终究有无法支撑的时候。这时，就需要对数据进行分片（sharding）。\n\n分片后的节点可以视为一个独立的子集，针对子集，任然需要保证高可用。\n\n\n\n\n# 高可用的应用\n\n应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 无状态 性。\n\n所谓的 无状态 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。\n\n由于无状态应用，各实例之间不用考虑数据一致性问题，所以其高可用方案相对简单。主要手段是：\n\n * 负载均衡\n * 分布式 session\n\n\n# 负载均衡\n\n负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。\n\n无状态应用的失效转移可以利用负载均衡来实现。\n\n无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。\n\n> 负载均衡原理可以参考：负载均衡基本原理\n\n\n# 分布式 session\n\n应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。\n\n在分布式场景下，一个用户的 session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 session，就可能导致用户需要重新进行登录等操作。\n\n为了解决分布式 session 问题，常见的解决方案有：\n\n * 粘性 session\n * 应用服务器间的 session 复制共享\n * 基于缓存的 session 共享 ✅\n\n> 分布式会话原理可以参考：分布式会话基本原理\n\n\n# 高可用的服务\n\n可复用的服务为业务产品提供基础公共服务，大型系统中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，一般也是无状态的服务，因此，同样可以使用负载均衡的失效转移策略来实现高可用。\n\n除此以外，还有以下手段来保证服务的高可用：\n\n * 分级管理\n * 超时重试\n * 异步调用\n * 过载保护\n   * 限流\n   * 降级\n   * 断路\n * 幂等性设计\n\n\n# 分级管理\n\n将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。\n\n在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。\n\n\n# 超时重试\n\n由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。\n\n\n# 异步调用\n\n对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。\n\n\n# 过载保护\n\n过载保护的手段，一般有：限流、降级、熔断。\n\n# 限流\n\n降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。\n\n常见的限流方式可以分为两类：基于请求限流和基于资源限流。\n\n# 基于请求限流\n\n基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。\n\n限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。\n\n无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。\n\n# 基于资源限流\n\n基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。\n\n基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。\n\n# 降级\n\n降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。\n\n在服务访问的高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：\n\n拒绝服务 - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。\n\n关闭服务 - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。\n\n# 熔断\n\n熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。\n\n熔断机制实现的关键是需要有一个统一的 api 调用层，由 api 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。\n\n\n# 幂等性设计\n\n服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如：向数据库写入两条记录。如果这个操作是比较敏感的交易操作，就会产生严重后果。\n\n服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。\n\n有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的 id 去进行有效性验证，验证通过才能继续执行。\n\n\n# 高可用的存储\n\n对于绝大部分软件系统而言，数据都是最宝贵的虚拟资产，一旦丢失，可以说是毁灭性的打击。\n\n保证存储高可用的主要手段是：数据备份和失效转移。\n\n存储高可用架构的复杂性主要体现在：如何应对副本同步延迟和中断导致的数据一致性问题。\n\n> 提示：再开始学习这部分内容前，建议先学习 二、高可用架构理论\n\n\n# 数据备份\n\n数据备份是保证数据有多个副本，任意副本的丢失都不会导致数据的永久丢失。\n\n * 冷备份 - 定期将数据复制到某种存储介质。\n * 热备份\n   * 异步热备方式 - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。\n   * 同步热备方式 - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。\n\n\n# 失效转移\n\n失效转移是保证任意一个副本不可访问时，可以快速切换访问其他副本，保证系统整体可用。\n\n# 失效确认\n\n\n\n判断服务器宕机的手段有两种：心跳检测和访问失败报告。\n\n对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。\n\n# 访问转移\n\n确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。\n\n# 数据恢复\n\n因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。\n\n\n# 辅助手段\n\n\n# 异地多活\n\n异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。\n\n异地多活架构可以分为同城异区、跨城异地、跨国异地。\n\n异地多活架构的代价：\n\n * 系统复杂度会发生质的变化，需要设计复杂的异地多活架构。\n * 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。\n\n异地多活的设计原则：\n\n * 保证核心业务的异地多活\n * 保证核心数据最终一致性\n * 采用多种手段同步数据\n * 只保证绝大部分用户的异地多活\n\n异地多活设计步骤：\n\n * 业务分级 - 常见的分级标准有：\n   * 流量大的业务\n   * 核心业务\n   * 盈利业务\n * 数据分类 - 常见的数据分析维度有：\n   * 数据量\n   * 唯一性\n   * 实时性\n   * 可丢实性\n   * 可恢复性\n * 数据同步 - 常见的数据同步方案\n   * 存储系统同步\n   * 消息队列同步\n   * 重复生成\n * 异常处理 - 常见异常处理措施：\n   * 多通道同步\n   * 同步和访问结合\n   * 日志记录\n   * 用户补偿\n\n\n# 发布流程\n\n高可用的软件质量保证的手段：\n\n * 自动化测试\n * 预发布验证\n * 代码控制\n * 自动化发布\n * 灰度发布\n\n\n# 系统监控\n\n> 不允许没有监控的系统上线。\n\n * 监控数据采集\n   * 用户行为日志收集\n     * 服务端日志收集 - apache、nginx 等几乎所有 web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 elastic 来进行收集。\n     * 客户端日志收集 - 利用页面嵌入专门的 javascript 脚本可以收集用户真实的操作行为。\n     * 日志分析 - 可以利用 elasticsearch 做语义分析及搜索；利用实时计算框架 storm、flink 等开发日志统计与分析工具。\n   * 服务器性能监控 - 收集服务器性能指标，如系统负载、内存占用、cpu 占用、磁盘 io、网络 io 等。常用的监控工具有：apache skywalking 、pinpoint 等。\n   * 运行数据报告 - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、tps、qps 等。\n * 监控管理\n   * 系统报警 - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。\n   * 失效转移 - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。\n   * 自动优雅降级\n     * 优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。\n     * 系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n * 左耳听风",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统伸缩性架构",frontmatter:{title:"系统伸缩性架构",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构","伸缩性"],permalink:"/pages/1e5251/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/05.%E7%B3%BB%E7%BB%9F%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/05.系统伸缩性架构.md",key:"v-19e0ab98",path:"/pages/1e5251/",headers:[{level:2,title:"系统架构的伸缩性设计",slug:"系统架构的伸缩性设计",normalizedTitle:"系统架构的伸缩性设计",charIndex:69},{level:3,title:"不同功能进行物理分离实现伸缩",slug:"不同功能进行物理分离实现伸缩",normalizedTitle:"不同功能进行物理分离实现伸缩",charIndex:84},{level:3,title:"单一功能通过集群规模实现伸缩",slug:"单一功能通过集群规模实现伸缩",normalizedTitle:"单一功能通过集群规模实现伸缩",charIndex:189},{level:2,title:"应用服务器集群的伸缩性设计",slug:"应用服务器集群的伸缩性设计",normalizedTitle:"应用服务器集群的伸缩性设计",charIndex:320},{level:3,title:"HTTP 重定向负载均衡",slug:"http-重定向负载均衡",normalizedTitle:"http 重定向负载均衡",charIndex:441},{level:3,title:"DNS 域名解析负载均衡",slug:"dns-域名解析负载均衡",normalizedTitle:"dns 域名解析负载均衡",charIndex:610},{level:3,title:"反向代理负载均衡",slug:"反向代理负载均衡",normalizedTitle:"反向代理负载均衡",charIndex:1138},{level:3,title:"IP 负载均衡",slug:"ip-负载均衡",normalizedTitle:"ip 负载均衡",charIndex:1234},{level:3,title:"数据链路层负载均衡",slug:"数据链路层负载均衡",normalizedTitle:"数据链路层负载均衡",charIndex:1535},{level:3,title:"负载均衡算法",slug:"负载均衡算法",normalizedTitle:"负载均衡算法",charIndex:782},{level:2,title:"分布式缓存集群的伸缩性设计",slug:"分布式缓存集群的伸缩性设计",normalizedTitle:"分布式缓存集群的伸缩性设计",charIndex:2466},{level:2,title:"数据存储服务集群的伸缩性设计",slug:"数据存储服务集群的伸缩性设计",normalizedTitle:"数据存储服务集群的伸缩性设计",charIndex:2517},{level:3,title:"关系型数据库的伸缩性设计",slug:"关系型数据库的伸缩性设计",normalizedTitle:"关系型数据库的伸缩性设计",charIndex:2536},{level:3,title:"NoSql 数据库的伸缩性设计",slug:"nosql-数据库的伸缩性设计",normalizedTitle:"nosql 数据库的伸缩性设计",charIndex:2657},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2723}],headersStr:"系统架构的伸缩性设计 不同功能进行物理分离实现伸缩 单一功能通过集群规模实现伸缩 应用服务器集群的伸缩性设计 HTTP 重定向负载均衡 DNS 域名解析负载均衡 反向代理负载均衡 IP 负载均衡 数据链路层负载均衡 负载均衡算法 分布式缓存集群的伸缩性设计 数据存储服务集群的伸缩性设计 关系型数据库的伸缩性设计 NoSql 数据库的伸缩性设计 参考资料",content:"# 系统伸缩性架构\n\n> 伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。\n\n\n# 系统架构的伸缩性设计\n\n\n# 不同功能进行物理分离实现伸缩\n\n * 纵向分离（分层后分离） - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。\n * 横向分离（业务分割后分离） - 将不同的业务模块分离部署，实现系统伸缩性。\n\n\n# 单一功能通过集群规模实现伸缩\n\n将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。\n\n\n# 应用服务器集群的伸缩性设计\n\n如果 HTTP 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。\n\n\n# HTTP 重定向负载均衡\n\n\n\n利用 HTTP 重定向协议实现负载均衡。\n\n这种负载均衡方案的优点是比较简单。\n\n缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。\n\n\n# DNS 域名解析负载均衡\n\n利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。\n\n\n\n在 DNS 服务器中配置多个 A 记录，如：\n\n114.100.40.1 www.mysite.com\n114.100.40.2 www.mysite.com\n114.100.40.3 www.mysite.com\n\n\n每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\nDNS 域名解析负载均衡的优点：\n\n * 将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。\n * 同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。\n\nDNS 域名解析负载均衡的缺点：\n\n * DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。\n * DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。\n\n\n# 反向代理负载均衡\n\n大多数反向代理服务器同时提供反向代理和负载均衡的功能。\n\n\n\n反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n\n\n# IP 负载均衡\n\n在网络层通过修改请求目标地址进行负载均衡。\n\n\n\n负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。\n\nIP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。\n\n\n# 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。\n\n在 Linux 平台上最好的链路层负载均衡开源产品是 LVS(Linux Virtual Server)。\n\n\n# 负载均衡算法\n\n负载均衡服务器的实现可以分为两个部分：\n\n 1. 根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。\n 2. 将请求数据发送到该地址对应的 Web 服务器上。\n\n负载均衡算法通常有以下几种：\n\n * 轮询（Round Robin） - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。\n * 加权轮询（Weighted Round Robin） - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。\n * 随机（Random） - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。\n * 最少连接（Least Connection） - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。\n * 源地址 Hash（Source Hash） - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。\n\n\n# 分布式缓存集群的伸缩性设计\n\n目前比较流行的分布式集群伸缩性方案就是：一致性 HASH 算法\n\n\n# 数据存储服务集群的伸缩性设计\n\n\n# 关系型数据库的伸缩性设计\n\n * 主从复制 - 主流关系型数据库一般都支持主从复制。\n * 分库 - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。\n * 分表 - 使用数据库分片中间件，如 Cobar 等。\n\n\n# NoSql 数据库的伸缩性设计\n\n一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",normalizedContent:"# 系统伸缩性架构\n\n> 伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。\n\n\n# 系统架构的伸缩性设计\n\n\n# 不同功能进行物理分离实现伸缩\n\n * 纵向分离（分层后分离） - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。\n * 横向分离（业务分割后分离） - 将不同的业务模块分离部署，实现系统伸缩性。\n\n\n# 单一功能通过集群规模实现伸缩\n\n将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。\n\n\n# 应用服务器集群的伸缩性设计\n\n如果 http 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。\n\n\n# http 重定向负载均衡\n\n\n\n利用 http 重定向协议实现负载均衡。\n\n这种负载均衡方案的优点是比较简单。\n\n缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 http 302 响应码重定向，可能使搜索引擎判断为 seo 作弊，降低搜索排名。\n\n\n# dns 域名解析负载均衡\n\n利用 dns 处理域名解析请求的同时进行负载均衡处理的一种方案。\n\n\n\n在 dns 服务器中配置多个 a 记录，如：\n\n114.100.40.1 www.mysite.com\n114.100.40.2 www.mysite.com\n114.100.40.3 www.mysite.com\n\n\n每次域名解析请求都会根据负载均衡算法计算一个不同的 ip 地址返回，这样 a 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\ndns 域名解析负载均衡的优点：\n\n * 将负载均衡的工作转交给了 dns，省掉了网站管理维护的麻烦。\n * 同时，许多 dns 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。\n\ndns 域名解析负载均衡的缺点：\n\n * dns 是多级解析，每一级 dns 都可能缓存 a 记录，当某台服务器下线后，即使修改了 dns 的 a 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。\n * dns 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。\n\n\n# 反向代理负载均衡\n\n大多数反向代理服务器同时提供反向代理和负载均衡的功能。\n\n\n\n反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n\n\n# ip 负载均衡\n\n在网络层通过修改请求目标地址进行负载均衡。\n\n\n\n负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 web 服务器 10.0.0.1，然后将目的 ip 地址修改为 10.0.0.1，不需要通过用户进程。真实 web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 ip 地址（114.100.80.10）发送给浏览器。\n\nip 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。\n\n\n# 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 ip 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 ip 和负载均衡服务器 ip 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 ip 和数据请求目的 ip 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。\n\n在 linux 平台上最好的链路层负载均衡开源产品是 lvs(linux virtual server)。\n\n\n# 负载均衡算法\n\n负载均衡服务器的实现可以分为两个部分：\n\n 1. 根据负载均衡算法和 web 服务器列表计算得到集群中一台 web 服务器的地址。\n 2. 将请求数据发送到该地址对应的 web 服务器上。\n\n负载均衡算法通常有以下几种：\n\n * 轮询（round robin） - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。\n * 加权轮询（weighted round robin） - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。\n * 随机（random） - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。\n * 最少连接（least connection） - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。\n * 源地址 hash（source hash） - 根据请求来源的 ip 地址进行 hash 计算，得到应用服务器，这样来自同一个 ip 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。\n\n\n# 分布式缓存集群的伸缩性设计\n\n目前比较流行的分布式集群伸缩性方案就是：一致性 hash 算法\n\n\n# 数据存储服务集群的伸缩性设计\n\n\n# 关系型数据库的伸缩性设计\n\n * 主从复制 - 主流关系型数据库一般都支持主从复制。\n * 分库 - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 join 操作。\n * 分表 - 使用数据库分片中间件，如 cobar 等。\n\n\n# nosql 数据库的伸缩性设计\n\n一般而言，nosql 不支持 sql 和 acid，但是强化了对于高可用和伸缩性的支持。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统扩展性架构",frontmatter:{title:"系统扩展性架构",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构","扩展性"],permalink:"/pages/943670/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/06.%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/06.系统扩展性架构.md",key:"v-7771b23d",path:"/pages/943670/",headers:[{level:2,title:"可扩展的基本思想",slug:"可扩展的基本思想",normalizedTitle:"可扩展的基本思想",charIndex:328},{level:2,title:"可扩展方式",slug:"可扩展方式",normalizedTitle:"可扩展方式",charIndex:442},{level:3,title:"分层架构",slug:"分层架构",normalizedTitle:"分层架构",charIndex:473},{level:3,title:"SOA",slug:"soa",normalizedTitle:"soa",charIndex:489},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:493},{level:3,title:"微内核",slug:"微内核",normalizedTitle:"微内核",charIndex:508},{level:2,title:"易扩展的系统架构",slug:"易扩展的系统架构",normalizedTitle:"易扩展的系统架构",charIndex:2347},{level:2,title:"利用分布式消息队列降低系统耦合性",slug:"利用分布式消息队列降低系统耦合性",normalizedTitle:"利用分布式消息队列降低系统耦合性",charIndex:2583},{level:3,title:"事件驱动架构",slug:"事件驱动架构",normalizedTitle:"事件驱动架构",charIndex:2604},{level:3,title:"分布式消息队列",slug:"分布式消息队列",normalizedTitle:"分布式消息队列",charIndex:2585},{level:2,title:"利用分布式服务打造可复用的业务平台",slug:"利用分布式服务打造可复用的业务平台",normalizedTitle:"利用分布式服务打造可复用的业务平台",charIndex:3079},{level:2,title:"可扩展的数据结构",slug:"可扩展的数据结构",normalizedTitle:"可扩展的数据结构",charIndex:3410},{level:2,title:"开放平台",slug:"开放平台",normalizedTitle:"开放平台",charIndex:3589},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3766}],headersStr:"可扩展的基本思想 可扩展方式 分层架构 SOA 微服务 微内核 易扩展的系统架构 利用分布式消息队列降低系统耦合性 事件驱动架构 分布式消息队列 利用分布式服务打造可复用的业务平台 可扩展的数据结构 开放平台 参考资料",content:"# 系统扩展性架构\n\n> 扩展性和伸缩性是不同的概念：\n> \n>  * 扩展性（Extensibility） - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。\n>  * 伸缩性（Scalability） - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。\n\n\n# 可扩展的基本思想\n\n * 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。\n * 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。\n * 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。\n\n\n# 可扩展方式\n\n典型的可扩展系统架构有：\n\n * 面向流程拆分：分层架构。\n * 面向服务拆分：SOA、微服务。\n * 面向功能拆分：微内核架构。\n\n\n# 分层架构\n\n分层架构的核心点时：需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构\n\n分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。\n\n典型分层架构：\n\n * C/S 架构、B/S 架构\n * MVC 架构、MVP 架构\n * 逻辑分层架构\n\n\n# SOA\n\nSOA 的全称是 Service Oriented Architecture，即“面向服务的架构”。\n\nSOA 提出了 3 个关键概念。\n\n * 服务 - 所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。\n * ESB - ESB 的全称是 Enterprise Service Bus，即 “企业服务总线”。ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。\n * 松耦合 - 松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。\n\n\n# 微服务\n\n微服务是去掉 ESB 后的 SOA。\n\n微服务的问题：\n\n * 服务划分过细，服务间关系复杂 - 服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。\n * 服务数量太多，团队效率急剧下降\n * 调用链太长，性能下降\n * 调用链太长，问题定位困难\n * 没有自动化支撑，无法快速交付\n * 没有服务治理，微服务数量多了后管理混乱\n\n微服务拆分：\n\n * 基于业务逻辑拆分\n * 基于可扩展拆分 - 将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。\n * 基于可靠性拆分 - 将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。\n\n基础设施：\n\n * 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。\n * 接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。\n * 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。\n * 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。\n\n\n# 微内核\n\n\n\n微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。\n\n插件管理\n\n核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。\n\n插件连接\n\n插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n\n常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（Spring 使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式。\n\n插件通信\n\n插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。\n\n\n# 易扩展的系统架构\n\n> 低耦合的系统更容易扩展、复用。\n\n可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。\n\n分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。\n\n在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。\n\n\n# 利用分布式消息队列降低系统耦合性\n\n\n# 事件驱动架构\n\n事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。\n\n\n# 分布式消息队列\n\n消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（FIFO）的原则将消息通过远程通信接口发送给消息消费者程序。\n\n\n\n在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。\n\n在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。\n\n\n# 利用分布式服务打造可复用的业务平台\n\n巨无霸系统的问题：\n\n * 构建、部署困难\n * 代码分支管理困难\n * 数据库连接耗尽\n * 扩展业务困难\n\n而解决巨无霸系统问题的方案就是拆分：\n\n * 通过纵向拆分将业务拆分多个应用或模块；\n * 通过横向拆分将可复用业务作为独立应用。\n\n然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：Spring Cloud、Dubbo 等。\n\n大型网站分布式服务的需求与特点：\n\n * 负载均衡\n * 失效转移\n * 高效的远程通信\n * 整合异构系统\n * 对应用最少侵入\n * 版本管理\n * 实时监控\n\n\n# 可扩展的数据结构\n\n传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。\n\n许多 NoSql 数据库使用 ColumnFamily 设计来设计可扩展的数据结构。\n\n\n# 开放平台\n\n很多大公司会利用开放平台提供大量开放性 API 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。\n\n开放平台不是一朝一夕完成的，这需要大量 OPEN API 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 OPEN API 时，可以便捷的暴露服务接口。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",normalizedContent:"# 系统扩展性架构\n\n> 扩展性和伸缩性是不同的概念：\n> \n>  * 扩展性（extensibility） - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。\n>  * 伸缩性（scalability） - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。\n\n\n# 可扩展的基本思想\n\n * 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。\n * 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。\n * 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。\n\n\n# 可扩展方式\n\n典型的可扩展系统架构有：\n\n * 面向流程拆分：分层架构。\n * 面向服务拆分：soa、微服务。\n * 面向功能拆分：微内核架构。\n\n\n# 分层架构\n\n分层架构的核心点时：需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构\n\n分层架构是很常见的架构模式，它也叫 n 层架构，通常情况下，n 至少是 2 层。例如，c/s 架构、b/s 架构。常见的是 3 层架构（例如，mvc、mvp 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。\n\n典型分层架构：\n\n * c/s 架构、b/s 架构\n * mvc 架构、mvp 架构\n * 逻辑分层架构\n\n\n# soa\n\nsoa 的全称是 service oriented architecture，即“面向服务的架构”。\n\nsoa 提出了 3 个关键概念。\n\n * 服务 - 所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。\n * esb - esb 的全称是 enterprise service bus，即 “企业服务总线”。esb 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。soa 使用 esb 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。\n * 松耦合 - 松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 soa 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。\n\n\n# 微服务\n\n微服务是去掉 esb 后的 soa。\n\n微服务的问题：\n\n * 服务划分过细，服务间关系复杂 - 服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。\n * 服务数量太多，团队效率急剧下降\n * 调用链太长，性能下降\n * 调用链太长，问题定位困难\n * 没有自动化支撑，无法快速交付\n * 没有服务治理，微服务数量多了后管理混乱\n\n微服务拆分：\n\n * 基于业务逻辑拆分\n * 基于可扩展拆分 - 将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。\n * 基于可靠性拆分 - 将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。\n\n基础设施：\n\n * 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。\n * 接口框架、api 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，api 网关是为了提升与外部服务对接的效率。\n * 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。\n * 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。\n\n\n# 微内核\n\n\n\n微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。\n\n插件管理\n\n核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。\n\n插件连接\n\n插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n\n常见的连接机制有 osgi（eclipse 使用）、消息模式、依赖注入（spring 使用），甚至使用分布式的协议都是可以的，比如 rpc 或者 http web 的方式。\n\n插件通信\n\n插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 cpu、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，cpu 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。\n\n\n# 易扩展的系统架构\n\n> 低耦合的系统更容易扩展、复用。\n\n可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。\n\n分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。\n\n在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。\n\n\n# 利用分布式消息队列降低系统耦合性\n\n\n# 事件驱动架构\n\n事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。\n\n\n# 分布式消息队列\n\n消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（fifo）的原则将消息通过远程通信接口发送给消息消费者程序。\n\n\n\n在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。\n\n在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。\n\n\n# 利用分布式服务打造可复用的业务平台\n\n巨无霸系统的问题：\n\n * 构建、部署困难\n * 代码分支管理困难\n * 数据库连接耗尽\n * 扩展业务困难\n\n而解决巨无霸系统问题的方案就是拆分：\n\n * 通过纵向拆分将业务拆分多个应用或模块；\n * 通过横向拆分将可复用业务作为独立应用。\n\n然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：spring cloud、dubbo 等。\n\n大型网站分布式服务的需求与特点：\n\n * 负载均衡\n * 失效转移\n * 高效的远程通信\n * 整合异构系统\n * 对应用最少侵入\n * 版本管理\n * 实时监控\n\n\n# 可扩展的数据结构\n\n传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。\n\n许多 nosql 数据库使用 columnfamily 设计来设计可扩展的数据结构。\n\n\n# 开放平台\n\n很多大公司会利用开放平台提供大量开放性 api 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。\n\n开放平台不是一朝一夕完成的，这需要大量 open api 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 open api 时，可以便捷的暴露服务接口。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统安全性架构",frontmatter:{title:"系统安全性架构",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","综合"],tags:["架构","安全"],permalink:"/pages/a1adcf/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/07.%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/07.系统安全性架构.md",key:"v-6c350cd6",path:"/pages/a1adcf/",headers:[{level:2,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:54},{level:3,title:"SSO",slug:"sso",normalizedTitle:"sso",charIndex:61},{level:4,title:"Session 共享问题",slug:"session-共享问题",normalizedTitle:"session 共享问题",charIndex:152},{level:4,title:"Cookie 跨域",slug:"cookie-跨域",normalizedTitle:"cookie 跨域",charIndex:440},{level:4,title:"CAS",slug:"cas",normalizedTitle:"cas",charIndex:815},{level:3,title:"Oauth 2.0",slug:"oauth-2-0",normalizedTitle:"oauth 2.0",charIndex:2080},{level:4,title:"基本原理",slug:"基本原理",normalizedTitle:"基本原理",charIndex:2093},{level:4,title:"授权模式",slug:"授权模式",normalizedTitle:"授权模式",charIndex:2572},{level:4,title:"授权码模式",slug:"授权码模式",normalizedTitle:"授权码模式",charIndex:2658},{level:4,title:"简化模式",slug:"简化模式",normalizedTitle:"简化模式",charIndex:2687},{level:4,title:"更新令牌",slug:"更新令牌",normalizedTitle:"更新令牌",charIndex:3113},{level:2,title:"鉴权",slug:"鉴权",normalizedTitle:"鉴权",charIndex:8461},{level:3,title:"RBAC",slug:"rbac",normalizedTitle:"rbac",charIndex:8468},{level:3,title:"角色继承",slug:"角色继承",normalizedTitle:"角色继承",charIndex:8669},{level:4,title:"职责分离(Separation of Duty)",slug:"职责分离-separation-of-duty",normalizedTitle:"职责分离(separation of duty)",charIndex:8775},{level:3,title:"RBAC0 模型",slug:"rbac0-模型",normalizedTitle:"rbac0 模型",charIndex:9109},{level:3,title:"RBAC1 模型",slug:"rbac1-模型",normalizedTitle:"rbac1 模型",charIndex:9405},{level:3,title:"RBAC2 模型",slug:"rbac2-模型",normalizedTitle:"rbac2 模型",charIndex:9643},{level:3,title:"RBAC3 模型",slug:"rbac3-模型",normalizedTitle:"rbac3 模型",charIndex:9977},{level:3,title:"什么是权限",slug:"什么是权限",normalizedTitle:"什么是权限",charIndex:10080},{level:3,title:"用户组的使用",slug:"用户组的使用",normalizedTitle:"用户组的使用",charIndex:10974},{level:3,title:"实例分析",slug:"实例分析",normalizedTitle:"实例分析",charIndex:11414},{level:3,title:"如何设计 RBAC 权限系统",slug:"如何设计-rbac-权限系统",normalizedTitle:"如何设计 rbac 权限系统",charIndex:11423},{level:3,title:"实例分析",slug:"实例分析-2",normalizedTitle:"实例分析",charIndex:11414},{level:2,title:"审计",slug:"审计",normalizedTitle:"审计",charIndex:9776},{level:2,title:"网站攻击",slug:"网站攻击",normalizedTitle:"网站攻击",charIndex:12211},{level:3,title:"XSS",slug:"xss",normalizedTitle:"xss",charIndex:17},{level:4,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:9440},{level:4,title:"攻击手段和目的",slug:"攻击手段和目的",normalizedTitle:"攻击手段和目的",charIndex:12750},{level:4,title:"应对手段",slug:"应对手段",normalizedTitle:"应对手段",charIndex:13061},{level:3,title:"CSRF",slug:"csrf",normalizedTitle:"csrf",charIndex:21},{level:4,title:"概念",slug:"概念-2",normalizedTitle:"概念",charIndex:9440},{level:4,title:"攻击手段和目的",slug:"攻击手段和目的-2",normalizedTitle:"攻击手段和目的",charIndex:12750},{level:4,title:"应对手段",slug:"应对手段-2",normalizedTitle:"应对手段",charIndex:13061},{level:3,title:"SQL 注入",slug:"sql-注入",normalizedTitle:"sql 注入",charIndex:26},{level:4,title:"概念",slug:"概念-3",normalizedTitle:"概念",charIndex:9440},{level:4,title:"攻击手段和目的",slug:"攻击手段和目的-3",normalizedTitle:"攻击手段和目的",charIndex:12750},{level:4,title:"应对手段",slug:"应对手段-3",normalizedTitle:"应对手段",charIndex:13061},{level:3,title:"DoS",slug:"dos",normalizedTitle:"dos",charIndex:33},{level:4,title:"攻击方式",slug:"攻击方式",normalizedTitle:"攻击方式",charIndex:13985},{level:4,title:"应对手段",slug:"应对手段-4",normalizedTitle:"应对手段",charIndex:13061},{level:2,title:"加密技术",slug:"加密技术",normalizedTitle:"加密技术",charIndex:16456},{level:3,title:"消息摘要",slug:"消息摘要",normalizedTitle:"消息摘要",charIndex:37},{level:3,title:"加密算法",slug:"加密算法",normalizedTitle:"加密算法",charIndex:42},{level:4,title:"对称加密",slug:"对称加密",normalizedTitle:"对称加密",charIndex:16550},{level:4,title:"非对称加密",slug:"非对称加密",normalizedTitle:"非对称加密",charIndex:16560},{level:4,title:"密钥安全管理",slug:"密钥安全管理",normalizedTitle:"密钥安全管理",charIndex:16911},{level:3,title:"证书",slug:"证书",normalizedTitle:"证书",charIndex:47},{level:4,title:"证书原理",slug:"证书原理",normalizedTitle:"证书原理",charIndex:17617},{level:2,title:"信息过滤",slug:"信息过滤",normalizedTitle:"信息过滤",charIndex:18056},{level:3,title:"文本匹配",slug:"文本匹配",normalizedTitle:"文本匹配",charIndex:13186},{level:3,title:"黑名单",slug:"黑名单",normalizedTitle:"黑名单",charIndex:10379},{level:3,title:"分类算法",slug:"分类算法",normalizedTitle:"分类算法",charIndex:18336},{level:2,title:"风险控制",slug:"风险控制",normalizedTitle:"风险控制",charIndex:18481},{level:3,title:"风险种类",slug:"风险种类",normalizedTitle:"风险种类",charIndex:18578},{level:3,title:"风险控制手段",slug:"风险控制手段",normalizedTitle:"风险控制手段",charIndex:18705},{level:3,title:"规则引擎",slug:"规则引擎",normalizedTitle:"规则引擎",charIndex:18778},{level:3,title:"统计模型",slug:"统计模型",normalizedTitle:"统计模型",charIndex:18783},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:19260}],headersStr:"认证 SSO Session 共享问题 Cookie 跨域 CAS Oauth 2.0 基本原理 授权模式 授权码模式 简化模式 更新令牌 鉴权 RBAC 角色继承 职责分离(Separation of Duty) RBAC0 模型 RBAC1 模型 RBAC2 模型 RBAC3 模型 什么是权限 用户组的使用 实例分析 如何设计 RBAC 权限系统 实例分析 审计 网站攻击 XSS 概念 攻击手段和目的 应对手段 CSRF 概念 攻击手段和目的 应对手段 SQL 注入 概念 攻击手段和目的 应对手段 DoS 攻击方式 应对手段 加密技术 消息摘要 加密算法 对称加密 非对称加密 密钥安全管理 证书 证书原理 信息过滤 文本匹配 黑名单 分类算法 风险控制 风险种类 风险控制手段 规则引擎 统计模型 参考资料",content:'# 系统安全性架构\n\n> 关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书\n\n\n# 认证\n\n\n# SSO\n\nSSO(Single Sign On)，即单点登录。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。\n\nSSO 需要解决多个异构系统之间的问题：\n\n * Session 共享问题\n * 跨域问题\n\n# Session 共享问题\n\n分布式 Session 的几种实现策略：\n\n * 粘性 Session - 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。\n * 应用服务器间的 Session 复制共享 - 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n * 基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。\n\n> 详情请参考：Session 原理\n\n# Cookie 跨域\n\nCookie 不能跨域！比如：浏览器不会把 www.google.com 的 cookie 传给 www.baidu.com。\n\n这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。\n\n针对 Cookie 不能跨域 的问题，有几种解决方案：\n\n * 服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。\n * 多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。\n * 将 Token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。\n\n# CAS\n\nCAS 是实现 SSO 的主流方式。\n\nCAS 分为两部分，CAS Server 和 CAS Client\n\n * CAS Server - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。\n * CAS Client - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。\n\n术语：\n\n * Ticket Granting Ticket (TGT) - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。\n * Ticket Granting Cookie (TGC) - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。\n * Service Ticket (ST) - 由 TGT 生成的一次性票据，用于验证，只能用一次。\n\nCAS 工作流程：\n\n\n\n 1. 用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。\n 2. 用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。\n 3. 浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。\n 4. CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。\n 5. 此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。\n 6. 重复类似 3、4 步骤。\n\n\n\n以上了归纳总结如下：\n\n 1. 访问服务 - 用户访问 SSO Client 资源。\n 2. 定向认证 - SSO Client 重定向用户请求到 SSO Server。\n 3. 用户认证 - 用户身份认证。\n 4. 发放票据 - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。\n 5. 验证票据 - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。\n 6. 传输用户信息 - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。\n\n\n# Oauth 2.0\n\n# 基本原理\n\nOAuth 在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n\n"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。\n\nOAuth 2.0 的运行流程如下图，摘自 RFC 6749。\n\n\n（A）用户打开客户端以后，客户端要求用户给予授权。\n\n（B）用户同意给予客户端授权。\n\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\n\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n\n（E）客户端使用令牌，向资源服务器申请获取资源。\n\n（F）资源服务器确认令牌无误，同意向客户端开放资源。\n\n不难看出来，上面六个步骤之中，B 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\n\n# 授权模式\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n# 授权码模式\n\n授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。\n\n\n它的步骤如下：\n\n（A）用户访问客户端，后者将前者导向认证服务器。\n\n（B）用户选择是否给予客户端授权。\n\n（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向 URI"（redirection URI），同时附上一个授权码。\n\n（D）客户端收到授权码，附上早先的"重定向 URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。\n\n（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n下面是上面这些步骤所需要的参数。\n\nA 步骤中，客户端申请认证的 URI，包含以下参数：\n\n * response_type：表示授权类型，必选项，此处的值固定为"code"\n * client_id：表示客户端的 ID，必选项\n * redirect_uri：表示重定向 URI，可选项\n * scope：表示申请的权限范围，可选项\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nGET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n  &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\n\n\nC 步骤中，服务器回应客户端的 URI，包含以下参数：\n\n * code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nHTTP/1.1 302 Found\nLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n    &state=xyz\n\n\nD 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：\n\n * grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。\n * code：表示上一步获得的授权码，必选项。\n * redirect_uri：表示重定向 URI，必选项，且必须与 A 步骤中的该参数值保持一致。\n * client_id：表示客户端 ID，必选项。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n\nE 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n\n下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",\n "example_parameter":"example_value"\n}\n\n\n从上面代码可以看到，相关参数使用 JSON 格式发送（Content-Type: application/json）。此外，HTTP 头信息中明确指定不得缓存。\n\n# 简化模式\n\n简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n\n\n它的步骤如下：\n\n（A）客户端将用户导向认证服务器。\n\n（B）用户决定是否给于客户端授权。\n\n（C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向 URI"，并在 URI 的 Hash 部分包含了访问令牌。\n\n（D）浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。\n\n（E）资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。\n\n（F）浏览器执行上一步获得的脚本，提取出令牌。\n\n（G）浏览器将令牌发给客户端。\n\n下面是上面这些步骤所需要的参数。\n\nA 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * response_type：表示授权类型，此处的值固定为"token"，必选项。\n * client_id：表示客户端的 ID，必选项。\n * redirect_uri：表示重定向的 URI，可选项。\n * scope：表示权限范围，可选项。\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nGET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n  &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\n\n\nC 步骤中，认证服务器回应客户端的 URI，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nHTTP/1.1 302 Found\nLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n         &state=xyz&token_type=example&expires_in=3600\n\n\n在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。\n\n根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。\n\n密码模式\n\n密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。\n\n在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。\n\n\n\n它的步骤如下：\n\n（A）用户向客户端提供用户名和密码。\n\n（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。\n\n（C）认证服务器确认无误后，向客户端提供访问令牌。\n\nB 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * grant_type：表示授权类型，此处的值固定为"password"，必选项。\n * username：表示用户名，必选项。\n * password：表示用户的密码，必选项。\n * scope：表示权限范围，可选项。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&username=johndoe&password=A3ddj3w\n\n\nC 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n整个过程中，客户端不得保存用户的密码。\n\n客户端模式\n\n客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。\n\n\n\n它的步骤如下：\n\n（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。\n\n（B）认证服务器确认无误后，向客户端提供访问令牌。\n\nA 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * granttype：表示授权类型，此处的值固定为"clientcredentials"，必选项。\n * scope：表示权限范围，可选项。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n\n\n认证服务器必须以某种方式，验证客户端身份。\n\nB 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n# 更新令牌\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 HTTP 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n# 鉴权\n\n\n# RBAC\n\nRBAC（Role-Based Access Control）即：基于角色的权限控制。通过角色关联用户，角色关联权限的方式间接赋予用户权限。\n\n每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。\n\n\n\n\n# 角色继承\n\n角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。\n\n\n\n# 职责分离(Separation of Duty)\n\n为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。\n\n职责分离有两种模式：\n\n静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。\n\n\n\n动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。\n\n\n\n讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。\n\n\n# RBAC0 模型\n\n最简单的用户、角色、权限模型。这里面又包含了 2 种：\n\n 1. 用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。\n 2. 用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。\n\n那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？\n\n如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。\n\n\n# RBAC1 模型\n\n相对于 RBAC0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。\n\n\n\n**使用场景：**如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。\n\n而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。\n\n\n# RBAC2 模型\n\n基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。\n\n * **角色互斥：**同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。\n * **基数约束：**一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的。\n * **先决条件角色：**指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。\n * **运行时互斥：**例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。\n\n\n# RBAC3 模型\n\n称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内，综合了 RBAC0、RBAC1 和 RBAC2 的所有特点，这里就不在多描述了。\n\n\n\n\n# 什么是权限\n\n说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？\n\n权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：页面权限、操作权限和数据权限（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。\n\n**页面权限：**所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。\n\n如下图：\n\n\n\n客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。\n\n**操作权限：**用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。\n\n**数据权限：**一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。\n\n简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。\n\n如下图：\n\n\n\n按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。\n\n换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。\n\n要实现数据权限有多种方式：\n\n 1. 可以利用 RBAC1 模型，通过角色分级来实现。\n 2. 在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。\n\n具体如何做呢？\n\n① 组织层级划分：\n\n\n\n**② 数据可视权限规则制定：**上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。\n\n通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。\n\n\n# 用户组的使用\n\n当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。\n\n例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。\n\n同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。\n\n用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。\n\n关于用户组的详细疑难解答，请查看https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！\n\n\n# 实例分析\n\n\n# 如何设计 RBAC 权限系统\n\n首先，我们思考一下一个简单的权限系统应该具备哪些内容？\n\n答案显而易见，RBAC 模型：用户-角色-权限。所以最基本的我们应该具备用户、角色、权限这三个内容。\n\n接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 RBAC 模型下，我们应该：创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户。\n\n将这个问题抽象为流程，如下图：\n\n\n\n现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？\n\n * 第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；\n * 第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。\n\n简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。\n\n\n# 实例分析\n\n① 创建角色列表\n\n\n\n在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。\n\n\n\n② 创建用户列表\n\n\n\n在用户列表快速创建一个用户：支持用户关联角色的功能。\n\n\n\n上述案例是基于最简单的 RBAC0 模型创建，适用于大部分常规的权限管理系统。\n\n下面再分析一下 RBAC1 中角色分级具体如何设计。\n\n 1. 在 RBAC0 的基础上，加上角色等级这个字段。\n 2. 权限分配规则制定：低等级角色只能在高等级角色权限基础上进行删减权限。\n\n具体界面呈现如下图：\n\n\n\n以上就是简单的 RBAC 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 RBAC 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。\n\n\n# 审计\n\nTODO\n\n\n# 网站攻击\n\n互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：\n\n\n# XSS\n\n# 概念\n\n跨站脚本（Cross-site scripting，通常简称为XSS） 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。\n\nXSS 攻击示例：\n\n假如有下面一个 textbox\n\n<input type="text" name="address1" value="value1from" />\n\n\nvalue1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 "/><script>alert(document.cookie)<\/script><!- 那么就会变成：\n\n<input type="text" name="address1" value="" />\n<script>\n  alert(document.cookie)\n<\/script>\n<!- ">\n\n\n嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。\n\n# 攻击手段和目的\n\n常用的 XSS 攻击手段和目的有：\n\n * 盗用 cookie，获取敏感信息。\n * 利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。\n * 利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n * 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n * 在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。\n\n# 应对手段\n\n * 过滤特殊字符 - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 > 转义为 &gt、< 转义为 &lt 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 3<5 中的 < 需要进行文本匹配后再转移，如：<img src= 这样的上下文中的 < 才转义。\n * 设置 Cookie 为 HttpOnly - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - 跨站脚本\n>  * Web 安全测试之 XSS\n\n\n# CSRF\n\n# 概念\n\n跨站请求伪造（Cross-site request forgery，CSRF），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\n\n# 攻击手段和目的\n\n可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\nCSRF 能做的事太多：\n\n * 以你名义发送邮件，发消息\n * 用你的账号购买商品\n * 用你的名义完成虚拟货币转账\n * 泄露个人隐私\n * ...\n\n# 应对手段\n\n * 表单 Token - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。\n * 验证码 - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。\n * Referer check - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - 跨站请求伪造\n>  * 浅谈 CSRF 攻击方式\n>  * 「每日一题」CSRF 是什么？「每日一题」CSRF 是什么？\n>  * WEB 安全之-CSRF（跨站请求伪造）\n\n\n# SQL 注入\n\n# 概念\n\nSQL 注入攻击（SQL injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。\n\n攻击示例：\n\n考虑以下简单的登录表单：\n\n<form action="/login" method="POST">\n  <p>Username: <input type="text" name="username" /></p>\n  <p>Password: <input type="password" name="password" /></p>\n  <p><input type="submit" value="登陆" /></p>\n</form>\n\n\n我们的处理里面的 SQL 可能是这样的：\n\nusername:=r.Form.Get("username")\npassword:=r.Form.Get("password")\nsql:="SELECT * FROM user WHERE username=\'"+username+"\' AND password=\'"+password+"\'"\n\n\n如果用户的输入的用户名如下，密码任意\n\nmyuser\' or \'foo\' = \'foo\' --\n\n\n那么我们的 SQL 变成了如下所示：\n\nSELECT * FROM user WHERE username=\'myuser\' or \'foo\' = \'foo\' --\'\' AND password=\'xxx\'\n\n\n在 SQL 里面 -- 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。\n\n对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。\n\nsql:="SELECT * FROM products WHERE name LIKE \'%"+prod+"%\'"\nDb.Exec(sql)\n\n\n如果攻击提交 a%\' exec master..xp_cmdshell \'net user test testpass /ADD\' -- 作为变量 prod 的值，那么 sql 将会变成\n\nsql:="SELECT * FROM products WHERE name LIKE \'%a%\' exec master..xp_cmdshell \'net user test testpass /ADD\'--%\'"\n\n\nMSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。\n\n虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。\n\n# 攻击手段和目的\n\n * 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。\n * 数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。\n * 数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD=\'xxxxxx\'）。\n * 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。\n * 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell "net stop iisadmin"可停止服务器的 IIS 服务）。\n * 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell "FORMAT C:"）。\n\n# 应对手段\n\n * 使用参数化查询 - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 Prepare 和 Query ，或者 Exec(query string, args ...interface{})。\n * 单引号转换 - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - SQL 注入攻击\n>  * 避免 SQL 注入\n>  * 实例讲解 SQL 注入攻击\n\n\n# DoS\n\n拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。\n\n当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。\n\n# 攻击方式\n\n * 带宽消耗型攻击\n * 资源消耗型攻击\n\n# 应对手段\n\n * 防火墙 - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。\n * 路由器、交换机 - 具有速度限制和访问控制能力。\n * 流量清洗 - 通过采用抗 DoS 软件处理，将正常流量和恶意流量区分开。\n\n> 👉 参考阅读：\n> \n>  * 拒绝服务攻击\n\n\n# 加密技术\n\n对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。\n\n信息加密技术一般分为：\n\n * 消息摘要\n * 加密算法\n   * 对称加密\n   * 非对称加密\n * 证书\n\n\n# 消息摘要\n\n常用数字签名算法：MD5、SHA 等。\n\n应用场景：将用户密码以消息摘要形式保存到数据库中。\n\n> 👉 参考阅读： Java 编码和加密\n\n\n# 加密算法\n\n# 对称加密\n\n对称加密指加密和解密所使用的密钥是同一个密钥。\n\n常用对称加密算法：DES、AES 等。\n\n应用场景：Cookie 加密、通信机密等。\n\n# 非对称加密\n\n非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。\n\n常用非对称加密算法：RSA 等。\n\n应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。\n\n> 👉 参考阅读： Java 编码和加密\n\n# 密钥安全管理\n\n保证密钥安全的方法：\n\n 1. 把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。\n 2. 把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。\n\n\n# 证书\n\n证书可以称为信息安全加密的终极手段。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。\n\n透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。\n\n众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。\n\n# 证书原理\n\nSSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n这里有两个问题：\n\n（1）如何保证公钥不被篡改？\n\n解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。\n\n（2）公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。\n\nSSL/TLS 协议的基本过程是这样的：\n\n 1. 客户端向服务器端索要并验证公钥。\n 2. 双方协商生成"对话密钥"。\n 3. 双方采用"对话密钥"进行加密通信。\n\n> 👉 参考阅读：\n> \n>  * 传输层安全性协议\n>  * 公开密钥认证\n>  * SSL/TLS 协议运行机制的概述\n\n\n# 信息过滤\n\n在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。\n\n常见的信息过滤与反垃圾手段有：\n\n\n# 文本匹配\n\n解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。\n\n\n# 黑名单\n\n黑名单就是将一些已经被识别出有违规行为的 IP、域名、邮箱等加入黑名单，拒绝其请求。\n\n黑名单可以通过 Hash 表来实现，方法简单，复杂度小，适于一般应用场景。\n\n但如果黑名单列表非常大时，Hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。\n\n\n# 分类算法\n\n对于海量信息，难以通过人工去审核。对广告贴。\n\n垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。\n\n简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。\n\n\n# 风险控制\n\n网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。\n\n\n# 风险种类\n\n * 账户风险 - 盗用账户、恶意注册账户等\n * 买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等\n * 卖家风险 - 虚假发货、出售违禁品、侵权等\n * 交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等\n\n\n# 风险控制手段\n\n大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。\n\n自动风控的技术手段主要有规则引擎和统计模型。\n\n\n# 规则引擎\n\n在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。\n\n如果以上这些条件都通过 if ... else ... 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。\n\n\n# 统计模型\n\n规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。\n\n为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。\n\n经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * Wiki 词条 - 跨站脚本\n * Web 安全测试之 XSS\n * Wiki 词条 - 跨站请求伪造\n * 浅谈 CSRF 攻击方式\n * 「每日一题」CSRF 是什么？「每日一题」CSRF 是什么？\n * WEB 安全之-CSRF（跨站请求伪造）\n * Wiki 词条 - SQL 注入攻击\n * 避免 SQL 注入\n * 实例讲解 SQL 注入攻击\n * 拒绝服务攻击\n * 传输层安全性协议\n * 公开密钥认证\n * SSL/TLS 协议运行机制的概述\n * http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n * CAS 实现 SSO 单点登录原理\n * 权限系统设计模型分析（DAC，MAC，RBAC，ABAC）\n * RBAC 模型：基于用户-角色-权限控制的一些思考',normalizedContent:'# 系统安全性架构\n\n> 关键词：xss、csrf、sql 注入、dos、消息摘要、加密算法、证书\n\n\n# 认证\n\n\n# sso\n\nsso(single sign on)，即单点登录。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。\n\nsso 需要解决多个异构系统之间的问题：\n\n * session 共享问题\n * 跨域问题\n\n# session 共享问题\n\n分布式 session 的几种实现策略：\n\n * 粘性 session - 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 session。\n * 应用服务器间的 session 复制共享 - 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n * 基于缓存的 session 共享 ✅ （推荐方案） - 不过需要程序自身控制 session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。\n\n> 详情请参考：session 原理\n\n# cookie 跨域\n\ncookie 不能跨域！比如：浏览器不会把 www.google.com 的 cookie 传给 www.baidu.com。\n\n这就存在一个问题：由于域名不同，用户在系统 a 登录后，浏览器记录系统 a 的 cookie，但是访问系统 b 的时候不会携带这个 cookie。\n\n针对 cookie 不能跨域 的问题，有几种解决方案：\n\n * 服务端生成 cookie 后，返回给客户端，客户端解析 cookie ，提取 token （比如 jwt），此后每次请求都携带这个 token。\n * 多个域名共享 cookie，在返回 cookie 给客户端的时候，在 cookie 中设置 domain 白名单。\n * 将 token 保存在 sessionstroage 中（不依赖 cookie 就没有跨域的问题了）。\n\n# cas\n\ncas 是实现 sso 的主流方式。\n\ncas 分为两部分，cas server 和 cas client\n\n * cas server - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。\n * cas client - 业务应用，需要接入 cas server。当用户访问我们的应用时，首先需要重定向到 cas server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。\n\n术语：\n\n * ticket granting ticket (tgt) - 可以认为是 cas server 根据用户名、密码生成的一张票，存在 server 端。\n * ticket granting cookie (tgc) - 其实就是一个 cookie，存放用户身份信息，由 server 发给 client 端。\n * service ticket (st) - 由 tgt 生成的一次性票据，用于验证，只能用一次。\n\ncas 工作流程：\n\n\n\n 1. 用户访问 cas client a（业务系统），第一次访问，重定向到认证服务中心（cas server）。cas server 发现当前请求中没有 cookie，再重定向到 cas server 的登录页面。重定向请求的 url 中包含访问地址，以便认证成功后直接跳转到访问页面。\n 2. 用户在登录页面输入用户名、密码等认证信息，认证成功后，cas server 生成 tgt，再用 tgt 生成一个 st。然后返回 st 和 tgc（cookie）给浏览器。\n 3. 浏览器携带 st 再度访问之前想访问的 cas client a 页面。\n 4. cas client a 收到 st 后，向 cas server 验证 st 的有效性。验证通过则允许用户访问页面。\n 5. 此时，如果登录另一个 cas client b，会先重定向到 cas server，cas server 可以判断这个 cas client b 是第一次访问，但是本地有 tgc，所以无需再次登录。用 tgc 创建一个 st，返回给浏览器。\n 6. 重复类似 3、4 步骤。\n\n\n\n以上了归纳总结如下：\n\n 1. 访问服务 - 用户访问 sso client 资源。\n 2. 定向认证 - sso client 重定向用户请求到 sso server。\n 3. 用户认证 - 用户身份认证。\n 4. 发放票据 - sso server 会产生一个 service ticket (st) 并返回给浏览器。\n 5. 验证票据 - 浏览器每次访问 sso client 时，携带 st，sso client 向 sso server 验证票据。只有验证通过，才允许访问。\n 6. 传输用户信息 - sso server 验证票据通过后，传输用户认证结果信息给 sso client。\n\n\n# oauth 2.0\n\n# 基本原理\n\noauth 在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n\n"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。\n\noauth 2.0 的运行流程如下图，摘自 rfc 6749。\n\n\n（a）用户打开客户端以后，客户端要求用户给予授权。\n\n（b）用户同意给予客户端授权。\n\n（c）客户端使用上一步获得的授权，向认证服务器申请令牌。\n\n（d）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n\n（e）客户端使用令牌，向资源服务器申请获取资源。\n\n（f）资源服务器确认令牌无误，同意向客户端开放资源。\n\n不难看出来，上面六个步骤之中，b 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\n\n# 授权模式\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。oauth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n# 授权码模式\n\n授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。\n\n\n它的步骤如下：\n\n（a）用户访问客户端，后者将前者导向认证服务器。\n\n（b）用户选择是否给予客户端授权。\n\n（c）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向 uri"（redirection uri），同时附上一个授权码。\n\n（d）客户端收到授权码，附上早先的"重定向 uri"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。\n\n（e）认证服务器核对了授权码和重定向 uri，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n下面是上面这些步骤所需要的参数。\n\na 步骤中，客户端申请认证的 uri，包含以下参数：\n\n * response_type：表示授权类型，必选项，此处的值固定为"code"\n * client_id：表示客户端的 id，必选项\n * redirect_uri：表示重定向 uri，可选项\n * scope：表示申请的权限范围，可选项\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nget /authorize?response_type=code&client_id=s6bhdrkqt3&state=xyz\n  &redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb http/1.1\nhost: server.example.com\n\n\nc 步骤中，服务器回应客户端的 uri，包含以下参数：\n\n * code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 id 和重定向 uri，是一一对应关系。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nhttp/1.1 302 found\nlocation: https://client.example.com/cb?code=splxlobezqqybys6wxsbia\n    &state=xyz\n\n\nd 步骤中，客户端向认证服务器申请令牌的 http 请求，包含以下参数：\n\n * grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。\n * code：表示上一步获得的授权码，必选项。\n * redirect_uri：表示重定向 uri，必选项，且必须与 a 步骤中的该参数值保持一致。\n * client_id：表示客户端 id，必选项。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=splxlobezqqybys6wxsbia\n&redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb\n\n\ne 步骤中，认证服务器发送的 http 回复，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n\n下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tgzv3jokf0xg5qx2tlkwia",\n "example_parameter":"example_value"\n}\n\n\n从上面代码可以看到，相关参数使用 json 格式发送（content-type: application/json）。此外，http 头信息中明确指定不得缓存。\n\n# 简化模式\n\n简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n\n\n它的步骤如下：\n\n（a）客户端将用户导向认证服务器。\n\n（b）用户决定是否给于客户端授权。\n\n（c）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向 uri"，并在 uri 的 hash 部分包含了访问令牌。\n\n（d）浏览器向资源服务器发出请求，其中不包括上一步收到的 hash 值。\n\n（e）资源服务器返回一个网页，其中包含的代码可以获取 hash 值中的令牌。\n\n（f）浏览器执行上一步获得的脚本，提取出令牌。\n\n（g）浏览器将令牌发给客户端。\n\n下面是上面这些步骤所需要的参数。\n\na 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * response_type：表示授权类型，此处的值固定为"token"，必选项。\n * client_id：表示客户端的 id，必选项。\n * redirect_uri：表示重定向的 uri，可选项。\n * scope：表示权限范围，可选项。\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nget /authorize?response_type=token&client_id=s6bhdrkqt3&state=xyz\n  &redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb http/1.1\nhost: server.example.com\n\n\nc 步骤中，认证服务器回应客户端的 uri，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nhttp/1.1 302 found\nlocation: http://example.com/cb#access_token=2yotnfzfejr1zcsicmwpaa\n         &state=xyz&token_type=example&expires_in=3600\n\n\n在上面的例子中，认证服务器用 http 头信息的 location 栏，指定浏览器重定向的网址。注意，在这个网址的 hash 部分包含了令牌。\n\n根据上面的 d 步骤，下一步浏览器会访问 location 指定的网址，但是 hash 部分不会发送。接下来的 e 步骤，服务提供商的资源服务器发送过来的代码，会提取出 hash 中的令牌。\n\n密码模式\n\n密码模式（resource owner password credentials grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。\n\n在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。\n\n\n\n它的步骤如下：\n\n（a）用户向客户端提供用户名和密码。\n\n（b）客户端将用户名和密码发给认证服务器，向后者请求令牌。\n\n（c）认证服务器确认无误后，向客户端提供访问令牌。\n\nb 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * grant_type：表示授权类型，此处的值固定为"password"，必选项。\n * username：表示用户名，必选项。\n * password：表示用户的密码，必选项。\n * scope：表示权限范围，可选项。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=password&username=johndoe&password=a3ddj3w\n\n\nc 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tgzv3jokf0xg5qx2tlkwia",\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n整个过程中，客户端不得保存用户的密码。\n\n客户端模式\n\n客户端模式（client credentials grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于 oauth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。\n\n\n\n它的步骤如下：\n\n（a）客户端向认证服务器进行身份认证，并要求一个访问令牌。\n\n（b）认证服务器确认无误后，向客户端提供访问令牌。\n\na 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * granttype：表示授权类型，此处的值固定为"clientcredentials"，必选项。\n * scope：表示权限范围，可选项。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n\n\n认证服务器必须以某种方式，验证客户端身份。\n\nb 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n# 更新令牌\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 http 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&refresh_token=tgzv3jokf0xg5qx2tlkwia\n\n\n\n# 鉴权\n\n\n# rbac\n\nrbac（role-based access control）即：基于角色的权限控制。通过角色关联用户，角色关联权限的方式间接赋予用户权限。\n\n每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 rbac 就是：用户关联角色，角色关联权限。\n\n\n\n\n# 角色继承\n\n角色继承(hierarchical role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。\n\n\n\n# 职责分离(separation of duty)\n\n为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 rbac 被提出。\n\n职责分离有两种模式：\n\n静态职责分离(static separation of duty)：用户无法同时被赋予有冲突的角色。\n\n\n\n动态职责分离(dynamic separation of duty)：用户在一次会话（session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。\n\n\n\n讲了这么多 rbac，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。\n\n\n# rbac0 模型\n\n最简单的用户、角色、权限模型。这里面又包含了 2 种：\n\n 1. 用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。\n 2. 用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。\n\n那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？\n\n如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。\n\n\n# rbac1 模型\n\n相对于 rbac0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。\n\n\n\n**使用场景：**如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 rbac0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。\n\n而 rbac1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。\n\n\n# rbac2 模型\n\n基于 rbac0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。\n\n * **角色互斥：**同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。\n * **基数约束：**一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 ceo 创建的，那这个角色的数量是有限的。\n * **先决条件角色：**指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。\n * **运行时互斥：**例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。\n\n\n# rbac3 模型\n\n称为统一模型，它包含了 rbac1 和 rbac2，利用传递性，也把 rbac0 包括在内，综合了 rbac0、rbac1 和 rbac2 的所有特点，这里就不在多描述了。\n\n\n\n\n# 什么是权限\n\n说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？\n\n权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：页面权限、操作权限和数据权限（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。\n\n**页面权限：**所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。\n\n如下图：\n\n\n\n客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。\n\n**操作权限：**用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。\n\n**数据权限：**一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。\n\n简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。\n\n如下图：\n\n\n\n按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。\n\n换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。\n\n要实现数据权限有多种方式：\n\n 1. 可以利用 rbac1 模型，通过角色分级来实现。\n 2. 在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。\n\n具体如何做呢？\n\n① 组织层级划分：\n\n\n\n**② 数据可视权限规则制定：**上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。\n\n通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。\n\n\n# 用户组的使用\n\n当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。\n\n例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。\n\n同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。\n\n用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。\n\n关于用户组的详细疑难解答，请查看https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！\n\n\n# 实例分析\n\n\n# 如何设计 rbac 权限系统\n\n首先，我们思考一下一个简单的权限系统应该具备哪些内容？\n\n答案显而易见，rbac 模型：用户-角色-权限。所以最基本的我们应该具备用户、角色、权限这三个内容。\n\n接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 rbac 模型下，我们应该：创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户。\n\n将这个问题抽象为流程，如下图：\n\n\n\n现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？\n\n * 第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；\n * 第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。\n\n简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。\n\n\n# 实例分析\n\n① 创建角色列表\n\n\n\n在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。\n\n\n\n② 创建用户列表\n\n\n\n在用户列表快速创建一个用户：支持用户关联角色的功能。\n\n\n\n上述案例是基于最简单的 rbac0 模型创建，适用于大部分常规的权限管理系统。\n\n下面再分析一下 rbac1 中角色分级具体如何设计。\n\n 1. 在 rbac0 的基础上，加上角色等级这个字段。\n 2. 权限分配规则制定：低等级角色只能在高等级角色权限基础上进行删减权限。\n\n具体界面呈现如下图：\n\n\n\n以上就是简单的 rbac 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 rbac 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。\n\n\n# 审计\n\ntodo\n\n\n# 网站攻击\n\n互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：\n\n\n# xss\n\n# 概念\n\n跨站脚本（cross-site scripting，通常简称为xss） 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 html 以及用户端脚本语言。\n\nxss 攻击示例：\n\n假如有下面一个 textbox\n\n<input type="text" name="address1" value="value1from" />\n\n\nvalue1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 "/><script>alert(document.cookie)<\/script><!- 那么就会变成：\n\n<input type="text" name="address1" value="" />\n<script>\n  alert(document.cookie)\n<\/script>\n<!- ">\n\n\n嵌入的 javascript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。\n\n# 攻击手段和目的\n\n常用的 xss 攻击手段和目的有：\n\n * 盗用 cookie，获取敏感信息。\n * 利用植入 flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 java 等得到类似的操作。\n * 利用 iframe、frame、xmlhttprequest 或上述 flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n * 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n * 在访问量极大的一些页面上的 xss 可以攻击一些小型网站，实现 ddos 攻击的效果。\n\n# 应对手段\n\n * 过滤特殊字符 - 将用户所提供的内容进行过滤，从而避免 html 和 jascript 代码的运行。如 > 转义为 &gt、< 转义为 &lt 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 3<5 中的 < 需要进行文本匹配后再转移，如：<img src= 这样的上下文中的 < 才转义。\n * 设置 cookie 为 httponly - 设置了 httponly 的 cookie 可以防止 javascript 脚本调用，就无法通过 document.cookie 获取用户 cookie 信息。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - 跨站脚本\n>  * web 安全测试之 xss\n\n\n# csrf\n\n# 概念\n\n跨站请求伪造（cross-site request forgery，csrf），也被称为 one-click attack 或者 session riding，通常缩写为 csrf 或者 xsrf。它是一种挟持用户在当前已登录的 web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（xss）相比，xss 利用的是用户对指定网站的信任，csrf 利用的是网站对用户网页浏览器的信任。\n\n# 攻击手段和目的\n\n可以如此理解 csrf：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\ncsrf 能做的事太多：\n\n * 以你名义发送邮件，发消息\n * 用你的账号购买商品\n * 用你的名义完成虚拟货币转账\n * 泄露个人隐私\n * ...\n\n# 应对手段\n\n * 表单 token - csrf 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。\n * 验证码 - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。\n * referer check - http 请求头的 referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - 跨站请求伪造\n>  * 浅谈 csrf 攻击方式\n>  * 「每日一题」csrf 是什么？「每日一题」csrf 是什么？\n>  * web 安全之-csrf（跨站请求伪造）\n\n\n# sql 注入\n\n# 概念\n\nsql 注入攻击（sql injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 sql 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 sql 指令而运行，因此遭到破坏或是入侵。\n\n攻击示例：\n\n考虑以下简单的登录表单：\n\n<form action="/login" method="post">\n  <p>username: <input type="text" name="username" /></p>\n  <p>password: <input type="password" name="password" /></p>\n  <p><input type="submit" value="登陆" /></p>\n</form>\n\n\n我们的处理里面的 sql 可能是这样的：\n\nusername:=r.form.get("username")\npassword:=r.form.get("password")\nsql:="select * from user where username=\'"+username+"\' and password=\'"+password+"\'"\n\n\n如果用户的输入的用户名如下，密码任意\n\nmyuser\' or \'foo\' = \'foo\' --\n\n\n那么我们的 sql 变成了如下所示：\n\nselect * from user where username=\'myuser\' or \'foo\' = \'foo\' --\'\' and password=\'xxx\'\n\n\n在 sql 里面 -- 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。\n\n对于 mssql 还有更加危险的一种 sql 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 mssql 数据库上执行系统命令。\n\nsql:="select * from products where name like \'%"+prod+"%\'"\ndb.exec(sql)\n\n\n如果攻击提交 a%\' exec master..xp_cmdshell \'net user test testpass /add\' -- 作为变量 prod 的值，那么 sql 将会变成\n\nsql:="select * from products where name like \'%a%\' exec master..xp_cmdshell \'net user test testpass /add\'--%\'"\n\n\nmssql 服务器会执行这条 sql 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 mssqlserver 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。\n\n虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。\n\n# 攻击手段和目的\n\n * 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。\n * 数据结构被黑客探知，得以做进一步攻击（例如 select * from sys.tables）。\n * 数据库服务器被攻击，系统管理员账户被窜改（例如 alter login sa with password=\'xxxxxx\'）。\n * 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 xss 等。\n * 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell "net stop iisadmin"可停止服务器的 iis 服务）。\n * 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell "format c:"）。\n\n# 应对手段\n\n * 使用参数化查询 - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 sql 语句中，即不要直接拼接 sql 语句。例如使用 database/sql 里面的查询函数 prepare 和 query ，或者 exec(query string, args ...interface{})。\n * 单引号转换 - 在组合 sql 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - sql 注入攻击\n>  * 避免 sql 注入\n>  * 实例讲解 sql 注入攻击\n\n\n# dos\n\n拒绝服务攻击（denial-of-service attack, dos）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。\n\n当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：ddos attack、ddos）。\n\n# 攻击方式\n\n * 带宽消耗型攻击\n * 资源消耗型攻击\n\n# 应对手段\n\n * 防火墙 - 允许或拒绝特定通讯协议，端口或 ip 地址。当攻击从少数不正常的 ip 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 ip 发出的通信。\n * 路由器、交换机 - 具有速度限制和访问控制能力。\n * 流量清洗 - 通过采用抗 dos 软件处理，将正常流量和恶意流量区分开。\n\n> 👉 参考阅读：\n> \n>  * 拒绝服务攻击\n\n\n# 加密技术\n\n对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。\n\n信息加密技术一般分为：\n\n * 消息摘要\n * 加密算法\n   * 对称加密\n   * 非对称加密\n * 证书\n\n\n# 消息摘要\n\n常用数字签名算法：md5、sha 等。\n\n应用场景：将用户密码以消息摘要形式保存到数据库中。\n\n> 👉 参考阅读： java 编码和加密\n\n\n# 加密算法\n\n# 对称加密\n\n对称加密指加密和解密所使用的密钥是同一个密钥。\n\n常用对称加密算法：des、aes 等。\n\n应用场景：cookie 加密、通信机密等。\n\n# 非对称加密\n\n非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。\n\n常用非对称加密算法：rsa 等。\n\n应用场景：https 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。\n\n> 👉 参考阅读： java 编码和加密\n\n# 密钥安全管理\n\n保证密钥安全的方法：\n\n 1. 把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。\n 2. 把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。\n\n\n# 证书\n\n证书可以称为信息安全加密的终极手段。公开密钥认证（英语：public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。\n\n透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 tls 实现并在万维网的 http 以 https、在电子邮件的 smtp 以 starttls 引入并广泛应用。\n\n众所周知，常见的应用层协议 http、ftp、telnet 本身不保证信息安全。但是加入了 ssl/tls 加密数据包机制的 https、ftps、telnets 是信息安全的。传输层安全性协议（transport layer security, tls），及其前身安全套接层（secure sockets layer, ssl）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。\n\n# 证书原理\n\nssl/tls 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n这里有两个问题：\n\n（1）如何保证公钥不被篡改？\n\n解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。\n\n（2）公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。\n\nssl/tls 协议的基本过程是这样的：\n\n 1. 客户端向服务器端索要并验证公钥。\n 2. 双方协商生成"对话密钥"。\n 3. 双方采用"对话密钥"进行加密通信。\n\n> 👉 参考阅读：\n> \n>  * 传输层安全性协议\n>  * 公开密钥认证\n>  * ssl/tls 协议运行机制的概述\n\n\n# 信息过滤\n\n在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。\n\n常见的信息过滤与反垃圾手段有：\n\n\n# 文本匹配\n\n解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。\n\n\n# 黑名单\n\n黑名单就是将一些已经被识别出有违规行为的 ip、域名、邮箱等加入黑名单，拒绝其请求。\n\n黑名单可以通过 hash 表来实现，方法简单，复杂度小，适于一般应用场景。\n\n但如果黑名单列表非常大时，hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。\n\n\n# 分类算法\n\n对于海量信息，难以通过人工去审核。对广告贴。\n\n垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。\n\n简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。\n\n\n# 风险控制\n\n网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。\n\n\n# 风险种类\n\n * 账户风险 - 盗用账户、恶意注册账户等\n * 买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等\n * 卖家风险 - 虚假发货、出售违禁品、侵权等\n * 交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等\n\n\n# 风险控制手段\n\n大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。\n\n自动风控的技术手段主要有规则引擎和统计模型。\n\n\n# 规则引擎\n\n在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。\n\n如果以上这些条件都通过 if ... else ... 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。\n\n\n# 统计模型\n\n规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。\n\n为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。\n\n经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * wiki 词条 - 跨站脚本\n * web 安全测试之 xss\n * wiki 词条 - 跨站请求伪造\n * 浅谈 csrf 攻击方式\n * 「每日一题」csrf 是什么？「每日一题」csrf 是什么？\n * web 安全之-csrf（跨站请求伪造）\n * wiki 词条 - sql 注入攻击\n * 避免 sql 注入\n * 实例讲解 sql 注入攻击\n * 拒绝服务攻击\n * 传输层安全性协议\n * 公开密钥认证\n * ssl/tls 协议运行机制的概述\n * http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n * cas 实现 sso 单点登录原理\n * 权限系统设计模型分析（dac，mac，rbac，abac）\n * rbac 模型：基于用户-角色-权限控制的一些思考',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"大型系统核心技术",frontmatter:{title:"大型系统核心技术",date:"2018-07-09T00:00:00.000Z",categories:["设计","架构","综合"],tags:["架构","分布式"],permalink:"/pages/8cbae8/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/08.%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html",relativePath:"03.设计/01.架构/00.综合/08.大型系统核心技术.md",key:"v-1cf67f56",path:"/pages/8cbae8/",headers:[{level:2,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:269},{level:2,title:"分布式锁",slug:"分布式锁",normalizedTitle:"分布式锁",charIndex:301},{level:3,title:"基于数据库实现分布式锁",slug:"基于数据库实现分布式锁",normalizedTitle:"基于数据库实现分布式锁",charIndex:444},{level:4,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:389},{level:5,title:"创建表",slug:"创建表",normalizedTitle:"创建表",charIndex:465},{level:5,title:"获取锁",slug:"获取锁",normalizedTitle:"获取锁",charIndex:919},{level:5,title:"释放锁",slug:"释放锁",normalizedTitle:"释放锁",charIndex:1133},{level:4,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:139},{level:4,title:"解决办法",slug:"解决办法",normalizedTitle:"解决办法",charIndex:1467},{level:4,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:1674},{level:3,title:"基于 Redis 实现分布式锁",slug:"基于-redis-实现分布式锁",normalizedTitle:"基于 redis 实现分布式锁",charIndex:1766},{level:4,title:"Redis 命令",slug:"redis-命令",normalizedTitle:"redis 命令",charIndex:1874},{level:4,title:"实现",slug:"实现-2",normalizedTitle:"实现",charIndex:389},{level:4,title:"问题",slug:"问题-2",normalizedTitle:"问题",charIndex:139},{level:4,title:"小结",slug:"小结-2",normalizedTitle:"小结",charIndex:1674},{level:3,title:"基于 ZooKeeper 实现分布式锁",slug:"基于-zookeeper-实现分布式锁",normalizedTitle:"基于 zookeeper 实现分布式锁",charIndex:2366},{level:4,title:"实现",slug:"实现-3",normalizedTitle:"实现",charIndex:389},{level:4,title:"小结",slug:"小结-3",normalizedTitle:"小结",charIndex:1674},{level:2,title:"分布式 Session",slug:"分布式-session",normalizedTitle:"分布式 session",charIndex:3128},{level:3,title:"Sticky Sessions",slug:"sticky-sessions",normalizedTitle:"sticky sessions",charIndex:3340},{level:3,title:"Session Replication",slug:"session-replication",normalizedTitle:"session replication",charIndex:3464},{level:3,title:"Session Server",slug:"session-server",normalizedTitle:"session server",charIndex:3569},{level:2,title:"分布式存储",slug:"分布式存储",normalizedTitle:"分布式存储",charIndex:3691},{level:2,title:"分布式缓存",slug:"分布式缓存",normalizedTitle:"分布式缓存",charIndex:3802},{level:2,title:"分布式计算",slug:"分布式计算",normalizedTitle:"分布式计算",charIndex:4140},{level:2,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:3179},{level:3,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:4159},{level:4,title:"轮询（Round Robin）",slug:"轮询-round-robin",normalizedTitle:"轮询（round robin）",charIndex:4165},{level:4,title:"加权轮询（Weighted Round Robbin）",slug:"加权轮询-weighted-round-robbin",normalizedTitle:"加权轮询（weighted round robbin）",charIndex:4394},{level:4,title:"最少连接（least Connections）",slug:"最少连接-least-connections",normalizedTitle:"最少连接（least connections）",charIndex:4552},{level:4,title:"加权最少连接（Weighted Least Connection）",slug:"加权最少连接-weighted-least-connection",normalizedTitle:"加权最少连接（weighted least connection）",charIndex:4852},{level:4,title:"随机算法（Random）",slug:"随机算法-random",normalizedTitle:"随机算法（random）",charIndex:4943},{level:4,title:"源地址哈希法 (IP Hash)",slug:"源地址哈希法-ip-hash",normalizedTitle:"源地址哈希法 (ip hash)",charIndex:5003},{level:3,title:"实现",slug:"实现-4",normalizedTitle:"实现",charIndex:389},{level:4,title:"HTTP 重定向",slug:"http-重定向",normalizedTitle:"http 重定向",charIndex:5184},{level:4,title:"DNS 重定向",slug:"dns-重定向",normalizedTitle:"dns 重定向",charIndex:5322},{level:4,title:"修改 MAC 地址",slug:"修改-mac-地址",normalizedTitle:"修改 mac 地址",charIndex:5470},{level:4,title:"修改 IP 地址",slug:"修改-ip-地址",normalizedTitle:"修改 ip 地址",charIndex:5545},{level:4,title:"代理自动配置",slug:"代理自动配置",normalizedTitle:"代理自动配置",charIndex:5579},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:5733}],headersStr:"分布式事务 分布式锁 基于数据库实现分布式锁 实现 创建表 获取锁 释放锁 问题 解决办法 小结 基于 Redis 实现分布式锁 Redis 命令 实现 问题 小结 基于 ZooKeeper 实现分布式锁 实现 小结 分布式 Session Sticky Sessions Session Replication Session Server 分布式存储 分布式缓存 分布式计算 负载均衡 算法 轮询（Round Robin） 加权轮询（Weighted Round Robbin） 最少连接（least Connections） 加权最少连接（Weighted Least Connection） 随机算法（Random） 源地址哈希法 (IP Hash) 实现 HTTP 重定向 DNS 重定向 修改 MAC 地址 修改 IP 地址 代理自动配置 资料",content:"# 大型系统核心技术\n\n> 大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。\n> \n> 单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。\n> \n> 分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。\n> \n> 本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。\n\n\n# 分布式事务\n\n> 参考：分布式原理#4-分布式事务问题\n\n\n# 分布式锁\n\nJava 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。\n\n分布式锁的解决方案大致有以下几种：\n\n * 基于数据库实现\n * 基于缓存（redis，memcached 等）实现\n * 基于 Zookeeper 实现\n\n\n# 基于数据库实现分布式锁\n\n# 实现\n\n# 创建表\n\nCREATE TABLE `methodLock` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',\n  `desc` varchar(1024) NOT NULL DEFAULT '备注信息',\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';\n\n\n# 获取锁\n\n想要锁住某个方法时，执行以下 SQL：\n\ninsert into methodLock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n# 释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:\n\ndelete from methodLock where method_name ='method_name'\n\n\n# 问题\n\n 1. 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n 2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n 3. 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n 4. 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n# 解决办法\n\n 1. 单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功\n 2. 写一个定时任务，隔一段时间清除一次过期的数据。\n 3. 写一个 while 循环，不断的重试插入，直到成功。\n 4. 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n# 小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 基于 Redis 实现分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。\n\n# Redis 命令\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n# 实现\n\n单点实现步骤：\n\n 1. 获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 问题\n\n * 单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。\n * 如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况\n\n# 小结\n\n可以考虑使用 redisson 的解决方案。\n\n\n# 基于 ZooKeeper 实现分布式锁\n\n# 实现\n\n这也是 ZooKeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 小结\n\nZooKeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。\n\n\n# 分布式 Session\n\n在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。\n\n分布式 Session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于 cache DB 缓存的 session 共享\n\n\n# Sticky Sessions\n\n需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。\n\n缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。\n\n\n\n\n# Session Replication\n\n在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。\n\n缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# Session Server\n\n使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。\n\n缺点：需要去实现存取 Session 的代码。\n\n\n\n\n# 分布式存储\n\n通常有两种解决方案：\n\n 1. 数据分布：就是把数据分块存在不同的服务器上（分库分表）。\n 2. 数据复制：让所有的服务器都有相同的数据，提供相当的服务。\n\n> 参考：分布式原理.md#2-数据分布\n\n\n# 分布式缓存\n\n使用缓存的好处：\n\n * 提升数据读取速度\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力\n * 降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本\n\n根据业务场景，通常缓存有以下几种使用方式\n\n * 懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache\n * 饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性\n\n缓存分类：\n\n * 应用内缓存：如：EHCache\n * 分布式缓存：如：Memached、Redis\n\n> 参考：分布式原理.md#6-分布式缓存问题\n\n\n# 分布式计算\n\n\n# 负载均衡\n\n\n# 算法\n\n# 轮询（Round Robin）\n\n轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。\n\n\n\n# 加权轮询（Weighted Round Robbin）\n\n加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。\n\n\n\n# 最少连接（least Connections）\n\n由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。\n\n\n\n最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n# 加权最少连接（Weighted Least Connection）\n\n在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n\n\n# 随机算法（Random）\n\n把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。\n\n\n\n# 源地址哈希法 (IP Hash)\n\n源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。\n\n * 优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。\n * 缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。\n\n\n\n\n# 实现\n\n# HTTP 重定向\n\nHTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。\n\n缺点：\n\n * 用户访问的延迟会增加；\n * 如果负载均衡器宕机，就无法访问该站点。\n\n\n\n# DNS 重定向\n\n使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。\n\n缺点：\n\n * DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。\n\n\n\n# 修改 MAC 地址\n\n使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。\n\n\n\n# 修改 IP 地址\n\n在网络层修改请求的目的 IP 地址。\n\n\n\n# 代理自动配置\n\n正向代理与反向代理的区别：\n\n * 正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在服务器端，用户不知道代理的存在。\n\nPAC 服务器是用来判断一个请求是否要经过代理。\n\n\n\n\n# 资料\n\n * https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html\n * https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md\n * https://www.jianshu.com/p/453c6e7ff81c\n * https://juejin.im/post/5a20cd8bf265da43163cdd9a\n * https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8\n * https://github.com/L316476844/distributed-session\n * 分布式缓存架构基础\n * 阿里 P8 技术专家细究分布式缓存问题",normalizedContent:"# 大型系统核心技术\n\n> 大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。\n> \n> 单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。\n> \n> 分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。\n> \n> 本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。\n\n\n# 分布式事务\n\n> 参考：分布式原理#4-分布式事务问题\n\n\n# 分布式锁\n\njava 原生 api 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。\n\n分布式锁的解决方案大致有以下几种：\n\n * 基于数据库实现\n * 基于缓存（redis，memcached 等）实现\n * 基于 zookeeper 实现\n\n\n# 基于数据库实现分布式锁\n\n# 实现\n\n# 创建表\n\ncreate table `methodlock` (\n  `id` int(11) not null auto_increment comment '主键',\n  `method_name` varchar(64) not null default '' comment '锁定的方法名',\n  `desc` varchar(1024) not null default '备注信息',\n  `update_time` timestamp not null default current_timestamp on update current_timestamp comment '保存数据时间，自动生成',\n  primary key (`id`),\n  unique key `uidx_method_name` (`method_name `) using btree\n) engine=innodb default charset=utf8 comment='锁定中的方法';\n\n\n# 获取锁\n\n想要锁住某个方法时，执行以下 sql：\n\ninsert into methodlock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n# 释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 sql:\n\ndelete from methodlock where method_name ='method_name'\n\n\n# 问题\n\n 1. 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n 2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n 3. 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n 4. 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n# 解决办法\n\n 1. 单点问题可以用多数据库实例，同时塞 n 个表，n/2+1 个成功就任务锁定成功\n 2. 写一个定时任务，隔一段时间清除一次过期的数据。\n 3. 写一个 while 循环，不断的重试插入，直到成功。\n 4. 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n# 小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 基于 redis 实现分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 redis、memcache、tair 等。这里以 redis 举例。\n\n# redis 命令\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n# 实现\n\n单点实现步骤：\n\n 1. 获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 uuid，再使用 expire 设置一个过期值。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 uuid 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 问题\n\n * 单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。\n * 如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况\n\n# 小结\n\n可以考虑使用 redisson 的解决方案。\n\n\n# 基于 zookeeper 实现分布式锁\n\n# 实现\n\n这也是 zookeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 a 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 b 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 a 处理完，删除自己的节点，线程 b 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 小结\n\nzookeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 zookeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 zookeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 zookeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 zookeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 zookeeper 实现分布式锁更加的简单，可靠性更高。但 zookeeper 因为需要频繁的创建和删除节点，性能上不如 redis 方式。\n\n\n# 分布式 session\n\n在分布式场景下，一个用户的 session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 session，就可能导致用户需要重新进行登录等操作。\n\n分布式 session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于 cache db 缓存的 session 共享\n\n\n# sticky sessions\n\n需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 session 存放在该服务器节点中。\n\n缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 session。\n\n\n\n\n# session replication\n\n在服务器节点之间进行 session 同步操作，这样的话用户可以访问任何一个服务器节点。\n\n缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# session server\n\n使用一个单独的服务器存储 session 数据，可以存在 mysql 数据库上，也可以存在 redis 或者 memcached 这种内存型数据库。\n\n缺点：需要去实现存取 session 的代码。\n\n\n\n\n# 分布式存储\n\n通常有两种解决方案：\n\n 1. 数据分布：就是把数据分块存在不同的服务器上（分库分表）。\n 2. 数据复制：让所有的服务器都有相同的数据，提供相当的服务。\n\n> 参考：分布式原理.md#2-数据分布\n\n\n# 分布式缓存\n\n使用缓存的好处：\n\n * 提升数据读取速度\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力\n * 降低存储成本，cache+db 的方式可以承担原有需要多台 db 才能承担的请求量，节省机器成本\n\n根据业务场景，通常缓存有以下几种使用方式\n\n * 懒汉式(读时触发)：写入 db 后, 然后把相关的数据也写入 cache\n * 饥饿式(写时触发)：先查询 db 里的数据, 然后把相关的数据写入 cache\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性\n\n缓存分类：\n\n * 应用内缓存：如：ehcache\n * 分布式缓存：如：memached、redis\n\n> 参考：分布式原理.md#6-分布式缓存问题\n\n\n# 分布式计算\n\n\n# 负载均衡\n\n\n# 算法\n\n# 轮询（round robin）\n\n轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 server 2）。\n\n\n\n# 加权轮询（weighted round robbin）\n\n加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。\n\n\n\n# 最少连接（least connections）\n\n由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。\n\n\n\n最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n# 加权最少连接（weighted least connection）\n\n在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n\n\n# 随机算法（random）\n\n把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。\n\n\n\n# 源地址哈希法 (ip hash)\n\n源地址哈希通过对客户端 ip 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。\n\n * 优点：保证同一 ip 的客户端都会被 hash 到同一台服务器上。\n * 缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 hash 改进。\n\n\n\n\n# 实现\n\n# http 重定向\n\nhttp 重定向负载均衡服务器收到 http 请求之后会返回服务器的地址，并将该地址写入 http 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。\n\n缺点：\n\n * 用户访问的延迟会增加；\n * 如果负载均衡器宕机，就无法访问该站点。\n\n\n\n# dns 重定向\n\n使用 dns 作为负载均衡器，根据负载情况返回不同服务器的 ip 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。\n\n缺点：\n\n * dns 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。\n\n\n\n# 修改 mac 地址\n\n使用 lvs（linux virtual server）这种链路层负载均衡器，根据负载情况修改请求的 mac 地址。\n\n\n\n# 修改 ip 地址\n\n在网络层修改请求的目的 ip 地址。\n\n\n\n# 代理自动配置\n\n正向代理与反向代理的区别：\n\n * 正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在服务器端，用户不知道代理的存在。\n\npac 服务器是用来判断一个请求是否要经过代理。\n\n\n\n\n# 资料\n\n * https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html\n * https://github.com/cyc2018/interview-notebook/blob/master/notes/%e5%88%86%e5%b8%83%e5%bc%8f%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90.md\n * https://www.jianshu.com/p/453c6e7ff81c\n * https://juejin.im/post/5a20cd8bf265da43163cdd9a\n * https://github.com/redisson/redisson/wiki/8.-%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%92%8c%e5%90%8c%e6%ad%a5%e5%99%a8\n * https://github.com/l316476844/distributed-session\n * 分布式缓存架构基础\n * 阿里 p8 技术专家细究分布式缓存问题",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"系统测试架构",frontmatter:{title:"系统测试架构",date:"2019-12-10T17:00:00.000Z",categories:["设计","架构","综合"],tags:["架构","设计","测试"],permalink:"/pages/641e5c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/00.%E7%BB%BC%E5%90%88/09.%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/00.综合/09.系统测试架构.md",key:"v-c62a590a",path:"/pages/641e5c/",headers:[{level:2,title:"测试方法分类",slug:"测试方法分类",normalizedTitle:"测试方法分类",charIndex:301},{level:3,title:"从测试设计方法分类",slug:"从测试设计方法分类",normalizedTitle:"从测试设计方法分类",charIndex:312},{level:3,title:"从测试的目的分类",slug:"从测试的目的分类",normalizedTitle:"从测试的目的分类",charIndex:597},{level:4,title:"功能测试",slug:"功能测试",normalizedTitle:"功能测试",charIndex:609},{level:4,title:"非功能测试",slug:"非功能测试",normalizedTitle:"非功能测试",charIndex:983},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1388}],headersStr:"测试方法分类 从测试设计方法分类 从测试的目的分类 功能测试 非功能测试 参考资料",content:"# 系统测试架构\n\n> 软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。\n> \n> 现代软件开发项目中，分工明确，基本上都会有研发、测试、QA 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。\n> \n> 注意：\n> \n>  * 为了方便，只有测试人员需要关注的测试点用【测试】标注；\n>  * 而只有研发人员需要关注的测试点用【研发】标注；\n>  * 都需要关注的测试点则不作标注。\n\n\n# 测试方法分类\n\n\n# 从测试设计方法分类\n\n * 黑盒测试【测试】 - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。\n * 白盒测试【研发】 - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。\n * 灰盒测试 - 介于黑盒和白盒之间。\n\n> 小结：\n> \n>  * 黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。\n>  * 白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。\n>  * 灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。\n\n\n# 从测试的目的分类\n\n# 功能测试\n\n * 单元测试（Unit Test） - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】\n   * 常用技术：junit4、junit5、mockito、assertj-core\n * 功能测试（Functional Test） - 验证模块的功能。【测试】\n * 集成测试（Integration Test） - 验证几个互相有依赖关系的模块的功能。【测试】\n * 场景测试（Scenario Test）- 验证几个模块是否能完成一个用户场景。【测试】\n * 系统测试（System Test） - 对于整个系统功能的测试。【测试】\n * Alpha 测试 - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】\n * Beta 测试 - 也叫公测，是真实的用户在真实的环境中进行的测试。\n\n# 非功能测试\n\n * 压力测试（Stress test） - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃\n * 负载测试（Load test） - 测试软件在负载情况下能否正常工作\n * 性能测试（Performance test） - 测试软件的效能，是否提供满意的服务质量。\n   * 常用技术：JMeter、JMH。\n * 软件辅助功能测试（Accessibility test） - 测试软件是否向残疾用户提供足够的辅助功能\n * 本地化/全球化测试（Localization/Globalization）\n * 兼容性测试（Compatibility Test）\n * 配置测试（Configuration Test） - 测试软件在各种配置下能否正常工作\n * 可用性测试（Usability Test） – 测试软件是否好用\n * 安全性测试（Security Test）\n\n\n# 参考资料\n\n * 软件测试 (一) 软件测试方法大汇总\n * Java 微基准测试框架 JMH",normalizedContent:"# 系统测试架构\n\n> 软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。\n> \n> 现代软件开发项目中，分工明确，基本上都会有研发、测试、qa 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。\n> \n> 注意：\n> \n>  * 为了方便，只有测试人员需要关注的测试点用【测试】标注；\n>  * 而只有研发人员需要关注的测试点用【研发】标注；\n>  * 都需要关注的测试点则不作标注。\n\n\n# 测试方法分类\n\n\n# 从测试设计方法分类\n\n * 黑盒测试【测试】 - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。\n * 白盒测试【研发】 - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。\n * 灰盒测试 - 介于黑盒和白盒之间。\n\n> 小结：\n> \n>  * 黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。\n>  * 白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。\n>  * 灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。\n\n\n# 从测试的目的分类\n\n# 功能测试\n\n * 单元测试（unit test） - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】\n   * 常用技术：junit4、junit5、mockito、assertj-core\n * 功能测试（functional test） - 验证模块的功能。【测试】\n * 集成测试（integration test） - 验证几个互相有依赖关系的模块的功能。【测试】\n * 场景测试（scenario test）- 验证几个模块是否能完成一个用户场景。【测试】\n * 系统测试（system test） - 对于整个系统功能的测试。【测试】\n * alpha 测试 - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】\n * beta 测试 - 也叫公测，是真实的用户在真实的环境中进行的测试。\n\n# 非功能测试\n\n * 压力测试（stress test） - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃\n * 负载测试（load test） - 测试软件在负载情况下能否正常工作\n * 性能测试（performance test） - 测试软件的效能，是否提供满意的服务质量。\n   * 常用技术：jmeter、jmh。\n * 软件辅助功能测试（accessibility test） - 测试软件是否向残疾用户提供足够的辅助功能\n * 本地化/全球化测试（localization/globalization）\n * 兼容性测试（compatibility test）\n * 配置测试（configuration test） - 测试软件在各种配置下能否正常工作\n * 可用性测试（usability test） – 测试软件是否好用\n * 安全性测试（security test）\n\n\n# 参考资料\n\n * 软件测试 (一) 软件测试方法大汇总\n * java 微基准测试框架 jmh",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"微服务简介",frontmatter:{title:"微服务简介",date:"2022-04-15T16:42:51.000Z",categories:["设计","架构","微服务"],tags:["设计","架构","微服务"],permalink:"/pages/012075/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B.html",relativePath:"03.设计/01.架构/01.微服务/01.微服务简介.md",key:"v-58986cb9",path:"/pages/012075/",headers:[{level:2,title:"什么是微服务",slug:"什么是微服务",normalizedTitle:"什么是微服务",charIndex:12},{level:3,title:"单体应用",slug:"单体应用",normalizedTitle:"单体应用",charIndex:285},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:2},{level:2,title:"何时需要微服务",slug:"何时需要微服务",normalizedTitle:"何时需要微服务",charIndex:889},{level:3,title:"拆分服务的思考维度",slug:"拆分服务的思考维度",normalizedTitle:"拆分服务的思考维度",charIndex:973},{level:3,title:"拆分服务的原则",slug:"拆分服务的原则",normalizedTitle:"拆分服务的原则",charIndex:1209},{level:3,title:"拆分服务的前置条件",slug:"拆分服务的前置条件",normalizedTitle:"拆分服务的前置条件",charIndex:1261},{level:2,title:"微服务的基础架构",slug:"微服务的基础架构",normalizedTitle:"微服务的基础架构",charIndex:1973},{level:3,title:"服务描述",slug:"服务描述",normalizedTitle:"服务描述",charIndex:2012},{level:3,title:"注册中心",slug:"注册中心",normalizedTitle:"注册中心",charIndex:1506},{level:3,title:"服务框架",slug:"服务框架",normalizedTitle:"服务框架",charIndex:2028},{level:3,title:"服务监控",slug:"服务监控",normalizedTitle:"服务监控",charIndex:2036},{level:3,title:"服务链路追踪",slug:"服务链路追踪",normalizedTitle:"服务链路追踪",charIndex:3373},{level:3,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:792},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4299}],headersStr:"什么是微服务 单体应用 微服务 何时需要微服务 拆分服务的思考维度 拆分服务的原则 拆分服务的前置条件 微服务的基础架构 服务描述 注册中心 服务框架 服务监控 服务链路追踪 服务治理 参考资料",content:"# 微服务简介\n\n\n# 什么是微服务\n\n> Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。——微服务的维基百科词条定义\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。在演化过程中，架构越来越复杂，一个应用被拆分的服务也越来越细。\n\n\n# 单体应用\n\n互联网早期的技术栈通常为 LAMP（Linux + Apache + MySQL + PHP）或 MVC（Spring + iBatis/Hibernate + Tomcat）。这两种架构都是典型的单体应用架构。其优点是技术栈简单，因此学习上手快，部署也容易。\n\n随着业务越来越复杂，开发团队规模不断扩张，单体应用架构就难以适应开发迭代节奏，主要有以下问题：\n\n * 构建、部署效率低：代码越多，依赖资源越多，则构建、部署的耗费时间自然会越长。即使每次修改一个很小的功能点，也不得不全量构建、全部部署，耗时耗力。\n * 团队协作成本高：单体应用的代码往往在一个工程中，而一个工程中的开发人员越多，显然沟通成本越高。\n * 可用性差：因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。\n\n\n# 微服务\n\n微服务架构有以下 4 个特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n简单来说，微服务就是将庞杂臃肿的单体应用拆分成细粒度的服务，独立部署，并交给各个中小团队来负责开发、测试、上线和运维整个生命周期。\n\n\n# 何时需要微服务\n\n应用微服务化架构前，要思考几个问题：什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n\n# 拆分服务的思考维度\n\n * 业务维度：业务和数据关系密切的应该拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。\n * 功能维度：公共功能聚合为一个服务。标准是是否被多个其他服务调用，且依赖的资源独立不与其他业务耦合。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n但并不是说功能拆分的越细越好，过度的拆分反而会让服务数量膨胀变得难以管理，因此找到符合自己业务现状和团队人员技术水平的拆分粒度才是可取的。\n\n\n# 拆分服务的原则\n\n单一职责\n\n高内聚，低耦合\n\n先粗后细，逐渐细化\n\n渐进式迭代\n\n考虑扩展性\n\n\n# 拆分服务的前置条件\n\n * 服务如何定义？\n   * 对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。\n   * 对于微服务来说，每个服务都运行在各自的进程之中，无论采用哪种通讯协议，是 HTTP 还是 RPC，服务之间的调用都通过接口来约定如何交互。约定内容包括接口名、接口参数以及接口返回值。\n * 服务如何发布和订阅？\n   * 单体应用由于部署在同一个 WAR 包里，接口之间的调用属于进程内的调用。\n   * 对于微服务来说，服务提供者需要向注册中心发布自己提供的服务（暴露接口信息以及接口地址）；服务消费者向注册中心订阅哪些服务可用。\n * 服务如何监控？通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。\n * 服务如何治理？可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。\n * 故障如何定位？在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。\n\n应用微服务架构，必须要先解决以上问题\n\n\n# 微服务的基础架构\n\n微服务架构下，服务调用主要依赖下面几个基本组件：\n\n * 服务描述\n * 注册中心\n * 服务框架\n * 服务监控\n * 服务追踪\n * 服务治理\n\n\n# 服务描述\n\n服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。\n\n常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。\n\n其中，RESTful API 方式通常用于 HTTP 协议的服务描述，并且常用 Wiki 或者Swagger来进行管理。下面是一个 RESTful API 方式的服务描述的例子。\n\nXML 配置方式多用作 RPC 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。下面是一个 XML 配置方式的服务描述的例子。\n\nIDL 文件方式通常用作 Thrift 和 gRPC 这类跨语言服务调用框架中，比如 gRPC 就是通过 Protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。\n\n\n# 注册中心\n\n\n\n有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 服务框架\n\n服务消费者发起调用需解决以下问题：\n\n * 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？\n * 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。\n * 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 JSON 序列化、Java 对象序列化以及 Protobuf 序列化等。\n\n\n# 服务监控\n\n一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。\n\n * 数据收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。\n * 数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。\n * 数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 Dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。\n\n\n# 服务链路追踪\n\n除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。\n\n服务链路追踪的工作原理大致如下：\n\n * 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。\n * 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。\n\n以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。\n\n\n# 服务治理\n\n服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。\n\n在生产环境中，你应该经常会遇到下面几种状况。\n\n * 单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。\n * 单 IDC 故障。你应该经常听说某某 App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 IDC 的流量到其他正常 IDC，可以避免因为单 IDC 故障引起的大批量业务受影响。\n * 依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。\n\n上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。\n\n\n# 参考资料\n\n * 从 0 开始学微服务",normalizedContent:"# 微服务简介\n\n\n# 什么是微服务\n\n> martin fowler 与 james lewis 共同提出了微服务的概念，定义了微服务是由单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 http api 通信。同时服务会使用最小的规模的集中管理 (例如 docker) 能力，服务可以用不同的编程语言与数据库等组件实现。——微服务的维基百科词条定义\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。在演化过程中，架构越来越复杂，一个应用被拆分的服务也越来越细。\n\n\n# 单体应用\n\n互联网早期的技术栈通常为 lamp（linux + apache + mysql + php）或 mvc（spring + ibatis/hibernate + tomcat）。这两种架构都是典型的单体应用架构。其优点是技术栈简单，因此学习上手快，部署也容易。\n\n随着业务越来越复杂，开发团队规模不断扩张，单体应用架构就难以适应开发迭代节奏，主要有以下问题：\n\n * 构建、部署效率低：代码越多，依赖资源越多，则构建、部署的耗费时间自然会越长。即使每次修改一个很小的功能点，也不得不全量构建、全部部署，耗时耗力。\n * 团队协作成本高：单体应用的代码往往在一个工程中，而一个工程中的开发人员越多，显然沟通成本越高。\n * 可用性差：因为所有的功能开发最后都部署到同一个 war 包里，运行在同一个 tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 war 包中部署的功能。\n\n\n# 微服务\n\n微服务架构有以下 4 个特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n简单来说，微服务就是将庞杂臃肿的单体应用拆分成细粒度的服务，独立部署，并交给各个中小团队来负责开发、测试、上线和运维整个生命周期。\n\n\n# 何时需要微服务\n\n应用微服务化架构前，要思考几个问题：什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n\n# 拆分服务的思考维度\n\n * 业务维度：业务和数据关系密切的应该拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。\n * 功能维度：公共功能聚合为一个服务。标准是是否被多个其他服务调用，且依赖的资源独立不与其他业务耦合。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n但并不是说功能拆分的越细越好，过度的拆分反而会让服务数量膨胀变得难以管理，因此找到符合自己业务现状和团队人员技术水平的拆分粒度才是可取的。\n\n\n# 拆分服务的原则\n\n单一职责\n\n高内聚，低耦合\n\n先粗后细，逐渐细化\n\n渐进式迭代\n\n考虑扩展性\n\n\n# 拆分服务的前置条件\n\n * 服务如何定义？\n   * 对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。\n   * 对于微服务来说，每个服务都运行在各自的进程之中，无论采用哪种通讯协议，是 http 还是 rpc，服务之间的调用都通过接口来约定如何交互。约定内容包括接口名、接口参数以及接口返回值。\n * 服务如何发布和订阅？\n   * 单体应用由于部署在同一个 war 包里，接口之间的调用属于进程内的调用。\n   * 对于微服务来说，服务提供者需要向注册中心发布自己提供的服务（暴露接口信息以及接口地址）；服务消费者向注册中心订阅哪些服务可用。\n * 服务如何监控？通常对于一个服务，我们最关心的是 qps（调用量）、avgtime（平均耗时）以及 p999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。\n * 服务如何治理？可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。\n * 故障如何定位？在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。\n\n应用微服务架构，必须要先解决以上问题\n\n\n# 微服务的基础架构\n\n微服务架构下，服务调用主要依赖下面几个基本组件：\n\n * 服务描述\n * 注册中心\n * 服务框架\n * 服务监控\n * 服务追踪\n * 服务治理\n\n\n# 服务描述\n\n服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。\n\n常用的服务描述方式包括 restful api、xml 配置以及 idl 文件三种。\n\n其中，restful api 方式通常用于 http 协议的服务描述，并且常用 wiki 或者swagger来进行管理。下面是一个 restful api 方式的服务描述的例子。\n\nxml 配置方式多用作 rpc 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。下面是一个 xml 配置方式的服务描述的例子。\n\nidl 文件方式通常用作 thrift 和 grpc 这类跨语言服务调用框架中，比如 grpc 就是通过 protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。\n\n\n# 注册中心\n\n\n\n有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 服务框架\n\n服务消费者发起调用需解决以下问题：\n\n * 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 tcp、udp 协议，还是采用七层 http 协议，还是采用其他协议？\n * 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。\n * 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 json 序列化、java 对象序列化以及 protobuf 序列化等。\n\n\n# 服务监控\n\n一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。\n\n * 数据收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。\n * 数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。\n * 数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。\n\n\n# 服务链路追踪\n\n除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。\n\n服务链路追踪的工作原理大致如下：\n\n * 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。\n * 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。\n\n以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。\n\n\n# 服务治理\n\n服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。\n\n在生产环境中，你应该经常会遇到下面几种状况。\n\n * 单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。\n * 单 idc 故障。你应该经常听说某某 app，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 idc 的流量到其他正常 idc，可以避免因为单 idc 故障引起的大批量业务受影响。\n * 依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。\n\n上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。\n\n\n# 参考资料\n\n * 从 0 开始学微服务",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"微服务基本原理",frontmatter:{title:"微服务基本原理",date:"2020-07-21T15:35:00.000Z",categories:["设计","架构","微服务"],tags:["设计","架构","微服务"],permalink:"/pages/aa7497/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"03.设计/01.架构/01.微服务/02.微服务基本原理.md",key:"v-121637aa",path:"/pages/aa7497/",headers:[{level:2,title:"微服务简介",slug:"微服务简介",normalizedTitle:"微服务简介",charIndex:14},{level:3,title:"什么是微服务架构",slug:"什么是微服务架构",normalizedTitle:"什么是微服务架构",charIndex:24},{level:3,title:"如何权衡微服务的利弊",slug:"如何权衡微服务的利弊",normalizedTitle:"如何权衡微服务的利弊",charIndex:190},{level:3,title:"康威定律",slug:"康威定律",normalizedTitle:"康威定律",charIndex:280},{level:3,title:"如何拆分微服务",slug:"如何拆分微服务",normalizedTitle:"如何拆分微服务",charIndex:411},{level:2,title:"微服务技术架构",slug:"微服务技术架构",normalizedTitle:"微服务技术架构",charIndex:682},{level:2,title:"服务注册发现",slug:"服务注册发现",normalizedTitle:"服务注册发现",charIndex:808},{level:3,title:"注册中心的工作流程",slug:"注册中心的工作流程",normalizedTitle:"注册中心的工作流程",charIndex:1205},{level:3,title:"注册中心实现模式",slug:"注册中心实现模式",normalizedTitle:"注册中心实现模式",charIndex:1397},{level:4,title:"应用内注册和发现",slug:"应用内注册和发现",normalizedTitle:"应用内注册和发现",charIndex:1409},{level:4,title:"应用外注册和发现",slug:"应用外注册和发现",normalizedTitle:"应用外注册和发现",charIndex:1697},{level:4,title:"注册中心选型",slug:"注册中心选型",normalizedTitle:"注册中心选型",charIndex:1986},{level:5,title:"高可用性",slug:"高可用性",normalizedTitle:"高可用性",charIndex:1996},{level:5,title:"数据一致性",slug:"数据一致性",normalizedTitle:"数据一致性",charIndex:2053},{level:3,title:"服务注册发现的问题",slug:"服务注册发现的问题",normalizedTitle:"服务注册发现的问题",charIndex:2557},{level:4,title:"多注册中心",slug:"多注册中心",normalizedTitle:"多注册中心",charIndex:2570},{level:4,title:"并行订阅服务",slug:"并行订阅服务",normalizedTitle:"并行订阅服务",charIndex:2635},{level:4,title:"批量注销服务",slug:"批量注销服务",normalizedTitle:"批量注销服务",charIndex:2756},{level:4,title:"服务变更信息同步更新",slug:"服务变更信息同步更新",normalizedTitle:"服务变更信息同步更新",charIndex:2825},{level:3,title:"识别服务节点是否存活",slug:"识别服务节点是否存活",normalizedTitle:"识别服务节点是否存活",charIndex:2962},{level:4,title:"心跳开关保护机制",slug:"心跳开关保护机制",normalizedTitle:"心跳开关保护机制",charIndex:2976},{level:4,title:"服务节点摘除保护机制",slug:"服务节点摘除保护机制",normalizedTitle:"服务节点摘除保护机制",charIndex:3465},{level:2,title:"服务通信",slug:"服务通信",normalizedTitle:"服务通信",charIndex:4006},{level:3,title:"序列化方式",slug:"序列化方式",normalizedTitle:"序列化方式",charIndex:4365},{level:3,title:"通信协议",slug:"通信协议",normalizedTitle:"通信协议",charIndex:4061},{level:2,title:"服务监控",slug:"服务监控",normalizedTitle:"服务监控",charIndex:4929},{level:3,title:"监控对象",slug:"监控对象",normalizedTitle:"监控对象",charIndex:5060},{level:3,title:"系统监控原理",slug:"系统监控原理",normalizedTitle:"系统监控原理",charIndex:5276},{level:4,title:"数据采集",slug:"数据采集",normalizedTitle:"数据采集",charIndex:5322},{level:4,title:"数据传输",slug:"数据传输",normalizedTitle:"数据传输",charIndex:4289},{level:4,title:"数据处理",slug:"数据处理",normalizedTitle:"数据处理",charIndex:5332},{level:4,title:"数据展示",slug:"数据展示",normalizedTitle:"数据展示",charIndex:5337},{level:3,title:"监控技术",slug:"监控技术",normalizedTitle:"监控技术",charIndex:6180},{level:2,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:160},{level:2,title:"API 网关",slug:"api-网关",normalizedTitle:"api 网关",charIndex:6951},{level:3,title:"Zuul",slug:"zuul",normalizedTitle:"zuul",charIndex:7188},{level:2,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:6772},{level:2,title:"服务路由",slug:"服务路由",normalizedTitle:"服务路由",charIndex:6822},{level:3,title:"服务路由的应用场景",slug:"服务路由的应用场景",normalizedTitle:"服务路由的应用场景",charIndex:7739},{level:3,title:"服务路由的规则",slug:"服务路由的规则",normalizedTitle:"服务路由的规则",charIndex:8228},{level:4,title:"条件路由",slug:"条件路由",normalizedTitle:"条件路由",charIndex:8252},{level:4,title:"脚本路由",slug:"脚本路由",normalizedTitle:"脚本路由",charIndex:8260},{level:3,title:"服务路由的获取方式",slug:"服务路由的获取方式",normalizedTitle:"服务路由的获取方式",charIndex:10508},{level:3,title:"内部服务调用",slug:"内部服务调用",normalizedTitle:"内部服务调用",charIndex:10798},{level:3,title:"外部服务调用",slug:"外部服务调用",normalizedTitle:"外部服务调用",charIndex:10973},{level:2,title:"配置中心",slug:"配置中心",normalizedTitle:"配置中心",charIndex:10618},{level:3,title:"Apollo",slug:"apollo",normalizedTitle:"apollo",charIndex:11573},{level:3,title:"Spring Cloud Git",slug:"spring-cloud-git",normalizedTitle:"spring cloud git",charIndex:11662},{level:2,title:"链路追踪",slug:"链路追踪",normalizedTitle:"链路追踪",charIndex:11771},{level:3,title:"链路追踪的作用",slug:"链路追踪的作用",normalizedTitle:"链路追踪的作用",charIndex:11780},{level:3,title:"链路追踪的原理",slug:"链路追踪的原理",normalizedTitle:"链路追踪的原理",charIndex:11833},{level:3,title:"链路追踪的实现",slug:"链路追踪的实现",normalizedTitle:"链路追踪的实现",charIndex:12300},{level:4,title:"数据采集层",slug:"数据采集层",normalizedTitle:"数据采集层",charIndex:12331},{level:4,title:"数据处理层",slug:"数据处理层",normalizedTitle:"数据处理层",charIndex:12351},{level:4,title:"数据展示层",slug:"数据展示层",normalizedTitle:"数据展示层",charIndex:12372},{level:3,title:"链路追踪方案对比",slug:"链路追踪方案对比",normalizedTitle:"链路追踪方案对比",charIndex:13124},{level:2,title:"限流熔断",slug:"限流熔断",normalizedTitle:"限流熔断",charIndex:13139},{level:3,title:"限流",slug:"限流",normalizedTitle:"限流",charIndex:13139},{level:3,title:"降级",slug:"降级",normalizedTitle:"降级",charIndex:6580},{level:2,title:"DEVOPS",slug:"devops",normalizedTitle:"devops",charIndex:14551},{level:3,title:"容器和容器平台",slug:"容器和容器平台",normalizedTitle:"容器和容器平台",charIndex:14562},{level:2,title:"RPC 选型",slug:"rpc-选型",normalizedTitle:"rpc 选型",charIndex:14601},{level:3,title:"限定语言 RPC",slug:"限定语言-rpc",normalizedTitle:"限定语言 rpc",charIndex:14612},{level:3,title:"跨语言 RPC",slug:"跨语言-rpc",normalizedTitle:"跨语言 rpc",charIndex:15325},{level:2,title:"Service Mesh",slug:"service-mesh",normalizedTitle:"service mesh",charIndex:15951},{level:3,title:"Service Mesh 的实现原理",slug:"service-mesh-的实现原理",normalizedTitle:"service mesh 的实现原理",charIndex:15970},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:16157}],headersStr:"微服务简介 什么是微服务架构 如何权衡微服务的利弊 康威定律 如何拆分微服务 微服务技术架构 服务注册发现 注册中心的工作流程 注册中心实现模式 应用内注册和发现 应用外注册和发现 注册中心选型 高可用性 数据一致性 服务注册发现的问题 多注册中心 并行订阅服务 批量注销服务 服务变更信息同步更新 识别服务节点是否存活 心跳开关保护机制 服务节点摘除保护机制 服务通信 序列化方式 通信协议 服务监控 监控对象 系统监控原理 数据采集 数据传输 数据处理 数据展示 监控技术 服务治理 API 网关 Zuul 负载均衡 服务路由 服务路由的应用场景 服务路由的规则 条件路由 脚本路由 服务路由的获取方式 内部服务调用 外部服务调用 配置中心 Apollo Spring Cloud Git 链路追踪 链路追踪的作用 链路追踪的原理 链路追踪的实现 数据采集层 数据处理层 数据展示层 链路追踪方案对比 限流熔断 限流 降级 DEVOPS 容器和容器平台 RPC 选型 限定语言 RPC 跨语言 RPC Service Mesh Service Mesh 的实现原理 参考资料",content:'# 微服务基本原理\n\n\n# 微服务简介\n\n\n# 什么是微服务架构\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。\n\n微服务架构的特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n\n# 如何权衡微服务的利弊\n\n优点\n\n * 强模块化边界\n * 可独立部署\n * 技术多样性\n\n缺点\n\n * 分布式复杂度\n * 最终一致性\n * 运维复杂度\n * 测试复杂度\n\n\n# 康威定律\n\n * 第一定律：组织沟通方式会通过系统设计表达出来\n * 第二定律：时间再多一件事情也不可能做的完美，但总有时间做完一件事情\n * 第三定律：线型系统和线型组织架构间有潜在的异质同态特性\n * 第四定律：大的系统组织总是比小系统更倾向于分解\n\n\n# 如何拆分微服务\n\n应用微服务化架构前，要思考几个问题：\n\n什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n拆分服务的思考维度：\n\n * 业务维度：业务和数据关系密切的应该放在一起。\n * 功能维度：公共功能聚合为一个服务。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n拆分服务的前置条件：\n\n应用微服务架构要先解决以下问题：\n\n * 服务如何定\n * 服务如何发布和订阅\n * 服务如何监控\n * 服务如何治理\n * 故障如何定位\n\n\n# 微服务技术架构\n\n\n\n第一层：接入层\n\n外部设备访问的统一接入层。\n\n第二层：聚合服务层\n\n对下层的基础服务做一些聚合，剪裁的工作，适配上层不同设备的数据输出。\n\n第三层：基础服务层\n\n比较细粒度的微服务层，提供基础的核心服务，公共服务。\n\n\n\n\n# 服务注册发现\n\n在微服务架构下，主要有三种角色：\n\n * 服务提供者（RPC Server / Provider）\n * 服务消费者（RPC Client / Consumer）\n * 服务注册中心（Registry）\n\n注册中心的实现依赖以下机制：\n\n * 注册中心 API\n * 集群部署：如果注册中心是单点，无法保障高可用。\n * 元数据存储：例如 ZooKeeper 将数据以层次化的目录结构存储。\n * 服务健康检查：使用长连接或心跳探测方式检查服务健康状态。\n * 服务状态变更通知：可以基于订阅者模式实现，例如 ZooKeeper 的 Watch 机制。\n * 白名单机制\n\n注册中心的服务注册和发现都是基于 API 的。一般需要支持以下功能：\n\n * 服务注册\n * 服务注销\n * 接口续约（心跳）\n * 服务订阅\n * 可用服务同步\n * 服务查询\n * 服务修改\n\n\n# 注册中心的工作流程\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 注册中心实现模式\n\n# 应用内注册和发现\n\n采用应用内注册与发现的方式，最典型的案例要属 Netflix 开源的 Eureka，官方架构图如下。\n\n\n\n对着这张图，我来介绍下 Eureka 的架构，它主要由三个重要的组件组成：\n\n * Eureka Server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 Eureka Client：集成在服务端的注册中心 SDK，服务提供者通过调用 SDK，实现服务注册、反注册等功能。\n * 客户端的 Eureka Client：集成在客户端的注册中心 SDK，服务消费者通过调用 SDK，实现服务订阅、服务更新等功能。\n\n# 应用外注册和发现\n\n\n\n通过这张架构图，可以看出来使用 Consul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * Consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * Registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁。\n * Consul Template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息。\n\n# 注册中心选型\n\n# 高可用性\n\n集群部署，通过部署多个实例组成集群来保证高可用性。\n\n多 IDC 部署，即部署在不止一个机房。\n\n# 数据一致性\n\n根据 CAP 理论，三者不能同时满足：\n\n * CP 型注册中心，牺牲可用性来保证数据强一致性，最典型的例子就是 ZooKeeper，etcd，Consul 了。ZooKeeper 集群内只有一个 Leader，而且在 Leader 无法使用的时候通过 Paxos 算法选举出一个新的 Leader。这个 Leader 的目的就是保证写信息的时候只向这个 Leader 写入，Leader 会同步信息到 Followers，这个过程就可以保证数据的强一致性。但如果多个 ZooKeeper 之间网络出现问题，造成出现多个 Leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 Consul 集群内都是通过 raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。\n * AP 型注册中心，牺牲一致性来保证可用性，最典型的例子就是 Eureka 了。对比下 Zookeeper，Eureka 不用选举一个 Leader，每个 Eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。\n\n\n# 服务注册发现的问题\n\n# 多注册中心\n\n对于服务消费者来说，要能够同时从多个注册中心订阅服务；对于服务提供者来说，要能够同时向多个注册中心注册服务。\n\n# 并行订阅服务\n\n可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。\n\n# 批量注销服务\n\n需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。\n\n# 服务变更信息同步更新\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 识别服务节点是否存活\n\n# 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n所以针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。\n\n当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n# 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n\n# 服务通信\n\n通过注册中心，服务消费者和服务提供者就可以感知彼此，但是，要实现交互还必须解决通信问题：\n\n * 通信协议。即服务提供者和服务消费者之间以什么样的 协议 进行网络通信，说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？例如：Dubbo 基于 TCP 通信；而 Spring Cloud 基于 HTTP REST 通信。TCP 通信方式，传输效率更高；但是 HTTP 方式天然可以提供对外服务。\n * 传输方式。即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。\n * 序列化和反序列化。它主要解决客户端和服务端采用哪种数据编解码的问题。常见的序列化方式包括：XML、JSON；二进制类如：thrift、protobuf、hessian、JDK。\n\n\n# 序列化方式\n\n序列化方式的选型，一般基于以下考虑：\n\n * 支持数据结构类型的丰富度\n * 跨语言支持\n * 性能\n\n> 👉 参考：Java 序列化\n\n\n# 通信协议\n\n微服务框架对比：\n\n       RPC                                       REST\n耦合性    强耦合                                       松散耦合\n协议     Tcp                                       Http、Http2\n序列化    二进制（Thrift、Protobuf、Hessian、Avro、JDK 等）   Xml、Json\n性能     高                                         低\n客户端    对编程语言有限制                                  跨语言支持更好（支持 Http 即可）\n代表技术   Dubbo、Motan、Tars、gRpc、Thrift              Spring Cloud\n\n\n# 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：访问接口、访问服务、SQL、内存使用率、响应时间、TPS、QPS 等。\n * 系统监控：CPU、内存、网络、磁盘等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n# 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：Zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：ELK、Flume。\n\n# 数据传输\n\n数据传输最常用的方式有两种：\n\n * UDP 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 UDP 协议与服务器建立连接，然后把数据发送过去。\n * Kafka 传输：这种处理方式是数据采集后发送到指定的 Topic，然后数据处理单元再订阅对应的 Topic，就可以从 Kafka 消息队列中读取到对应的数据。由于 Kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n# 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n# 数据展示\n\n数据展示是把处理后的数据以 Dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 监控技术\n\n\n\n * ELK 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * Graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 API 也可以接入其他图形化监控系统如 Grafana。\n * TICK 的核心在于其时间序列数据库 InfluxDB 的存储功能强大，且支持类似 SQL 语言的复杂数据处理操作。\n * Prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 PromQL 查询语言，功能强大而且简洁。\n\n\n# 服务治理\n\n微服务治理平台就是与服务打交道的统一入口，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。\n\n微服务治理平台关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 API，而且还提供了可视化的界面，以方便开发人员和运维人员操作。\n\n\n\n服务治理的常用手段有：\n\n * 节点管理\n   * 注册中心主动摘除机制\n   * 服务消费者摘除机制\n * 负载均衡\n   * 轮询\n   * 随机\n   * 最近最少连接\n   * 一致性 Hash\n * 服务路由\n   * 业务存在灰度发布的需求\n   * 多机房就近访问的需求\n * 服务容错\n   * FailOver：失败自动切换\n   * FailBack：失败通知\n   * FailCache：失败缓存\n   * FailFast：快速失败\n\n\n# API 网关\n\nAPI 网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API 网关封装了系统内部架构，为每个客户端提供一个定制的 API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。 API 网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供 REST/HTTP 的访问 API。服务端通过 API-GW 注册和管理服务。\n\n\n# Zuul\n\n\n\n在 zuul 中， 整个请求的过程是这样的，首先将请求给 zuulservlet 处理，zuulservlet 中有一个 zuulRunner 对象，该对象中初始化了 RequestContext：作为存储整个请求的一些数据，并被所有的 zuulfilter 共享。zuulRunner 中还有 FilterProcessor，FilterProcessor 作为执行所有的 zuulfilter 的管理器。FilterProcessor 从 filterloader 中获取 zuulfilter，而 zuulfilter 是被 filterFileManager 所加载，并支持 groovy 热加载，采用了轮询的方式热加载。有了这些 filter 之后，zuulservelet 首先执行的 Pre 类型的过滤器，再执行 route 类型的过滤器，最后执行的是 post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行 error 类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。\n\n\n# 负载均衡\n\n> 参考：负载均衡基本原理\n\n\n# 服务路由\n\n服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求。\n\n\n# 服务路由的应用场景\n\n * 分组调用。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 灰度发布。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。\n * 流量切换。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n# 条件路由\n\n条件路由是基于条件表达式的路由规则。\n\ncondition://0.0.0.0/dubbo.test.interfaces.TestService?category=routers&dynamic=true&priority=2&enabled=true&rule=" + URL.encode(" host = 10.20.153.10=> host = 10.20.153.11")\n\n\n这里面 condition:// 代表了这是一段用条件表达式编写的路由规则，具体的规则是\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n分隔符“=>”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 IP 为“10.20.153.10”的服务消费者都调用 IP 为“10.20.153.11”的服务提供者节点。\n\n如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。\n\n=> host ！= 10.20.153.11\n\n\n如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10=>\n\n\n下面我举一些 Dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 IP 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。\n\n * 白名单和黑名单功能\n\nhost != 10.20.153.10,10.20.153.11 =>\n\n\n这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。\n\nhost = 10.20.153.10,10.20.153.11 =>\n\n\n同理，这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。\n\n * 机房隔离\n\nhost = 172.22.3.* => host = 172.22.3.*\n\n\n这条路由规则意思是 IP 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 IDC，理论上同一个 IDC 内的调用性能要比跨 IDC 调用性能要好，应用这个规则是为了实现同 IDC 就近访问。\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host =172.22.3.94,172.22.3.95\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n这条路由规则意思是 find*、get*、is* 等读方法调用 IP 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 IP 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。\n\n# 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。\n\n"script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面“script://”就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.ArrayList(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).getUrl().getHost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 服务路由的获取方式\n\n服务路由的获取方式主要有三种：\n\n * 本地配置\n\n顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n\n * 配置中心管理\n\n这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n\n * 动态下发\n\n这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n\n# 内部服务调用\n\n基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign 聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign\n\n\n\n\n# 外部服务调用\n\n基于 Netflix 的 zuul，做了简单了解，SpringCloud 与 zuul 集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。\n\nSpring Cloud 很好的集成了 zuul，并且可以通过注解的形式来进行请求的反向路由以及 API 网关功能 Spring Cloud 集成 zuul，对与 url 映射的处理方式与 SpringMVC 对 url 的请求方式类似，都是通过 RequestMapping 来进行请求绑定的。核心类：ZuulHandlerMapping zuul 的核心是 ZuulServlet，一个请求核心流程：HttpServletRequest –>ZuulHandlerMapping –>ZuulController –> ZuulServlet –> ZuulFilter –> HttpServletResponse\n\n\n# 配置中心\n\n配置中心的思路就是把服务的各种配置，如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。服务启动时，可以自动从配置中心中拉取所需的配置，并且如果有配置变更的情况，同样可以自动从配置中心拉取最新的配置信息，服务无须重新发布。\n\n配置中心一般包含下面几个功能：\n\n * 配置注册功能\n * 配置反注册功能\n * 配置查看功能\n * 配置变更订阅功能\n\n\n# Apollo\n\n携程开源的分布式配置中心，支持 Java 和.Net 语言，客户端和配置中心通过 HTTP 长连接实现实时推送，并且有统一的管理界面来实现配置管理。\n\n\n\n\n# Spring Cloud Git\n\nSpring Cloud 中使用的配置中心组件，只支持 Java 语言，配置存储在 git 中，变更配置也需要通过 git 操作，如果配置中心有配置变更，需要手动刷新。\n\n\n\n\n# 链路追踪\n\n\n# 链路追踪的作用\n\n * 优化系统瓶颈\n * 优化链路调用\n * 生成网络拓扑\n * 透明传输数据\n\n\n# 链路追踪的原理\n\n理解链路追踪必须先了解以下概念：\n\n * traceId，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。\n * spanId，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。\n\n\n\n\n# 链路追踪的实现\n\n一个服务追踪系统一般可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n# 数据采集层\n\n一次 RPC 请求可以分为四个阶段。\n\n * CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。\n * SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。\n * SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38。\n * CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38。\n\n# 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n * 实时数据处理\n\n针对实时数据处理，一般采用 Storm 或者 Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理\n\n针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。\n\n# 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n\n# 链路追踪方案对比\n\n\n\n\n# 限流熔断\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n一种是代码 bug 所导致，比如说某一段 Java 代码不断地分配大对象，但没有及时回收导致 JVM OOM 退出；\n\n另一种是突发的流量冲击，超出了系统的最大承载能力，比如“双 11”这种购物活动，电商系统会在零点一瞬间涌入大量流量，超出系统的最大承载能力，一下子就把整个系统给压垮了。\n\n应付集群故障的思路，主要有两种：限流和降级。\n\n\n# 限流\n\n限流就是限制流量。通常情况下，系统能够承载的流量根据集群规模的大小是固定的，可以称之为系统的最大容量。当真实流量超过了系统的最大容量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。所以，应该根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会被自动抛弃，这样的话可以最大限度地保证系统提供的服务正常。\n\n除此之外，通常一个微服务系统会同时提供多个服务，每个服务在同一时刻的请求量也是不同的，很可能出现的一种情况就是，系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。因此，还要针对系统中每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动抛弃，这样的话不至于因为一个服务影响了其他所有服务。\n\n在实际项目中，可以用两个指标来衡量服务的请求量，一个是 QPS 即每秒请求量，一个是工作线程数。不过 QPS 因为不同服务的响应快慢不同，所以系统能够承载的 QPS 相差很大，因此一般选择工作线程数来作为限流的指标，给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话无论是系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是某个服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。\n\n\n# 降级\n\n什么是降级呢？在我看来，降级就是通过停止系统中的某些功能，来保证系统整体的可用性。降级可以说是一种被动防御的措施，为什么这么说呢？因为它一般是系统已经出现故障后所采取的一种止损措施。\n\n那么降级一般是如何实现的呢？根据我的实践来看， 一种可行的方案是通过开关来实现。\n\n具体来讲，就是在系统运行的内存中开辟一块区域，专门用于存储开关的状态，也就是开启还是关闭。并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。当开关开启时，业务的某一段逻辑就不再执行，而正常情况下，开关是关闭的状态。\n\n开关一般用在两种地方，一种是新增的业务逻辑，因为新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行；另一种是依赖的服务或资源，因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响。\n\n在实际业务应用的时候，降级要按照对业务的影响程度进行分级，一般分为三级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预；二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级；三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。\n\n\n# DEVOPS\n\n\n# 容器和容器平台\n\nMesos、Marathon、Kubernetes\n\n\n# RPC 选型\n\n\n# 限定语言 RPC\n\n跟语言平台绑定的开源 RPC 框架主要有下面几种。\n\n * Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。\n * Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n * Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。\n * Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言，最近几年生态发展得比较好，是比较火的 RPC 框架。\n\n所以很明显，如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 RPC 框架中的一种；如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 RPC 框架。\n\n仔细分析，可以看出 Spring Cloud 不仅提供了基本的 RPC 框架功能，还提供了服务注册组件、配置中心组件、负载均衡组件、断路器组件、分布式消息追踪组件等一系列组件，也难怪被技术圈的人称之为“Spring Cloud 全家桶”。如果你不想自己实现以上这些功能，那么 Spring Cloud 基本可以满足你的全部需求。而 Dubbo、Motan 基本上只提供了最基础的 RPC 框架的功能，其他微服务组件都需要自己去实现。不过由于 Spring Cloud 的 RPC 通信采用了 HTTP 协议，相比 Dubbo 和 Motan 所采用的私有协议来说，在高并发的通信场景下，性能相对要差一些，所以对性能有苛刻要求的情况下，可以考虑 Dubbo 和 Motan。\n\n\n# 跨语言 RPC\n\n而跨语言平台的开源 RPC 框架主要有以下几种。\n\n * gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持常用的 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言。\n * Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持常用的 C++、Java、PHP、Python、Ruby、Erlang 等多种语言。\n\n从成熟度上来讲，Thrift 因为诞生的时间要早于 gRPC，所以使用的范围要高于 gRPC，在 HBase、Hadoop、Scribe、Cassandra 等许多开源组件中都得到了广泛地应用。而且 Thrift 支持多达 25 种语言，这要比 gRPC 支持的语言更多，所以如果遇到 gRPC 不支持的语言场景下，选择 Thrift 更合适。\n\n但 gRPC 作为后起之秀，因为采用了 HTTP/2 作为通信协议、ProtoBuf 作为数据序列化格式，在移动端设备的应用以及对传输带宽比较敏感的场景下具有很大的优势，而且开发文档丰富，根据 ProtoBuf 文件生成的代码要比 Thrift 更简洁一些，从使用难易程度上更占优势，所以如果使用的语言平台 gRPC 支持的话，建议还是采用 gRPC 比较好。\n\n\n# Service Mesh\n\n\n\n\n# Service Mesh 的实现原理\n\nService Mesh 实现的关键就在于两点：\n\n一个是上面提到的轻量级的网络代理也叫 SideCar，它的作用就是转发服务之间的调用；\n\n一个是基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲\n * 谈谈微服务中的 API 网关（API Gateway）',normalizedContent:'# 微服务基本原理\n\n\n# 微服务简介\n\n\n# 什么是微服务架构\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。\n\n微服务架构的特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n\n# 如何权衡微服务的利弊\n\n优点\n\n * 强模块化边界\n * 可独立部署\n * 技术多样性\n\n缺点\n\n * 分布式复杂度\n * 最终一致性\n * 运维复杂度\n * 测试复杂度\n\n\n# 康威定律\n\n * 第一定律：组织沟通方式会通过系统设计表达出来\n * 第二定律：时间再多一件事情也不可能做的完美，但总有时间做完一件事情\n * 第三定律：线型系统和线型组织架构间有潜在的异质同态特性\n * 第四定律：大的系统组织总是比小系统更倾向于分解\n\n\n# 如何拆分微服务\n\n应用微服务化架构前，要思考几个问题：\n\n什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n拆分服务的思考维度：\n\n * 业务维度：业务和数据关系密切的应该放在一起。\n * 功能维度：公共功能聚合为一个服务。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n拆分服务的前置条件：\n\n应用微服务架构要先解决以下问题：\n\n * 服务如何定\n * 服务如何发布和订阅\n * 服务如何监控\n * 服务如何治理\n * 故障如何定位\n\n\n# 微服务技术架构\n\n\n\n第一层：接入层\n\n外部设备访问的统一接入层。\n\n第二层：聚合服务层\n\n对下层的基础服务做一些聚合，剪裁的工作，适配上层不同设备的数据输出。\n\n第三层：基础服务层\n\n比较细粒度的微服务层，提供基础的核心服务，公共服务。\n\n\n\n\n# 服务注册发现\n\n在微服务架构下，主要有三种角色：\n\n * 服务提供者（rpc server / provider）\n * 服务消费者（rpc client / consumer）\n * 服务注册中心（registry）\n\n注册中心的实现依赖以下机制：\n\n * 注册中心 api\n * 集群部署：如果注册中心是单点，无法保障高可用。\n * 元数据存储：例如 zookeeper 将数据以层次化的目录结构存储。\n * 服务健康检查：使用长连接或心跳探测方式检查服务健康状态。\n * 服务状态变更通知：可以基于订阅者模式实现，例如 zookeeper 的 watch 机制。\n * 白名单机制\n\n注册中心的服务注册和发现都是基于 api 的。一般需要支持以下功能：\n\n * 服务注册\n * 服务注销\n * 接口续约（心跳）\n * 服务订阅\n * 可用服务同步\n * 服务查询\n * 服务修改\n\n\n# 注册中心的工作流程\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 注册中心实现模式\n\n# 应用内注册和发现\n\n采用应用内注册与发现的方式，最典型的案例要属 netflix 开源的 eureka，官方架构图如下。\n\n\n\n对着这张图，我来介绍下 eureka 的架构，它主要由三个重要的组件组成：\n\n * eureka server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 eureka client：集成在服务端的注册中心 sdk，服务提供者通过调用 sdk，实现服务注册、反注册等功能。\n * 客户端的 eureka client：集成在客户端的注册中心 sdk，服务消费者通过调用 sdk，实现服务订阅、服务更新等功能。\n\n# 应用外注册和发现\n\n\n\n通过这张架构图，可以看出来使用 consul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 docker 实例是否存活，来负责服务提供者的注册和销毁。\n * consul template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 lb 配置（比如 nginx 的 upstream），这样服务消费者就通过访问 nginx 就可以获取最新的服务提供者信息。\n\n# 注册中心选型\n\n# 高可用性\n\n集群部署，通过部署多个实例组成集群来保证高可用性。\n\n多 idc 部署，即部署在不止一个机房。\n\n# 数据一致性\n\n根据 cap 理论，三者不能同时满足：\n\n * cp 型注册中心，牺牲可用性来保证数据强一致性，最典型的例子就是 zookeeper，etcd，consul 了。zookeeper 集群内只有一个 leader，而且在 leader 无法使用的时候通过 paxos 算法选举出一个新的 leader。这个 leader 的目的就是保证写信息的时候只向这个 leader 写入，leader 会同步信息到 followers，这个过程就可以保证数据的强一致性。但如果多个 zookeeper 之间网络出现问题，造成出现多个 leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 consul 集群内都是通过 raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。\n * ap 型注册中心，牺牲一致性来保证可用性，最典型的例子就是 eureka 了。对比下 zookeeper，eureka 不用选举一个 leader，每个 eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。\n\n\n# 服务注册发现的问题\n\n# 多注册中心\n\n对于服务消费者来说，要能够同时从多个注册中心订阅服务；对于服务提供者来说，要能够同时向多个注册中心注册服务。\n\n# 并行订阅服务\n\n可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。\n\n# 批量注销服务\n\n需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。\n\n# 服务变更信息同步更新\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 识别服务节点是否存活\n\n# 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n所以针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。\n\n当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n# 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n\n# 服务通信\n\n通过注册中心，服务消费者和服务提供者就可以感知彼此，但是，要实现交互还必须解决通信问题：\n\n * 通信协议。即服务提供者和服务消费者之间以什么样的 协议 进行网络通信，说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 tcp、udp 协议，还是采用七层 http 协议，还是采用其他协议？例如：dubbo 基于 tcp 通信；而 spring cloud 基于 http rest 通信。tcp 通信方式，传输效率更高；但是 http 方式天然可以提供对外服务。\n * 传输方式。即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。\n * 序列化和反序列化。它主要解决客户端和服务端采用哪种数据编解码的问题。常见的序列化方式包括：xml、json；二进制类如：thrift、protobuf、hessian、jdk。\n\n\n# 序列化方式\n\n序列化方式的选型，一般基于以下考虑：\n\n * 支持数据结构类型的丰富度\n * 跨语言支持\n * 性能\n\n> 👉 参考：java 序列化\n\n\n# 通信协议\n\n微服务框架对比：\n\n       rpc                                       rest\n耦合性    强耦合                                       松散耦合\n协议     tcp                                       http、http2\n序列化    二进制（thrift、protobuf、hessian、avro、jdk 等）   xml、json\n性能     高                                         低\n客户端    对编程语言有限制                                  跨语言支持更好（支持 http 即可）\n代表技术   dubbo、motan、tars、grpc、thrift              spring cloud\n\n\n# 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：访问接口、访问服务、sql、内存使用率、响应时间、tps、qps 等。\n * 系统监控：cpu、内存、网络、磁盘等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n# 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：elk、flume。\n\n# 数据传输\n\n数据传输最常用的方式有两种：\n\n * udp 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 udp 协议与服务器建立连接，然后把数据发送过去。\n * kafka 传输：这种处理方式是数据采集后发送到指定的 topic，然后数据处理单元再订阅对应的 topic，就可以从 kafka 消息队列中读取到对应的数据。由于 kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n# 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 opentsdb，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n# 数据展示\n\n数据展示是把处理后的数据以 dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 监控技术\n\n\n\n * elk 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 api 也可以接入其他图形化监控系统如 grafana。\n * tick 的核心在于其时间序列数据库 influxdb 的存储功能强大，且支持类似 sql 语言的复杂数据处理操作。\n * prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 promql 查询语言，功能强大而且简洁。\n\n\n# 服务治理\n\n微服务治理平台就是与服务打交道的统一入口，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。\n\n微服务治理平台关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 api，而且还提供了可视化的界面，以方便开发人员和运维人员操作。\n\n\n\n服务治理的常用手段有：\n\n * 节点管理\n   * 注册中心主动摘除机制\n   * 服务消费者摘除机制\n * 负载均衡\n   * 轮询\n   * 随机\n   * 最近最少连接\n   * 一致性 hash\n * 服务路由\n   * 业务存在灰度发布的需求\n   * 多机房就近访问的需求\n * 服务容错\n   * failover：失败自动切换\n   * failback：失败通知\n   * failcache：失败缓存\n   * failfast：快速失败\n\n\n# api 网关\n\napi 网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。api 网关封装了系统内部架构，为每个客户端提供一个定制的 api。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。 api 网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供 rest/http 的访问 api。服务端通过 api-gw 注册和管理服务。\n\n\n# zuul\n\n\n\n在 zuul 中， 整个请求的过程是这样的，首先将请求给 zuulservlet 处理，zuulservlet 中有一个 zuulrunner 对象，该对象中初始化了 requestcontext：作为存储整个请求的一些数据，并被所有的 zuulfilter 共享。zuulrunner 中还有 filterprocessor，filterprocessor 作为执行所有的 zuulfilter 的管理器。filterprocessor 从 filterloader 中获取 zuulfilter，而 zuulfilter 是被 filterfilemanager 所加载，并支持 groovy 热加载，采用了轮询的方式热加载。有了这些 filter 之后，zuulservelet 首先执行的 pre 类型的过滤器，再执行 route 类型的过滤器，最后执行的是 post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行 error 类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。\n\n\n# 负载均衡\n\n> 参考：负载均衡基本原理\n\n\n# 服务路由\n\n服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求。\n\n\n# 服务路由的应用场景\n\n * 分组调用。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 灰度发布。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。\n * 流量切换。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n# 条件路由\n\n条件路由是基于条件表达式的路由规则。\n\ncondition://0.0.0.0/dubbo.test.interfaces.testservice?category=routers&dynamic=true&priority=2&enabled=true&rule=" + url.encode(" host = 10.20.153.10=> host = 10.20.153.11")\n\n\n这里面 condition:// 代表了这是一段用条件表达式编写的路由规则，具体的规则是\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n分隔符“=>”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 ip 为“10.20.153.10”的服务消费者都调用 ip 为“10.20.153.11”的服务提供者节点。\n\n如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。\n\n=> host ！= 10.20.153.11\n\n\n如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10=>\n\n\n下面我举一些 dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 ip 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。\n\n * 白名单和黑名单功能\n\nhost != 10.20.153.10,10.20.153.11 =>\n\n\n这条路由规则意思是除了 ip 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。\n\nhost = 10.20.153.10,10.20.153.11 =>\n\n\n同理，这条路由规则意思是除了 ip 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。\n\n * 机房隔离\n\nhost = 172.22.3.* => host = 172.22.3.*\n\n\n这条路由规则意思是 ip 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 idc，理论上同一个 idc 内的调用性能要比跨 idc 调用性能要好，应用这个规则是为了实现同 idc 就近访问。\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host =172.22.3.94,172.22.3.95\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n这条路由规则意思是 find*、get*、is* 等读方法调用 ip 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 ip 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。\n\n# 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 javascript、groovy、jruby 等。\n\n"script://0.0.0.0/com.foo.barservice?category=routers&dynamic=false&rule=" + url.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面“script://”就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 javascript 编写的 route() 方法表达的意思是，只有 ip 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.arraylist(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).geturl().gethost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 服务路由的获取方式\n\n服务路由的获取方式主要有三种：\n\n * 本地配置\n\n顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n\n * 配置中心管理\n\n这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n\n * 动态下发\n\n这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n\n# 内部服务调用\n\n基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 eureka+（resttemplate+ribbon）或者 eureka+feign 聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 eureka+（resttemplate+ribbon）或者 eureka+feign\n\n\n\n\n# 外部服务调用\n\n基于 netflix 的 zuul，做了简单了解，springcloud 与 zuul 集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。\n\nspring cloud 很好的集成了 zuul，并且可以通过注解的形式来进行请求的反向路由以及 api 网关功能 spring cloud 集成 zuul，对与 url 映射的处理方式与 springmvc 对 url 的请求方式类似，都是通过 requestmapping 来进行请求绑定的。核心类：zuulhandlermapping zuul 的核心是 zuulservlet，一个请求核心流程：httpservletrequest –>zuulhandlermapping –>zuulcontroller –> zuulservlet –> zuulfilter –> httpservletresponse\n\n\n# 配置中心\n\n配置中心的思路就是把服务的各种配置，如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。服务启动时，可以自动从配置中心中拉取所需的配置，并且如果有配置变更的情况，同样可以自动从配置中心拉取最新的配置信息，服务无须重新发布。\n\n配置中心一般包含下面几个功能：\n\n * 配置注册功能\n * 配置反注册功能\n * 配置查看功能\n * 配置变更订阅功能\n\n\n# apollo\n\n携程开源的分布式配置中心，支持 java 和.net 语言，客户端和配置中心通过 http 长连接实现实时推送，并且有统一的管理界面来实现配置管理。\n\n\n\n\n# spring cloud git\n\nspring cloud 中使用的配置中心组件，只支持 java 语言，配置存储在 git 中，变更配置也需要通过 git 操作，如果配置中心有配置变更，需要手动刷新。\n\n\n\n\n# 链路追踪\n\n\n# 链路追踪的作用\n\n * 优化系统瓶颈\n * 优化链路调用\n * 生成网络拓扑\n * 透明传输数据\n\n\n# 链路追踪的原理\n\n理解链路追踪必须先了解以下概念：\n\n * traceid，用于标识某一次具体的请求 id。当用户的请求进入系统后，会在 rpc 调用网络的第一层生成一个全局唯一的 traceid，并且会随着每一层的 rpc 调用，不断往后传递，这样的话通过 traceid 就可以把一次用户请求在系统中调用的路径串联起来。\n * spanid，用于标识一次 rpc 调用在分布式请求中的位置。当用户的请求进入系统后，处在 rpc 调用网络的第一层 a 时 spanid 初始值是 0，进入下一层 rpc 调用 b 的时候 spanid 是 0.1，继续进入下一层 rpc 调用 c 时 spanid 是 0.1.1，而与 b 处在同一层的 rpc 调用 e 的 spanid 是 0.2，这样的话通过 spanid 就可以定位某一次 rpc 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 uid。\n\n\n\n\n# 链路追踪的实现\n\n一个服务追踪系统一般可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n# 数据采集层\n\n一次 rpc 请求可以分为四个阶段。\n\n * cs（client send）阶段 : 客户端发起请求，并生成调用的上下文。\n * sr（server recieve）阶段 : 服务端接收请求，并生成上下文。\n * ss（server send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceid=123456，spanid=0.1，appkey=b，method=b.method，start=103，duration=38。\n * cr（client recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanid=0.1，appkey=a，method=b.method，start=103，duration=38。\n\n# 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n * 实时数据处理\n\n针对实时数据处理，一般采用 storm 或者 spark streaming 来对链路数据进行实时聚合加工，存储一般使用 oltp 数据仓库，比如 hbase，使用 traceid 作为 rowkey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理\n\n针对离线数据处理，一般通过运行 mapreduce 或者 spark 批处理程序来对链路数据进行离线计算，存储一般使用 hive。\n\n# 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n\n# 链路追踪方案对比\n\n\n\n\n# 限流熔断\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n一种是代码 bug 所导致，比如说某一段 java 代码不断地分配大对象，但没有及时回收导致 jvm oom 退出；\n\n另一种是突发的流量冲击，超出了系统的最大承载能力，比如“双 11”这种购物活动，电商系统会在零点一瞬间涌入大量流量，超出系统的最大承载能力，一下子就把整个系统给压垮了。\n\n应付集群故障的思路，主要有两种：限流和降级。\n\n\n# 限流\n\n限流就是限制流量。通常情况下，系统能够承载的流量根据集群规模的大小是固定的，可以称之为系统的最大容量。当真实流量超过了系统的最大容量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。所以，应该根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会被自动抛弃，这样的话可以最大限度地保证系统提供的服务正常。\n\n除此之外，通常一个微服务系统会同时提供多个服务，每个服务在同一时刻的请求量也是不同的，很可能出现的一种情况就是，系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。因此，还要针对系统中每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动抛弃，这样的话不至于因为一个服务影响了其他所有服务。\n\n在实际项目中，可以用两个指标来衡量服务的请求量，一个是 qps 即每秒请求量，一个是工作线程数。不过 qps 因为不同服务的响应快慢不同，所以系统能够承载的 qps 相差很大，因此一般选择工作线程数来作为限流的指标，给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话无论是系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是某个服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。\n\n\n# 降级\n\n什么是降级呢？在我看来，降级就是通过停止系统中的某些功能，来保证系统整体的可用性。降级可以说是一种被动防御的措施，为什么这么说呢？因为它一般是系统已经出现故障后所采取的一种止损措施。\n\n那么降级一般是如何实现的呢？根据我的实践来看， 一种可行的方案是通过开关来实现。\n\n具体来讲，就是在系统运行的内存中开辟一块区域，专门用于存储开关的状态，也就是开启还是关闭。并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。当开关开启时，业务的某一段逻辑就不再执行，而正常情况下，开关是关闭的状态。\n\n开关一般用在两种地方，一种是新增的业务逻辑，因为新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行；另一种是依赖的服务或资源，因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响。\n\n在实际业务应用的时候，降级要按照对业务的影响程度进行分级，一般分为三级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预；二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级；三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。\n\n\n# devops\n\n\n# 容器和容器平台\n\nmesos、marathon、kubernetes\n\n\n# rpc 选型\n\n\n# 限定语言 rpc\n\n跟语言平台绑定的开源 rpc 框架主要有下面几种。\n\n * dubbo：国内最早开源的 rpc 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 java 语言。\n * motan：微博内部使用的 rpc 框架，于 2016 年对外开源，仅支持 java 语言。\n * tars：腾讯内部使用的 rpc 框架，于 2017 年对外开源，仅支持 c++ 语言。\n * spring cloud：国外 pivotal 公司 2014 年对外开源的 rpc 框架，仅支持 java 语言，最近几年生态发展得比较好，是比较火的 rpc 框架。\n\n所以很明显，如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 rpc 框架中的一种；如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 rpc 框架。\n\n仔细分析，可以看出 spring cloud 不仅提供了基本的 rpc 框架功能，还提供了服务注册组件、配置中心组件、负载均衡组件、断路器组件、分布式消息追踪组件等一系列组件，也难怪被技术圈的人称之为“spring cloud 全家桶”。如果你不想自己实现以上这些功能，那么 spring cloud 基本可以满足你的全部需求。而 dubbo、motan 基本上只提供了最基础的 rpc 框架的功能，其他微服务组件都需要自己去实现。不过由于 spring cloud 的 rpc 通信采用了 http 协议，相比 dubbo 和 motan 所采用的私有协议来说，在高并发的通信场景下，性能相对要差一些，所以对性能有苛刻要求的情况下，可以考虑 dubbo 和 motan。\n\n\n# 跨语言 rpc\n\n而跨语言平台的开源 rpc 框架主要有以下几种。\n\n * grpc：google 于 2015 年对外开源的跨语言 rpc 框架，支持常用的 c++、java、python、go、ruby、php、android java、objective-c 等多种语言。\n * thrift：最初是由 facebook 开发的内部系统跨语言的 rpc 框架，2007 年贡献给了 apache 基金，成为 apache 开源项目之一，支持常用的 c++、java、php、python、ruby、erlang 等多种语言。\n\n从成熟度上来讲，thrift 因为诞生的时间要早于 grpc，所以使用的范围要高于 grpc，在 hbase、hadoop、scribe、cassandra 等许多开源组件中都得到了广泛地应用。而且 thrift 支持多达 25 种语言，这要比 grpc 支持的语言更多，所以如果遇到 grpc 不支持的语言场景下，选择 thrift 更合适。\n\n但 grpc 作为后起之秀，因为采用了 http/2 作为通信协议、protobuf 作为数据序列化格式，在移动端设备的应用以及对传输带宽比较敏感的场景下具有很大的优势，而且开发文档丰富，根据 protobuf 文件生成的代码要比 thrift 更简洁一些，从使用难易程度上更占优势，所以如果使用的语言平台 grpc 支持的话，建议还是采用 grpc 比较好。\n\n\n# service mesh\n\n\n\n\n# service mesh 的实现原理\n\nservice mesh 实现的关键就在于两点：\n\n一个是上面提到的轻量级的网络代理也叫 sidecar，它的作用就是转发服务之间的调用；\n\n一个是基于 sidecar 的服务治理也被叫作 control plane，它的作用是向 sidecar 发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲\n * 谈谈微服务中的 api 网关（api gateway）',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"微服务",frontmatter:{title:"微服务",date:"2021-06-02T11:22:02.000Z",categories:["设计","架构","微服务"],tags:["设计","架构","微服务"],permalink:"/pages/559360/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/",relativePath:"03.设计/01.架构/01.微服务/README.md",key:"v-717c7df2",path:"/pages/559360/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:10},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:116},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:419}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 微服务\n\n\n# 📖 内容\n\n * 微服务简介 - 关键词：微服务\n * 微服务基本原理 - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 大型网站系统与 Java 中间件实践\n   * 亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统\n   * 企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n\n\n# 🚪 传送\n\n◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 微服务\n\n\n# 📖 内容\n\n * 微服务简介 - 关键词：微服务\n * 微服务基本原理 - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 大型网站系统与 java 中间件实践\n   * 亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统\n   * 企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n\n\n# 🚪 传送\n\n◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"认证和授权",frontmatter:{title:"认证和授权",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","安全"],tags:["架构","安全","认证","授权"],permalink:"/pages/7ac4c5/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/02.%E5%AE%89%E5%85%A8/01.%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83.html",relativePath:"03.设计/01.架构/02.安全/01.认证和授权.md",key:"v-0d3720dc",path:"/pages/7ac4c5/",headers:[{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:46},{level:3,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:2},{level:3,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:5},{level:3,title:"鉴权",slug:"鉴权",normalizedTitle:"鉴权",charIndex:1107},{level:3,title:"权限控制",slug:"权限控制",normalizedTitle:"权限控制",charIndex:1534},{level:3,title:"认证、授权、鉴权和权限控制的关系",slug:"认证、授权、鉴权和权限控制的关系",normalizedTitle:"认证、授权、鉴权和权限控制的关系",charIndex:2139},{level:2,title:"JWT",slug:"jwt",normalizedTitle:"jwt",charIndex:38},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2623}],headersStr:"基本概念 认证 授权 鉴权 权限控制 认证、授权、鉴权和权限控制的关系 JWT 参考资料",content:"# 认证和授权\n\n> 关键词：SSO、Oauth 2.0、CAS、RABC、JWT\n\n\n# 基本概念\n\n\n# 认证\n\n认证是指根据声明者所特有的识别信息，确认声明者的身份。认证在英文中对应于 identification 这个单词。\n\n最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术：\n\n * 身份证\n * 用户名和密码认证\n * 用户手机认证：手机短信、手机二维码扫描、手势密码\n * 用户邮箱认证\n * 基于时间序列和用户相关的一次性口令\n * 用户的生物学特征认证：指纹、语音、眼睛虹膜\n * 用户的大数据识别认证\n * 等等\n\n为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。\n\n\n# 授权\n\n简单来说，授权一般是指获取用户的委派权限。在英文中对应于 authorization 这个单词。\n\n在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念，\n\n * 资源所有者：拥有资源的所有权利，一般就是资源的拥有者。\n * 资源执行者：被委派去执行资源的相关操作。\n * 操作权限：可以对资源进行的某种操作。\n * 资源：有价值的信息或数据等，受到安全保护。\n\n需要说明的是，资源所有者和执行者可以是自然人，就是普通用户，但不限于自然人。在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器。比如用户在浏览器上登录一个网站，那么这个浏览器就成为一个执行者，它在用户登录后获取了用户的授权，代表着用户执行各种指令，进行购物、下单、付钱、转账等等操作。\n\n同时，资源所有者和执行者可以是分开的不同实体，也可以是同一个。若是分开的两者，则资源执行者是以资源所有者的代理形式而存在。\n\n授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。\n\n在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，\n\n * 通过 web 服务器的 session 机制，一个访问会话保持着用户的授权信息\n * 通过 web 浏览器的 cookie 机制，一个网站的 cookie 保持着用户的授权信息\n * 颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息\n\n前面两者常见于 web 开发，需要有浏览器的支持。\n\n\n# 鉴权\n\n鉴权是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在英文中对应于 authentication 这个单词。\n\n鉴权主要是对声明者所声明的真实性进行校验。若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。\n\n因此，鉴权的实现方式是和授权方式有一一对应关系。对授权所颁发授信媒介进行解析，确认其真实性。下面是鉴权的一些实现方式，\n\n * 门禁卡：通过门禁卡识别器\n * 钥匙：通过相匹配的锁\n * 银行卡：通过银行卡识别器\n * 互联网 web 开发领域的 session/cookie/token：校验 session/cookie/token 的合法性和有效性\n\n鉴权是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。\n\n\n# 权限控制\n\n权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。权限控制在英文中对应于 access/permission control。\n\n对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。\n\n先看权限（Permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。\n\n若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为，\n\n * 这是一个门禁卡，拥有开公司所有的门的权限\n * 这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门\n\n可以看到，权限作为一个抽象的概念，将执行者和可具体执行的操作相分离。\n\n在上文的讨论中，鉴权的输出是权限（Permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。\n\n对于控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行。现实生活中控制的实现方式，多种多样，\n\n * 门禁：控制门的开关\n * 自行车锁：控制车轮\n * 互联网 web 后端服务：控制接口访问，允许或拒绝访问请求\n\n\n# 认证、授权、鉴权和权限控制的关系\n\n认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系，\n\n认证--\x3e授权--\x3e鉴权--\x3e权限控制\n\n需要说明的是，这四个环节在有些时候会同时发生。 例如在下面的几个场景，\n\n * 使用门禁卡开门：认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生\n * 用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。\n\n无论怎样，若从时间顺序方面来看，这四个环节是按时间前后、依次相继发生的关系。\n\n认证和鉴权的关系：\n\n这两个概念在很多时候是被混淆最多的概念。被混淆的主要原因，如上文所述，很多时候认证、授权、鉴权和权限控制一同发生，以至于被误解为，认证就是鉴权，鉴权就是认证。\n\n其实两者是不一样的概念，两者都有对身份的确认过程，但是两者的主要区别在于，\n\n * 认证是确认声明者的本身身份，其作为授权的上游衔接而存在\n * 鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在\n\n\n# JWT\n\n\n# 参考资料\n\n理解 OAuth 2.0",normalizedContent:"# 认证和授权\n\n> 关键词：sso、oauth 2.0、cas、rabc、jwt\n\n\n# 基本概念\n\n\n# 认证\n\n认证是指根据声明者所特有的识别信息，确认声明者的身份。认证在英文中对应于 identification 这个单词。\n\n最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术：\n\n * 身份证\n * 用户名和密码认证\n * 用户手机认证：手机短信、手机二维码扫描、手势密码\n * 用户邮箱认证\n * 基于时间序列和用户相关的一次性口令\n * 用户的生物学特征认证：指纹、语音、眼睛虹膜\n * 用户的大数据识别认证\n * 等等\n\n为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。\n\n\n# 授权\n\n简单来说，授权一般是指获取用户的委派权限。在英文中对应于 authorization 这个单词。\n\n在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念，\n\n * 资源所有者：拥有资源的所有权利，一般就是资源的拥有者。\n * 资源执行者：被委派去执行资源的相关操作。\n * 操作权限：可以对资源进行的某种操作。\n * 资源：有价值的信息或数据等，受到安全保护。\n\n需要说明的是，资源所有者和执行者可以是自然人，就是普通用户，但不限于自然人。在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器。比如用户在浏览器上登录一个网站，那么这个浏览器就成为一个执行者，它在用户登录后获取了用户的授权，代表着用户执行各种指令，进行购物、下单、付钱、转账等等操作。\n\n同时，资源所有者和执行者可以是分开的不同实体，也可以是同一个。若是分开的两者，则资源执行者是以资源所有者的代理形式而存在。\n\n授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。\n\n在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，\n\n * 通过 web 服务器的 session 机制，一个访问会话保持着用户的授权信息\n * 通过 web 浏览器的 cookie 机制，一个网站的 cookie 保持着用户的授权信息\n * 颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息\n\n前面两者常见于 web 开发，需要有浏览器的支持。\n\n\n# 鉴权\n\n鉴权是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在英文中对应于 authentication 这个单词。\n\n鉴权主要是对声明者所声明的真实性进行校验。若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。\n\n因此，鉴权的实现方式是和授权方式有一一对应关系。对授权所颁发授信媒介进行解析，确认其真实性。下面是鉴权的一些实现方式，\n\n * 门禁卡：通过门禁卡识别器\n * 钥匙：通过相匹配的锁\n * 银行卡：通过银行卡识别器\n * 互联网 web 开发领域的 session/cookie/token：校验 session/cookie/token 的合法性和有效性\n\n鉴权是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。\n\n\n# 权限控制\n\n权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。权限控制在英文中对应于 access/permission control。\n\n对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。\n\n先看权限（permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。\n\n若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为，\n\n * 这是一个门禁卡，拥有开公司所有的门的权限\n * 这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门\n\n可以看到，权限作为一个抽象的概念，将执行者和可具体执行的操作相分离。\n\n在上文的讨论中，鉴权的输出是权限（permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。\n\n对于控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行。现实生活中控制的实现方式，多种多样，\n\n * 门禁：控制门的开关\n * 自行车锁：控制车轮\n * 互联网 web 后端服务：控制接口访问，允许或拒绝访问请求\n\n\n# 认证、授权、鉴权和权限控制的关系\n\n认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系，\n\n认证--\x3e授权--\x3e鉴权--\x3e权限控制\n\n需要说明的是，这四个环节在有些时候会同时发生。 例如在下面的几个场景，\n\n * 使用门禁卡开门：认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生\n * 用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。\n\n无论怎样，若从时间顺序方面来看，这四个环节是按时间前后、依次相继发生的关系。\n\n认证和鉴权的关系：\n\n这两个概念在很多时候是被混淆最多的概念。被混淆的主要原因，如上文所述，很多时候认证、授权、鉴权和权限控制一同发生，以至于被误解为，认证就是鉴权，鉴权就是认证。\n\n其实两者是不一样的概念，两者都有对身份的确认过程，但是两者的主要区别在于，\n\n * 认证是确认声明者的本身身份，其作为授权的上游衔接而存在\n * 鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在\n\n\n# jwt\n\n\n# 参考资料\n\n理解 oauth 2.0",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"OAuth 2.0",frontmatter:{title:"OAuth 2.0",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","安全"],tags:["架构","安全","认证","授权","OAuth 2.0"],permalink:"/pages/21bd0a/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/02.%E5%AE%89%E5%85%A8/02.OAuth2.0.html",relativePath:"03.设计/01.架构/02.安全/02.OAuth2.0.md",key:"v-04b48643",path:"/pages/21bd0a/",headers:[{level:2,title:"授权码模式",slug:"授权码模式",normalizedTitle:"授权码模式",charIndex:251},{level:2,title:"隐藏模式",slug:"隐藏模式",normalizedTitle:"隐藏模式",charIndex:538},{level:2,title:"密码模式",slug:"密码模式",normalizedTitle:"密码模式",charIndex:298},{level:2,title:"客户端凭证模式",slug:"客户端凭证模式",normalizedTitle:"客户端凭证模式",charIndex:757},{level:2,title:"令牌的使用",slug:"令牌的使用",normalizedTitle:"令牌的使用",charIndex:796},{level:2,title:"令牌的更新",slug:"令牌的更新",normalizedTitle:"令牌的更新",charIndex:806},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1029}],headersStr:"授权码模式 隐藏模式 密码模式 客户端凭证模式 令牌的使用 令牌的更新 参考资料",content:'# OAuth 2.0\n\n> OAuth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。\n\n简单来说，OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。\n\nOAuth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n\n# 授权码模式\n\n授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。\n\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n\n# 隐藏模式\n\n有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。\n\n\n# 密码模式\n\n如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。\n\n\n# 客户端凭证模式\n\n适用于没有前端的命令行应用，即在命令行下请求令牌。\n\n\n# 令牌的使用\n\n\n# 令牌的更新\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 HTTP 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致\n\n\n# 参考资料\n\n * RFC 6749\n * OAuth 2.0 的一个简单解释\n * 理解 OAuth 2.0\n * The Simplest Guide To OAuth 2.0',normalizedContent:'# oauth 2.0\n\n> oauth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。\n\n简单来说，oauth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。\n\noauth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n\n# 授权码模式\n\n授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。\n\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n\n# 隐藏模式\n\n有些 web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。rfc 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。\n\n\n# 密码模式\n\n如果你高度信任某个应用，rfc 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。\n\n\n# 客户端凭证模式\n\n适用于没有前端的命令行应用，即在命令行下请求令牌。\n\n\n# 令牌的使用\n\n\n# 令牌的更新\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 http 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致\n\n\n# 参考资料\n\n * rfc 6749\n * oauth 2.0 的一个简单解释\n * 理解 oauth 2.0\n * the simplest guide to oauth 2.0',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"Cinchcast 的架构",frontmatter:{title:"Cinchcast 的架构",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/3f25aa/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Cinchcast%E7%9A%84%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/99.解决方案/Cinchcast的架构.md",key:"v-b45bd736",path:"/pages/3f25aa/",headers:[{level:2,title:"统计数据",slug:"统计数据",normalizedTitle:"统计数据",charIndex:231},{level:2,title:"数据中心",slug:"数据中心",normalizedTitle:"数据中心",charIndex:417},{level:2,title:"硬件",slug:"硬件",normalizedTitle:"硬件",charIndex:408},{level:2,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:626},{level:2,title:"软件和使用的技术",slug:"软件和使用的技术",normalizedTitle:"软件和使用的技术",charIndex:839},{level:2,title:"监测",slug:"监测",normalizedTitle:"监测",charIndex:1083},{level:2,title:"我们的原则",slug:"我们的原则",normalizedTitle:"我们的原则",charIndex:1238},{level:2,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:13},{level:2,title:"经验教训",slug:"经验教训",normalizedTitle:"经验教训",charIndex:1748},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2152}],headersStr:"统计数据 数据中心 硬件 开发工具 软件和使用的技术 监测 我们的原则 架构 经验教训 参考资料",content:"# Cinchcast 的架构\n\nCinchcast 提供的解决方案允许公司创建、共享、衡量和货币化音频内容，以接触和吸引对其业务最重要的人。我们的技术将会议桥接器与实时音频流相结合，以简化在线活动并增强参与者的参与度。 Cinchcast 技术还用于为全球最大的音频社交网络 Blogtalkradio 提供动力。今天，我们的平台每天制作和分发超过 1,500 小时的原创内容。在本文中，我们描述了我们为扩展平台以支持这种规模的数据而做出的工程决策。\n\n\n# 统计数据\n\n * 浏览量每月超过 5000 万\n * 创建了 50000 小时的音频内容\n * 1500 万个流媒体\n * 175,000,000 次广告展示\n * 峰值每秒 40000 并发请求\n * MSSQL、Redis、ElasticSearch 集群中存储的数据达到每天数 TB，\n * 10 人工程师团队\n * 生产环境大概有 100 左右的硬件节点\n\n\n# 数据中心\n\n线上网站部署在布鲁克林的数据中心。但 QA 和 Staging 环境则使用了 Amazon EC2 云实例。\n\n——考虑到数据安全，大部分公司不愿意把真实数据部署在云端。\n\n\n# 硬件\n\n * 大概有 50 台 Web 服务器\n * 15 台 MS SQL 数据库服务器\n * 2 台 Redis 的 NoSQL 的键值服务器\n * 2 台 NodeJS 服务器\n * 2 台 弹性搜索集群服务器\n\n\n# 开发工具\n\n * NET 4 C#：ASP.NET 和 MVC3\n * IDE 用的是 Visual Studio 2010 Team Suite\n * 用 StyleCop、ReSharper 来强化代码标准\n * 使用敏捷。其中大的功能用 Scrum，小任务则通过看板任务墙管理\n * 测试和持续集成使用 Jenkins + Nunit\n * 自动化测试则是 Selenium 和 Sauce On Demand\n\n\n# 软件和使用的技术\n\n * Windows Server 2008 R2 的 64 位操作系统\n * 基于微软 Windows Server 2008 Web 服务器下运行的 SQL Server 2005\n * 负载均衡是 EQL(Equalizer load balancers)\n * Redis 作为分布式缓存层和消息分发队列\n * NodeJS 用来进行实时分析和更新仪表盘\n * 搜索用得是 ElasticSearch，日志分析是通过 Sawmill+自定义分析器脚本\n\n\n# 监测\n\n * NewRelic：性能监控\n * 性能对 KPI（转换率，页面浏览量）的影响：Chartbeat：\n * Gomez，WhatsupGold，Nagios 等用来各种预警和报警\n * SQL Server monitoring 的监控：来自 Red Gate 的 SQL Monitor\n\n\n# 我们的原则\n\n * 尊重他人的时间。不要带着问题来，要拿出解决办法。\n * 不要去追逐当下的热点技术，先实现基本功能，然后再做锦上添花的。务实是最重要的。\n * 成为一个“如何做”的团队而不是总是说“不”的团队\n * 预先处理总比亡羊补牢要好，把安全植入到软件开发生命周期中，通过培训开发人员如何写出安全的软件并把它从一开始就作为业务优先考虑之处。\n\n\n# 架构\n\n * 所有 Javascript、CSS 和图像都缓存在 CDN 级别。 DNS 指向一个 CDN，它将请求传递给源服务器。我们使用 Cotendo 是因为它允许在 CDN 上做出 L7 路由决策。\n * 单独的 Web 服务器集群用于为普通用户和广告用户的请求提供服务，通过 cookie 进行区分。\n * 我们正在转向面向服务的架构，其中系统的关键部分，例如搜索、身份验证、缓存，都是以各种语言实现的 RESTFUL 服务。这些服务还提供了一个缓存层。\n * REDIS NOSQL 键值存储（redis.io）用作数据库调用之前的缓存层。\n * Scaleout 用于在网络服务器集群中维护会话状态。但是，我们正在考虑切换到 REDIS。\n\n\n# 经验教训\n\n * SQL Server 数据库中的文本搜索不好用，经常出现 CPU 阻塞，所以 Cinchcast 切换到 ElasticSearch，一个 Lucene 的衍生工具。\n * 微软内置的会话模块容易出现死锁，他们用 AngiesList 会话模块取代了它，并把数据存储到 Redis。\n * 日志是发现问题的关键。\n * 重新发明轮子，有时候也可以是一件好事。例如，在一个供应商的提供的 JS / CSS 的产品导致性能问题的时候，他们通过重写显著改善了网站的性能。\n * 并不是所有的数据都是关系型的。\n * 在开发中不使用指标检测就像在风暴中不参考高度表来降落飞机，因此整个开发过程中，一定要通过网站吞吐量，解决错误的时间、代码覆盖率，等指标来衡量你的效率。 总的来说，对于日 PV 百万级的网站来说，Cinchcast 的架构、研发、运维等层面的技术选型和经验值得学习和参考。\n\n\n# 参考资料\n\n * 每天产生 1500 小时的音频",normalizedContent:"# cinchcast 的架构\n\ncinchcast 提供的解决方案允许公司创建、共享、衡量和货币化音频内容，以接触和吸引对其业务最重要的人。我们的技术将会议桥接器与实时音频流相结合，以简化在线活动并增强参与者的参与度。 cinchcast 技术还用于为全球最大的音频社交网络 blogtalkradio 提供动力。今天，我们的平台每天制作和分发超过 1,500 小时的原创内容。在本文中，我们描述了我们为扩展平台以支持这种规模的数据而做出的工程决策。\n\n\n# 统计数据\n\n * 浏览量每月超过 5000 万\n * 创建了 50000 小时的音频内容\n * 1500 万个流媒体\n * 175,000,000 次广告展示\n * 峰值每秒 40000 并发请求\n * mssql、redis、elasticsearch 集群中存储的数据达到每天数 tb，\n * 10 人工程师团队\n * 生产环境大概有 100 左右的硬件节点\n\n\n# 数据中心\n\n线上网站部署在布鲁克林的数据中心。但 qa 和 staging 环境则使用了 amazon ec2 云实例。\n\n——考虑到数据安全，大部分公司不愿意把真实数据部署在云端。\n\n\n# 硬件\n\n * 大概有 50 台 web 服务器\n * 15 台 ms sql 数据库服务器\n * 2 台 redis 的 nosql 的键值服务器\n * 2 台 nodejs 服务器\n * 2 台 弹性搜索集群服务器\n\n\n# 开发工具\n\n * net 4 c#：asp.net 和 mvc3\n * ide 用的是 visual studio 2010 team suite\n * 用 stylecop、resharper 来强化代码标准\n * 使用敏捷。其中大的功能用 scrum，小任务则通过看板任务墙管理\n * 测试和持续集成使用 jenkins + nunit\n * 自动化测试则是 selenium 和 sauce on demand\n\n\n# 软件和使用的技术\n\n * windows server 2008 r2 的 64 位操作系统\n * 基于微软 windows server 2008 web 服务器下运行的 sql server 2005\n * 负载均衡是 eql(equalizer load balancers)\n * redis 作为分布式缓存层和消息分发队列\n * nodejs 用来进行实时分析和更新仪表盘\n * 搜索用得是 elasticsearch，日志分析是通过 sawmill+自定义分析器脚本\n\n\n# 监测\n\n * newrelic：性能监控\n * 性能对 kpi（转换率，页面浏览量）的影响：chartbeat：\n * gomez，whatsupgold，nagios 等用来各种预警和报警\n * sql server monitoring 的监控：来自 red gate 的 sql monitor\n\n\n# 我们的原则\n\n * 尊重他人的时间。不要带着问题来，要拿出解决办法。\n * 不要去追逐当下的热点技术，先实现基本功能，然后再做锦上添花的。务实是最重要的。\n * 成为一个“如何做”的团队而不是总是说“不”的团队\n * 预先处理总比亡羊补牢要好，把安全植入到软件开发生命周期中，通过培训开发人员如何写出安全的软件并把它从一开始就作为业务优先考虑之处。\n\n\n# 架构\n\n * 所有 javascript、css 和图像都缓存在 cdn 级别。 dns 指向一个 cdn，它将请求传递给源服务器。我们使用 cotendo 是因为它允许在 cdn 上做出 l7 路由决策。\n * 单独的 web 服务器集群用于为普通用户和广告用户的请求提供服务，通过 cookie 进行区分。\n * 我们正在转向面向服务的架构，其中系统的关键部分，例如搜索、身份验证、缓存，都是以各种语言实现的 restful 服务。这些服务还提供了一个缓存层。\n * redis nosql 键值存储（redis.io）用作数据库调用之前的缓存层。\n * scaleout 用于在网络服务器集群中维护会话状态。但是，我们正在考虑切换到 redis。\n\n\n# 经验教训\n\n * sql server 数据库中的文本搜索不好用，经常出现 cpu 阻塞，所以 cinchcast 切换到 elasticsearch，一个 lucene 的衍生工具。\n * 微软内置的会话模块容易出现死锁，他们用 angieslist 会话模块取代了它，并把数据存储到 redis。\n * 日志是发现问题的关键。\n * 重新发明轮子，有时候也可以是一件好事。例如，在一个供应商的提供的 js / css 的产品导致性能问题的时候，他们通过重写显著改善了网站的性能。\n * 并不是所有的数据都是关系型的。\n * 在开发中不使用指标检测就像在风暴中不参考高度表来降落飞机，因此整个开发过程中，一定要通过网站吞吐量，解决错误的时间、代码覆盖率，等指标来衡量你的效率。 总的来说，对于日 pv 百万级的网站来说，cinchcast 的架构、研发、运维等层面的技术选型和经验值得学习和参考。\n\n\n# 参考资料\n\n * 每天产生 1500 小时的音频",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"README",frontmatter:{title:"README",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/c38eff/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",relativePath:"03.设计/01.架构/99.解决方案/README.md",key:"v-f4f72696",path:"/pages/c38eff/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:11},{level:3,title:"知名系统架构",slug:"知名系统架构",normalizedTitle:"知名系统架构",charIndex:21},{level:3,title:"我上我也行系列",slug:"我上我也行系列",normalizedTitle:"我上我也行系列",charIndex:1665},{level:4,title:"设计一个短地址服务",slug:"设计一个短地址服务",normalizedTitle:"设计一个短地址服务",charIndex:1676},{level:4,title:"设计一个低代码平台",slug:"设计一个低代码平台",normalizedTitle:"设计一个低代码平台",charIndex:1689},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1703}],headersStr:"📖 内容 知名系统架构 我上我也行系列 设计一个短地址服务 设计一个低代码平台 🚪 传送",content:"# 解决方案\n\n\n# 📖 内容\n\n\n# 知名系统架构\n\n类型                细分类型    系统                                      资料\nData processing           MapReduce - Google 的分布式数据处理             research.google.com\nData processing           Spark - Databricks 的分布式数据处理             slideshare.net\nData processing           Storm - Twitter 的分布式数据处理                slideshare.net\n                                                                  \n分布式存储             Nosql   Bigtable - Google 的列式数据库                harvard.edu\n分布式存储             Nosql   HBase - Bigtable 的开源实现                  slideshare.net\n分布式存储             Nosql   Cassandra - Facebook 的列式数据库             slideshare.net\n分布式存储             Nosql   DynamoDB - Amazon 的文档数据库                harvard.edu\n分布式存储             Nosql   MongoDB - 文档数据库                         MongoDB\n分布式存储             Nosql   Spanner - Google 的全球分布数据库               research.google.com\n分布式存储             Nosql   Memcached - 分布式内存缓存系统                   slideshare.net\n分布式存储             Nosql   Redis - 能够持久化及具有值类型的分布式内存缓存系统           Redis\n分布式存储             文件系统    Google File System (GFS) - 分布式文件系统      research.google.com\n分布式存储             文件系统    Hadoop File System (HDFS) - GFS 的开源实现   apache.org\n                                                                  \n分布式中间件                    Chubby - Google 的分布式系统的低耦合锁服务           research.google.com\n分布式中间件                    Dapper - 分布式系统跟踪基础设施                    research.google.com\n分布式中间件            MQ      Kafka - LinkedIn 的发布订阅消息系统              Kafka\n分布式中间件            分布式协调   Zookeeper - 集中的基础架构和协调服务                ZooKeeper\n                                                                  \n\n\n# 我上我也行系列\n\n# 设计一个短地址服务\n\n# 设计一个低代码平台\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 解决方案\n\n\n# 📖 内容\n\n\n# 知名系统架构\n\n类型                细分类型    系统                                      资料\ndata processing           mapreduce - google 的分布式数据处理             research.google.com\ndata processing           spark - databricks 的分布式数据处理             slideshare.net\ndata processing           storm - twitter 的分布式数据处理                slideshare.net\n                                                                  \n分布式存储             nosql   bigtable - google 的列式数据库                harvard.edu\n分布式存储             nosql   hbase - bigtable 的开源实现                  slideshare.net\n分布式存储             nosql   cassandra - facebook 的列式数据库             slideshare.net\n分布式存储             nosql   dynamodb - amazon 的文档数据库                harvard.edu\n分布式存储             nosql   mongodb - 文档数据库                         mongodb\n分布式存储             nosql   spanner - google 的全球分布数据库               research.google.com\n分布式存储             nosql   memcached - 分布式内存缓存系统                   slideshare.net\n分布式存储             nosql   redis - 能够持久化及具有值类型的分布式内存缓存系统           redis\n分布式存储             文件系统    google file system (gfs) - 分布式文件系统      research.google.com\n分布式存储             文件系统    hadoop file system (hdfs) - gfs 的开源实现   apache.org\n                                                                  \n分布式中间件                    chubby - google 的分布式系统的低耦合锁服务           research.google.com\n分布式中间件                    dapper - 分布式系统跟踪基础设施                    research.google.com\n分布式中间件            mq      kafka - linkedin 的发布订阅消息系统              kafka\n分布式中间件            分布式协调   zookeeper - 集中的基础架构和协调服务                zookeeper\n                                                                  \n\n\n# 我上我也行系列\n\n# 设计一个短地址服务\n\n# 设计一个低代码平台\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"亚马逊的架构",frontmatter:{title:"亚马逊的架构",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/940342/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%9A%84%E6%9E%B6%E6%9E%84.html",relativePath:"03.设计/01.架构/99.解决方案/亚马逊的架构.md",key:"v-f104e8ee",path:"/pages/940342/",headers:[{level:2,title:"摘录的要点",slug:"摘录的要点",normalizedTitle:"摘录的要点",charIndex:13},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:178}],headersStr:"摘录的要点 参考资料",content:"# 亚马逊的架构\n\n\n# 摘录的要点\n\n可扩展：添加资源，性能成正比提升\n\n分布式、去中心化\n\n隔离性：面向服务，聚合数以百计的服务，对外统一提供服务\n\n同时支持 REST 和 SOAP\n\n团队在精不在多，节省沟通成本\n\n状态管理是大规模系统的核心问题，如分布式 Session 等\n\n设计应尽量简单，很多问题可以用业务逻辑去解决，而不是通过技术\n\n\n# 参考资料\n\n * Amazon 的架构",normalizedContent:"# 亚马逊的架构\n\n\n# 摘录的要点\n\n可扩展：添加资源，性能成正比提升\n\n分布式、去中心化\n\n隔离性：面向服务，聚合数以百计的服务，对外统一提供服务\n\n同时支持 rest 和 soap\n\n团队在精不在多，节省沟通成本\n\n状态管理是大规模系统的核心问题，如分布式 session 等\n\n设计应尽量简单，很多问题可以用业务逻辑去解决，而不是通过技术\n\n\n# 参考资料\n\n * amazon 的架构",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"低代码平台",frontmatter:{title:"低代码平台",date:"2021-05-06T16:57:48.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/f90553/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0.html",relativePath:"03.设计/01.架构/99.解决方案/低代码平台.md",key:"v-569eca3f",path:"/pages/f90553/",headers:[{level:2,title:"业务分析",slug:"业务分析",normalizedTitle:"业务分析",charIndex:76},{level:3,title:"低代码平台是什么",slug:"低代码平台是什么",normalizedTitle:"低代码平台是什么",charIndex:85},{level:3,title:"技术路线",slug:"技术路线",normalizedTitle:"技术路线",charIndex:287},{level:4,title:"基于 IDE 框架的快速开发平台",slug:"基于-ide-框架的快速开发平台",normalizedTitle:"基于 ide 框架的快速开发平台",charIndex:295},{level:4,title:"基于模型驱动的应用平台",slug:"基于模型驱动的应用平台",normalizedTitle:"基于模型驱动的应用平台",charIndex:556},{level:3,title:"核心要素",slug:"核心要素",normalizedTitle:"核心要素",charIndex:783},{level:4,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:356},{level:4,title:"业务流程",slug:"业务流程",normalizedTitle:"业务流程",charIndex:986},{level:4,title:"用户权限",slug:"用户权限",normalizedTitle:"用户权限",charIndex:991},{level:4,title:"统计图表",slug:"统计图表",normalizedTitle:"统计图表",charIndex:996},{level:3,title:"流行产品",slug:"流行产品",normalizedTitle:"流行产品",charIndex:1776},{level:4,title:"OutSystems",slug:"outsystems",normalizedTitle:"outsystems",charIndex:1784},{level:4,title:"Mendix",slug:"mendix",normalizedTitle:"mendix",charIndex:1923},{level:2,title:"顶层设计",slug:"顶层设计",normalizedTitle:"顶层设计",charIndex:2064},{level:2,title:"组件设计",slug:"组件设计",normalizedTitle:"组件设计",charIndex:2452},{level:3,title:"列表页",slug:"列表页",normalizedTitle:"列表页",charIndex:2461},{level:4,title:"搜索栏",slug:"搜索栏",normalizedTitle:"搜索栏",charIndex:2468},{level:4,title:"操作栏",slug:"操作栏",normalizedTitle:"操作栏",charIndex:2475},{level:4,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:2482},{level:4,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:2488},{level:3,title:"表单页",slug:"表单页",normalizedTitle:"表单页",charIndex:2495},{level:4,title:"表单组件",slug:"表单组件",normalizedTitle:"表单组件",charIndex:2502},{level:4,title:"校验器",slug:"校验器",normalizedTitle:"校验器",charIndex:2510},{level:2,title:"扩展设计",slug:"扩展设计",normalizedTitle:"扩展设计",charIndex:2518},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2527}],headersStr:"业务分析 低代码平台是什么 技术路线 基于 IDE 框架的快速开发平台 基于模型驱动的应用平台 核心要素 数据模型 业务流程 用户权限 统计图表 流行产品 OutSystems Mendix 顶层设计 组件设计 列表页 搜索栏 操作栏 表格 分页 表单页 表单组件 校验器 扩展设计 参考资料",content:"# 设计一个低代码平台\n\n> 本文目标是设计一个用于提高开发人员开发效率的低代码平台，这里会采用系统解决方案设计的一般思路来逐步探寻设计方案。\n\n\n# 业务分析\n\n\n# 低代码平台是什么\n\n广义上的低代码平台包括低代码平台和零代码平台，它们都属于 APaaS（Application Platform as a Service 应用平台即服务），两者的主要区别在于对代码的依赖程度：\n\n * 低代码平台：通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。\n * 零代码平台：零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。\n\n\n# 技术路线\n\n# 基于 IDE 框架的快速开发平台\n\n该方案将传统的集成开发环境（IDE）充分可视化，开发者对前端界面组件、数据源绑定方式、数据模型、业务逻辑和工作流等都可以自由定义，平台将自动生成代码，开发者也可以添加自己的代码，对程序具有较强的控制能力，因此该方案具备更高的灵活性，可以设计出定制化程度高、逻辑复杂的软件。\n\n由于该方案仍涉及代码开发、部署等技术工作，所以它仍然是一个技术开发平台，需要较高的学习成本，主要价值是提高开发效率，减少重复劳动。\n\nOutsystems 就是采用该方案的典型产品，如下为产品截图：\n\n\n\n# 基于模型驱动的应用平台\n\n用户通过可视化方式构建数据模型、视图、权限、工作流等，即可在平台提供的环境中运行，无需编译部署，更像一种傻瓜式的应用搭建平台。平台对各类组件、业务逻辑做了较高层级的封装，因此用户无法随心所欲修改界面风格、交互方式、处理逻辑等。\n\n该方案可以实现完全零代码，对使用者技术要求不高，但需要具备业务抽象、建模能力。主要价值是降低开发门槛、快速适应变化。\n\n明道云、伙伴云等都是此类方案的典型产品，如下为明道云的产品截图：\n\n\n\n\n# 核心要素\n\n绝大部分的企业软件由以下四个部分组成：\n\n * 业务实体：即操作对象，如客户、订单\n * 业务活动：即进行何种操作，如采购申请、合同审批\n * 业务权限：即何种人拥有何种权限，包括数据查看权限和数据操作权限，如部门经理可以管理所有下属的客户信息，而员工只能管理自己的客户信息\n * 统计报表：即从哪些方面量化企业活动情况，如客户增长率、各月销售额趋势\n\n低代码平台将以上进行抽象，支持数据模型、业务流程、用户权限、统计图表，因此可以作为更通用的企业软件解决方案，这四类能力也是任何一个低代码平台都必须具备的核心要素。\n\n# 数据模型\n\n建立数据模型就是提取业务实体的数据特征，抽象为数据表，建立表间关系。制作 ER 图的过程就是数据建模。市面上常见的低代码平台均提供了丰富的控件，可以拖拽完成数据模型搭建。此外，数据模型搭建与表单展示合二为一，每完成一个数据表的创建，就自动生成了该表的增删改查功能及相关页面，进而隐藏了数据库设计、前端开发这些专业技术。其实，这也就是我们常说的表单引擎。\n\n这里顺便提一下，虽然很多低代码平台将数据建模与表单展示合二为一，但通过这种方式自动生成的表单只能实现最基础的增删改查页面，用户对界面展示内容及形式的控制程度很低，无法满足大部分企业软件的需求，所以低代码平台一般还会提供自定义页面功能，用户可根据需要在页面上配置按钮、图表等元素，满足个性化需求。\n\n# 业务流程\n\n业务流程指为了实现某项目标，由多人合作，按照一定的规则、顺序进行的一系列活动，在软件中，业务流程的参与者可以是人，也可以是程序。低代码平台实现了可视化流程配置，用户对触发条件、处理节点、节点参与者进行配置，实现自定义业务流程。\n\n# 用户权限\n\n大部分的低代码平台都采用了非常经典的 RBAC（Role-Based Access Control ）模型管理用户权限，简单来说就是将拥有相同权限的用户添加为相同角色，通过为角色分配权限，实现了“用户——角色——权限”的授权模式。由于企业是一个组织，一般都会有部门的概念，所以也可以将部门添加到某个角色，实现“用户——部门——角色——权限”的授权模式。\n\n# 统计图表\n\n统计图表可以类比 Excel 中的透视图，统计图表由数据源、统计规则、展示形式定义，低代码平台也正是遵循这种方式，实现统计图表的可视化配置。\n\n\n# 流行产品\n\n# OutSystems\n\nOutSystems 是快速应用开发的头号低代码平台，并且是 2018 年 Gartner 高生产力平台的领导者。OutSystems 号称将低代码功能与高级移动功能相结合的唯一解决方案，它支持整个应用程序组合的可视化开发，可轻松与现有系统集成。\n\n# Mendix\n\nMendix 帮助企业改善创新方式。通过使用可视化模型，在 Mendix 上构建应用程序非常简单，快速且直观，可使开发人员和业务分析人员等众多人员构建强大的应用程序，而无需编写代码。借助模型驱动开发，业务领导者和 IT 部门可以共享语言来快速构建应用程序。\n\n\n# 顶层设计\n\n由于系统的用户群体是有一定技术基础的开发人员。所以，系统定位是低代码平台，而非零代码平台。\n\n其次，由于系统主要是用于简化基本的页面开发，所以技术路线应该选择：基于模型驱动的应用平台。\n\n最后，由于生成的代码是应用于 Java Web 框架。生成的后端代码是 java 代码；前端代码是基于 vue + element-ui 生态的前端代码。\n\n\n\n代码生成规则对应的数据建模：\n\n\n\n自动生成前后端代码。\n\n * 后端代码\n   * Controller\n   * Service\n   * ServiceImpl\n   * Daomybatis\n   * DaoImpl\n   * Mapper\n   * Query\n   * Dto\n   * Entity\n   * xml\n * 前端代码\n   * List\n   * Form\n   * Api\n\n\n# 组件设计\n\n\n# 列表页\n\n# 搜索栏\n\n# 操作栏\n\n# 表格\n\n# 分页\n\n\n# 表单页\n\n# 表单组件\n\n# 校验器\n\n\n# 扩展设计\n\n\n# 参考资料\n\n * 低代码平台：10 分钟从入门到原理\n * 浅谈低代码平台涉及的一些技术选型",normalizedContent:"# 设计一个低代码平台\n\n> 本文目标是设计一个用于提高开发人员开发效率的低代码平台，这里会采用系统解决方案设计的一般思路来逐步探寻设计方案。\n\n\n# 业务分析\n\n\n# 低代码平台是什么\n\n广义上的低代码平台包括低代码平台和零代码平台，它们都属于 apaas（application platform as a service 应用平台即服务），两者的主要区别在于对代码的依赖程度：\n\n * 低代码平台：通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。\n * 零代码平台：零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。\n\n\n# 技术路线\n\n# 基于 ide 框架的快速开发平台\n\n该方案将传统的集成开发环境（ide）充分可视化，开发者对前端界面组件、数据源绑定方式、数据模型、业务逻辑和工作流等都可以自由定义，平台将自动生成代码，开发者也可以添加自己的代码，对程序具有较强的控制能力，因此该方案具备更高的灵活性，可以设计出定制化程度高、逻辑复杂的软件。\n\n由于该方案仍涉及代码开发、部署等技术工作，所以它仍然是一个技术开发平台，需要较高的学习成本，主要价值是提高开发效率，减少重复劳动。\n\noutsystems 就是采用该方案的典型产品，如下为产品截图：\n\n\n\n# 基于模型驱动的应用平台\n\n用户通过可视化方式构建数据模型、视图、权限、工作流等，即可在平台提供的环境中运行，无需编译部署，更像一种傻瓜式的应用搭建平台。平台对各类组件、业务逻辑做了较高层级的封装，因此用户无法随心所欲修改界面风格、交互方式、处理逻辑等。\n\n该方案可以实现完全零代码，对使用者技术要求不高，但需要具备业务抽象、建模能力。主要价值是降低开发门槛、快速适应变化。\n\n明道云、伙伴云等都是此类方案的典型产品，如下为明道云的产品截图：\n\n\n\n\n# 核心要素\n\n绝大部分的企业软件由以下四个部分组成：\n\n * 业务实体：即操作对象，如客户、订单\n * 业务活动：即进行何种操作，如采购申请、合同审批\n * 业务权限：即何种人拥有何种权限，包括数据查看权限和数据操作权限，如部门经理可以管理所有下属的客户信息，而员工只能管理自己的客户信息\n * 统计报表：即从哪些方面量化企业活动情况，如客户增长率、各月销售额趋势\n\n低代码平台将以上进行抽象，支持数据模型、业务流程、用户权限、统计图表，因此可以作为更通用的企业软件解决方案，这四类能力也是任何一个低代码平台都必须具备的核心要素。\n\n# 数据模型\n\n建立数据模型就是提取业务实体的数据特征，抽象为数据表，建立表间关系。制作 er 图的过程就是数据建模。市面上常见的低代码平台均提供了丰富的控件，可以拖拽完成数据模型搭建。此外，数据模型搭建与表单展示合二为一，每完成一个数据表的创建，就自动生成了该表的增删改查功能及相关页面，进而隐藏了数据库设计、前端开发这些专业技术。其实，这也就是我们常说的表单引擎。\n\n这里顺便提一下，虽然很多低代码平台将数据建模与表单展示合二为一，但通过这种方式自动生成的表单只能实现最基础的增删改查页面，用户对界面展示内容及形式的控制程度很低，无法满足大部分企业软件的需求，所以低代码平台一般还会提供自定义页面功能，用户可根据需要在页面上配置按钮、图表等元素，满足个性化需求。\n\n# 业务流程\n\n业务流程指为了实现某项目标，由多人合作，按照一定的规则、顺序进行的一系列活动，在软件中，业务流程的参与者可以是人，也可以是程序。低代码平台实现了可视化流程配置，用户对触发条件、处理节点、节点参与者进行配置，实现自定义业务流程。\n\n# 用户权限\n\n大部分的低代码平台都采用了非常经典的 rbac（role-based access control ）模型管理用户权限，简单来说就是将拥有相同权限的用户添加为相同角色，通过为角色分配权限，实现了“用户——角色——权限”的授权模式。由于企业是一个组织，一般都会有部门的概念，所以也可以将部门添加到某个角色，实现“用户——部门——角色——权限”的授权模式。\n\n# 统计图表\n\n统计图表可以类比 excel 中的透视图，统计图表由数据源、统计规则、展示形式定义，低代码平台也正是遵循这种方式，实现统计图表的可视化配置。\n\n\n# 流行产品\n\n# outsystems\n\noutsystems 是快速应用开发的头号低代码平台，并且是 2018 年 gartner 高生产力平台的领导者。outsystems 号称将低代码功能与高级移动功能相结合的唯一解决方案，它支持整个应用程序组合的可视化开发，可轻松与现有系统集成。\n\n# mendix\n\nmendix 帮助企业改善创新方式。通过使用可视化模型，在 mendix 上构建应用程序非常简单，快速且直观，可使开发人员和业务分析人员等众多人员构建强大的应用程序，而无需编写代码。借助模型驱动开发，业务领导者和 it 部门可以共享语言来快速构建应用程序。\n\n\n# 顶层设计\n\n由于系统的用户群体是有一定技术基础的开发人员。所以，系统定位是低代码平台，而非零代码平台。\n\n其次，由于系统主要是用于简化基本的页面开发，所以技术路线应该选择：基于模型驱动的应用平台。\n\n最后，由于生成的代码是应用于 java web 框架。生成的后端代码是 java 代码；前端代码是基于 vue + element-ui 生态的前端代码。\n\n\n\n代码生成规则对应的数据建模：\n\n\n\n自动生成前后端代码。\n\n * 后端代码\n   * controller\n   * service\n   * serviceimpl\n   * daomybatis\n   * daoimpl\n   * mapper\n   * query\n   * dto\n   * entity\n   * xml\n * 前端代码\n   * list\n   * form\n   * api\n\n\n# 组件设计\n\n\n# 列表页\n\n# 搜索栏\n\n# 操作栏\n\n# 表格\n\n# 分页\n\n\n# 表单页\n\n# 表单组件\n\n# 校验器\n\n\n# 扩展设计\n\n\n# 参考资料\n\n * 低代码平台：10 分钟从入门到原理\n * 浅谈低代码平台涉及的一些技术选型",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"海量数据处理",frontmatter:{title:"海量数据处理",date:"2021-08-19T22:15:16.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/d63886/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html",relativePath:"03.设计/01.架构/99.解决方案/海量数据处理.md",key:"v-6f5cbd38",path:"/pages/d63886/",headers:[{level:2,title:"如何从海量的 URL 中找出相同的 URL？",slug:"如何从海量的-url-中找出相同的-url",normalizedTitle:"如何从海量的 url 中找出相同的 url？",charIndex:13},{level:3,title:"问题描述",slug:"问题描述",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方案总结",slug:"方案总结",normalizedTitle:"方案总结",charIndex:748},{level:2,title:"如何从海量数据中找出高频词？",slug:"如何从海量数据中找出高频词",normalizedTitle:"如何从海量数据中找出高频词？",charIndex:798},{level:3,title:"问题描述",slug:"问题描述-2",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-2",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方案总结",slug:"方案总结-2",normalizedTitle:"方案总结",charIndex:748},{level:2,title:"如何找出某一天访问百度网站最多的 IP？",slug:"如何找出某一天访问百度网站最多的-ip",normalizedTitle:"如何找出某一天访问百度网站最多的 ip？",charIndex:1564},{level:3,title:"问题描述",slug:"问题描述-3",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-3",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方法总结",slug:"方法总结",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何在大量的数据中找出不重复的整数？",slug:"如何在大量的数据中找出不重复的整数",normalizedTitle:"如何在大量的数据中找出不重复的整数？",charIndex:1938},{level:3,title:"问题描述",slug:"问题描述-4",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-4",normalizedTitle:"解决思路",charIndex:120},{level:4,title:"方法一：分治法",slug:"方法一-分治法",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：位图法",slug:"方法二-位图法",normalizedTitle:"方法二：位图法",charIndex:2113},{level:3,title:"方法总结",slug:"方法总结-2",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何在大量的数据中判断一个数是否存在？",slug:"如何在大量的数据中判断一个数是否存在",normalizedTitle:"如何在大量的数据中判断一个数是否存在？",charIndex:2959},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：分治法",slug:"方法一-分治法-2",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：位图法",slug:"方法二-位图法-2",normalizedTitle:"方法二：位图法",charIndex:2113},{level:3,title:"方法总结",slug:"方法总结-3",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何查询最热门的查询串？",slug:"如何查询最热门的查询串",normalizedTitle:"如何查询最热门的查询串？",charIndex:3311},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-2",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：分治法",slug:"方法一-分治法-3",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：HashMap 法",slug:"方法二-hashmap-法",normalizedTitle:"方法二：hashmap 法",charIndex:3732},{level:4,title:"方法三：前缀树法（字典树）",slug:"方法三-前缀树法-字典树",normalizedTitle:"方法三：前缀树法（字典树）",charIndex:4079},{level:3,title:"方法总结",slug:"方法总结-4",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何统计不同电话号码的个数？",slug:"如何统计不同电话号码的个数",normalizedTitle:"如何统计不同电话号码的个数？",charIndex:4350},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-3",normalizedTitle:"解答思路",charIndex:3062},{level:3,title:"方法总结",slug:"方法总结-5",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何从 5 亿个数中找出中位数？",slug:"如何从-5-亿个数中找出中位数",normalizedTitle:"如何从 5 亿个数中找出中位数？",charIndex:4703},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-4",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：双堆法",slug:"方法一-双堆法",normalizedTitle:"方法一：双堆法",charIndex:4914},{level:4,title:"方法二：分治法",slug:"方法二-分治法",normalizedTitle:"方法二：分治法",charIndex:6276},{level:3,title:"方法总结",slug:"方法总结-6",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何找出排名前 500 的数？",slug:"如何找出排名前-500-的数",normalizedTitle:"如何找出排名前 500 的数？",charIndex:6794},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-5",normalizedTitle:"解答思路",charIndex:3062},{level:3,title:"方法总结",slug:"方法总结-7",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何按照 query 的频度排序？",slug:"如何按照-query-的频度排序",normalizedTitle:"如何按照 query 的频度排序？",charIndex:9132},{level:3,title:"题目描述",slug:"题目描述-6",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-6",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：HashMap 法",slug:"方法一-hashmap-法",normalizedTitle:"方法一：hashmap 法",charIndex:9353},{level:4,title:"方法二：分治法",slug:"方法二-分治法-2",normalizedTitle:"方法二：分治法",charIndex:6276},{level:3,title:"方法总结",slug:"方法总结-8",normalizedTitle:"方法总结",charIndex:1852}],headersStr:"如何从海量的 URL 中找出相同的 URL？ 问题描述 解决思路 方案总结 如何从海量数据中找出高频词？ 问题描述 解决思路 方案总结 如何找出某一天访问百度网站最多的 IP？ 问题描述 解决思路 方法总结 如何在大量的数据中找出不重复的整数？ 问题描述 解决思路 方法一：分治法 方法二：位图法 方法总结 如何在大量的数据中判断一个数是否存在？ 题目描述 解答思路 方法一：分治法 方法二：位图法 方法总结 如何查询最热门的查询串？ 题目描述 解答思路 方法一：分治法 方法二：HashMap 法 方法三：前缀树法（字典树） 方法总结 如何统计不同电话号码的个数？ 题目描述 解答思路 方法总结 如何从 5 亿个数中找出中位数？ 题目描述 解答思路 方法一：双堆法 方法二：分治法 方法总结 如何找出排名前 500 的数？ 题目描述 解答思路 方法总结 如何按照 query 的频度排序？ 题目描述 解答思路 方法一：HashMap 法 方法二：分治法 方法总结",content:"# 海量数据处理\n\n\n# 如何从海量的 URL 中找出相同的 URL？\n\n\n# 问题描述\n\n给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。\n\n\n# 解决思路\n\n每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。\n\n> $$5,000,000,000 * 64 B ≈ 5 GB * 64 = 320 GB$$\n\n由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。\n\n思路如下：\n\n首先遍历文件 a，对遍历到的 URL 求 hash(URL) % 1000，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。\n\n接着遍历 ai( i∈[0,999])，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 对每个子文件进行 HashSet 统计。\n\n\n# 如何从海量数据中找出高频词？\n\n\n# 问题描述\n\n有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。\n\n\n# 解决思路\n\n由于内存限制，无法直接将大文件的所有词一次读到内存中。因此，可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。\n\n思路如下：\n\n首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 Ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。\n\n接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1) 若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。\n\n上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 使用 HashMap 统计频数；\n * 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。\n\n\n# 如何找出某一天访问百度网站最多的 IP？\n\n\n# 问题描述\n\n现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。\n\n\n# 解决思路\n\n这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。\n\n> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。\n\n\n# 方法总结\n\n * 分而治之，进行哈希取余；\n * 使用 HashMap 统计频数；\n * 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。\n\n\n# 如何在大量的数据中找出不重复的整数？\n\n\n# 问题描述\n\n在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。\n\n\n# 解决思路\n\n# 方法一：分治法\n\n与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。\n\n# 方法二：位图法\n\n位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。\n\n位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。\n\n假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：\n\n0 0 0 0 0 0 0 0\n\n\n然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：\n\n0 0 0 0 1 0 1 0\n\n\n依次遍历，结束后，位数组是这样的：\n\n0 1 1 0 1 1 1 0\n\n\n每个为 1 的位，它的下标都表示了一个数：\n\nfor i in range(8):\n    if bits[i] == 1:\n        print(i)\n\n\n这样我们其实就已经实现了排序。\n\n对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。\n\n那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：\n\n * 00 表示这个数字没出现过；\n * 01 表示这个数字出现过一次（即为题目所找的不重复整数）；\n * 10 表示这个数字出现了多次。\n\n那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：\n\n遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。\n\n\n# 方法总结\n\n判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何在大量的数据中判断一个数是否存在？\n\n\n# 题目描述\n\n给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？\n\n\n# 解答思路\n\n# 方法一：分治法\n\n依然可以用分治法解决，方法与前面类似，就不再次赘述了。\n\n# 方法二：位图法\n\n40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。\n\n我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。\n\n\n# 方法总结\n\n判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何查询最热门的查询串？\n\n\n# 题目描述\n\n搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。\n\n假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）\n\n\n# 解答思路\n\n每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。\n\n# 方法一：分治法\n\n分治法依然是一个非常实用的方法。\n\n划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。\n\n方法可行，但不是最好，下面介绍其他方法。\n\n# 方法二：HashMap 法\n\n虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。\n\n思路如下：\n\n首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。\n\n接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。\n\n遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。\n\n# 方法三：前缀树法（字典树）\n\n方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。\n\n思路如下：\n\n在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。\n\n最后依然使用小顶堆来对字符串的出现次数进行排序。\n\n\n# 方法总结\n\n前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。\n\n\n# 如何统计不同电话号码的个数？\n\n\n# 题目描述\n\n已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。\n\n\n# 解答思路\n\n这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。\n\n对于本题，8 位电话号码可以表示的号码个数为 $$10^8$$ 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。\n\n思路如下：\n\n申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。\n\n\n# 方法总结\n\n求解数据重复问题，记得考虑位图法。\n\n\n# 如何从 5 亿个数中找出中位数？\n\n\n# 题目描述\n\n从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。\n\n\n# 解答思路\n\n如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。\n\n# 方法一：双堆法\n\n维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。\n\n若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。\n\nclass MedianFinder {\n\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    /** initialize your data structure here. */\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\n        minHeap = new PriorityQueue<>(Integer::compareTo);\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || maxHeap.peek() > num) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        int size1 = maxHeap.size();\n        int size2 = minHeap.size();\n        if (size1 - size2 > 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (size2 - size1 > 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        int size1 = maxHeap.size();\n        int size2 = minHeap.size();\n\n        return size1 == size2\n            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2\n            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());\n    }\n}\n\n\n> 见 LeetCode No.295：https://leetcode.com/problems/find-median-from-data-stream/\n\n以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。\n\n# 方法二：分治法\n\n分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。\n\n对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。\n\n划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。\n\n> 提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。\n\n对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。\n\n> 注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。\n\n\n# 方法总结\n\n分治法，真香！\n\n\n# 如何找出排名前 500 的数？\n\n\n# 题目描述\n\n有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？\n\n\n# 解答思路\n\n对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：\n\n首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。\n\n接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。\n\n重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。\n\n> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。\n\nimport lombok.Data;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\n/**\n * @author https://github.com/yanglbme\n */\n@Data\npublic class DataWithSource implements Comparable<DataWithSource> {\n    /**\n     * 数值\n     */\n    private int value;\n\n    /**\n     * 记录数值来源的数组\n     */\n    private int source;\n\n    /**\n     * 记录数值在数组中的索引\n     */\n    private int index;\n\n    public DataWithSource(int value, int source, int index) {\n        this.value = value;\n        this.source = source;\n        this.index = index;\n    }\n\n    /**\n     *\n     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改\n     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆\n     */\n    @Override\n    public int compareTo(DataWithSource o) {\n        return Integer.compare(o.getValue(), this.value);\n    }\n}\n\n\nclass Test {\n    public static int[] getTop(int[][] data) {\n        int rowSize = data.length;\n        int columnSize = data[0].length;\n\n        // 创建一个columnSize大小的数组，存放结果\n        int[] result = new int[columnSize];\n\n        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();\n        for (int i = 0; i < rowSize; ++i) {\n            // 将每个数组的最大一个元素放入堆中\n            DataWithSource d = new DataWithSource(data[i][0], i, 0);\n            maxHeap.add(d);\n        }\n\n        int num = 0;\n        while (num < columnSize) {\n            // 删除堆顶元素\n            DataWithSource d = maxHeap.poll();\n            result[num++] = d.getValue();\n            if (num >= columnSize) {\n                break;\n            }\n\n            d.setValue(data[d.getSource()][d.getIndex() + 1]);\n            d.setIndex(d.getIndex() + 1);\n            maxHeap.add(d);\n        }\n        return result;\n\n    }\n\n    public static void main(String[] args) {\n        int[][] data = {\n                {29, 17, 14, 2, 1},\n                {19, 17, 16, 15, 6},\n                {30, 25, 20, 14, 5},\n        };\n\n        int[] top = getTop(data);\n        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]\n    }\n}\n\n\n\n# 方法总结\n\n求 TopK，不妨考虑一下堆排序？\n\n\n# 如何按照 query 的频度排序？\n\n\n# 题目描述\n\n有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。\n\n\n# 解答思路\n\n如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。\n\n# 方法一：HashMap 法\n\n如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。\n\n# 方法二：分治法\n\n分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。\n\n接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。\n\n\n# 方法总结\n\n * 内存若够，直接读入进行排序；\n * 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。",normalizedContent:"# 海量数据处理\n\n\n# 如何从海量的 url 中找出相同的 url？\n\n\n# 问题描述\n\n给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64b，内存限制是 4g。请找出 a、b 两个文件共同的 url。\n\n\n# 解决思路\n\n每个 url 占 64b，那么 50 亿个 url 占用的空间大小约为 320gb。\n\n> $$5,000,000,000 * 64 b ≈ 5 gb * 64 = 320 gb$$\n\n由于内存大小只有 4g，因此，我们不可能一次性把所有 url 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 url 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4g，这样就可以把这个小文件读到内存中进行处理了。\n\n思路如下：\n\n首先遍历文件 a，对遍历到的 url 求 hash(url) % 1000，根据计算结果把遍历到的 url 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300mb。使用同样的方法遍历文件 b，把文件 b 中的 url 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 url 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 url。那么接下来，我们只需要求出这 1000 对小文件中相同的 url 就好了。\n\n接着遍历 ai( i∈[0,999])，把 url 存储到一个 hashset 集合中。然后遍历 bi 中每个 url，看在 hashset 集合中是否存在，若存在，说明这就是共同的 url，可以把这个 url 保存到一个单独的文件中。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 对每个子文件进行 hashset 统计。\n\n\n# 如何从海量数据中找出高频词？\n\n\n# 问题描述\n\n有一个 1gb 大小的文件，文件里每一行是一个词，每个词的大小不超过 16b，内存大小限制是 1mb，要求返回频数最高的 100 个词(top 100)。\n\n\n# 解决思路\n\n由于内存限制，无法直接将大文件的所有词一次读到内存中。因此，可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1mb，进而直接将单个小文件读取到内存中进行处理。\n\n思路如下：\n\n首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200kb 左右。如果有的小文件大小仍然超过 1mb，则采用同样的方式继续进行分解。\n\n接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 hashmap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1) 若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。\n\n上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 使用 hashmap 统计频数；\n * 求解最大的 topn 个，用小顶堆；求解最小的 topn 个，用大顶堆。\n\n\n# 如何找出某一天访问百度网站最多的 ip？\n\n\n# 问题描述\n\n现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 ip。\n\n\n# 解决思路\n\n这道题只关心某一天访问百度最多的 ip，因此，可以首先对文件进行一次遍历，把这一天访问百度 ip 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 ip 进行哈希映射，接着使用 hashmap 统计重复 ip 的次数，最后计算出重复次数最多的 ip。\n\n> 注：这里只需要找出出现次数最多的 ip，可以不必使用堆，直接用一个变量 max 即可。\n\n\n# 方法总结\n\n * 分而治之，进行哈希取余；\n * 使用 hashmap 统计频数；\n * 求解最大的 topn 个，用小顶堆；求解最小的 topn 个，用大顶堆。\n\n\n# 如何在大量的数据中找出不重复的整数？\n\n\n# 问题描述\n\n在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。\n\n\n# 解决思路\n\n# 方法一：分治法\n\n与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 hashset/hashmap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。\n\n# 方法二：位图法\n\n位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。\n\n位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。\n\n假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：\n\n0 0 0 0 0 0 0 0\n\n\n然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：\n\n0 0 0 0 1 0 1 0\n\n\n依次遍历，结束后，位数组是这样的：\n\n0 1 1 0 1 1 1 0\n\n\n每个为 1 的位，它的下标都表示了一个数：\n\nfor i in range(8):\n    if bits[i] == 1:\n        print(i)\n\n\n这样我们其实就已经实现了排序。\n\n对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4b，即 32bit，那么我们可以表示的整数的个数为 232。\n\n那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：\n\n * 00 表示这个数字没出现过；\n * 01 表示这个数字出现过一次（即为题目所找的不重复整数）；\n * 10 表示这个数字出现了多次。\n\n那么这 232 个整数，总共所需内存为 232*2b=1gb。因此，当可用内存超过 1gb 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：\n\n遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。\n\n\n# 方法总结\n\n判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何在大量的数据中判断一个数是否存在？\n\n\n# 题目描述\n\n给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？\n\n\n# 解答思路\n\n# 方法一：分治法\n\n依然可以用分治法解决，方法与前面类似，就不再次赘述了。\n\n# 方法二：位图法\n\n40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512m。\n\n我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。\n\n\n# 方法总结\n\n判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何查询最热门的查询串？\n\n\n# 题目描述\n\n搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。\n\n假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1g。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）\n\n\n# 解答思路\n\n每个查询串最长为 255b，1000w 个串需要占用 约 2.55g 内存，因此，我们无法将所有字符串全部读入到内存中处理。\n\n# 方法一：分治法\n\n分治法依然是一个非常实用的方法。\n\n划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。\n\n方法可行，但不是最好，下面介绍其他方法。\n\n# 方法二：hashmap 法\n\n虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 hashmap 中，所占用的空间为 300w*(255+4)≈777m（其中，4 表示整数占用的 4 个字节）。由此可见，1g 的内存空间完全够用。\n\n思路如下：\n\n首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 o(n)。\n\n接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。\n\n遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 o(nlog10)。\n\n# 方法三：前缀树法（字典树）\n\n方法二使用了 hashmap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。\n\n思路如下：\n\n在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。\n\n最后依然使用小顶堆来对字符串的出现次数进行排序。\n\n\n# 方法总结\n\n前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。\n\n\n# 如何统计不同电话号码的个数？\n\n\n# 题目描述\n\n已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。\n\n\n# 解答思路\n\n这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。\n\n对于本题，8 位电话号码可以表示的号码个数为 $$10^8$$ 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100m。\n\n思路如下：\n\n申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。\n\n\n# 方法总结\n\n求解数据重复问题，记得考虑位图法。\n\n\n# 如何从 5 亿个数中找出中位数？\n\n\n# 题目描述\n\n从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (n+1)/2 个数；当样本数为偶数时，中位数为 第 n/2 个数与第 1+n/2 个数的均值。\n\n\n# 解答思路\n\n如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 o(nlogn)。这里使用其他方法。\n\n# 方法一：双堆法\n\n维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。\n\n若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。\n\nclass medianfinder {\n\n    private priorityqueue<integer> maxheap;\n    private priorityqueue<integer> minheap;\n\n    /** initialize your data structure here. */\n    public medianfinder() {\n        maxheap = new priorityqueue<>(comparator.reverseorder());\n        minheap = new priorityqueue<>(integer::compareto);\n    }\n\n    public void addnum(int num) {\n        if (maxheap.isempty() || maxheap.peek() > num) {\n            maxheap.offer(num);\n        } else {\n            minheap.offer(num);\n        }\n\n        int size1 = maxheap.size();\n        int size2 = minheap.size();\n        if (size1 - size2 > 1) {\n            minheap.offer(maxheap.poll());\n        } else if (size2 - size1 > 1) {\n            maxheap.offer(minheap.poll());\n        }\n    }\n\n    public double findmedian() {\n        int size1 = maxheap.size();\n        int size2 = minheap.size();\n\n        return size1 == size2\n            ? (maxheap.peek() + minheap.peek()) * 1.0 / 2\n            : (size1 > size2 ? maxheap.peek() : minheap.peek());\n    }\n}\n\n\n> 见 leetcode no.295：https://leetcode.com/problems/find-median-from-data-stream/\n\n以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4b，总共需要 2g 内存。如果可用内存不足 2g，就不能使用这种方法了，下面介绍另一种方法。\n\n# 方法二：分治法\n\n分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。\n\n对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。\n\n划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。\n\n> 提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。\n\n对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。\n\n> 注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。\n\n\n# 方法总结\n\n分治法，真香！\n\n\n# 如何找出排名前 500 的数？\n\n\n# 题目描述\n\n有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？\n\n\n# 解答思路\n\n对于 topk 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：\n\n首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。\n\n接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。\n\n重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。\n\n> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。\n\nimport lombok.data;\n\nimport java.util.arrays;\nimport java.util.priorityqueue;\n\n/**\n * @author https://github.com/yanglbme\n */\n@data\npublic class datawithsource implements comparable<datawithsource> {\n    /**\n     * 数值\n     */\n    private int value;\n\n    /**\n     * 记录数值来源的数组\n     */\n    private int source;\n\n    /**\n     * 记录数值在数组中的索引\n     */\n    private int index;\n\n    public datawithsource(int value, int source, int index) {\n        this.value = value;\n        this.source = source;\n        this.index = index;\n    }\n\n    /**\n     *\n     * 由于 priorityqueue 使用小顶堆来实现，这里通过修改\n     * 两个整数的比较逻辑来让 priorityqueue 变成大顶堆\n     */\n    @override\n    public int compareto(datawithsource o) {\n        return integer.compare(o.getvalue(), this.value);\n    }\n}\n\n\nclass test {\n    public static int[] gettop(int[][] data) {\n        int rowsize = data.length;\n        int columnsize = data[0].length;\n\n        // 创建一个columnsize大小的数组，存放结果\n        int[] result = new int[columnsize];\n\n        priorityqueue<datawithsource> maxheap = new priorityqueue<>();\n        for (int i = 0; i < rowsize; ++i) {\n            // 将每个数组的最大一个元素放入堆中\n            datawithsource d = new datawithsource(data[i][0], i, 0);\n            maxheap.add(d);\n        }\n\n        int num = 0;\n        while (num < columnsize) {\n            // 删除堆顶元素\n            datawithsource d = maxheap.poll();\n            result[num++] = d.getvalue();\n            if (num >= columnsize) {\n                break;\n            }\n\n            d.setvalue(data[d.getsource()][d.getindex() + 1]);\n            d.setindex(d.getindex() + 1);\n            maxheap.add(d);\n        }\n        return result;\n\n    }\n\n    public static void main(string[] args) {\n        int[][] data = {\n                {29, 17, 14, 2, 1},\n                {19, 17, 16, 15, 6},\n                {30, 25, 20, 14, 5},\n        };\n\n        int[] top = gettop(data);\n        system.out.println(arrays.tostring(top)); // [30, 29, 25, 20, 19]\n    }\n}\n\n\n\n# 方法总结\n\n求 topk，不妨考虑一下堆排序？\n\n\n# 如何按照 query 的频度排序？\n\n\n# 题目描述\n\n有 10 个文件，每个文件大小为 1g，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。\n\n\n# 解答思路\n\n如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。\n\n# 方法一：hashmap 法\n\n如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 hashmap 中。接着就可以按照 query 出现的次数进行排序。\n\n# 方法二：分治法\n\n分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 hashmap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。\n\n接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。\n\n\n# 方法总结\n\n * 内存若够，直接读入进行排序；\n * 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"电商",frontmatter:{title:"电商",date:"2021-08-05T23:42:12.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/4ae6a4/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%94%B5%E5%95%86.html",relativePath:"03.设计/01.架构/99.解决方案/电商.md",key:"v-5430ebce",path:"/pages/4ae6a4/",headers:[{level:2,title:"基本业务架构",slug:"基本业务架构",normalizedTitle:"基本业务架构",charIndex:9},{level:3,title:"订单",slug:"订单",normalizedTitle:"订单",charIndex:22},{level:4,title:"订单信息管理",slug:"订单信息管理",normalizedTitle:"订单信息管理",charIndex:80},{level:4,title:"优惠券",slug:"优惠券",normalizedTitle:"优惠券",charIndex:134},{level:2,title:"典型问题",slug:"典型问题",normalizedTitle:"典型问题",charIndex:142}],headersStr:"基本业务架构 订单 订单信息管理 优惠券 典型问题",content:"# 电商\n\n\n# 基本业务架构\n\n\n\n\n# 订单\n\n订单服务一般不主动调用其他服务\n\n订单服务不负责和第三方集成\n\n订单服务不提供优惠计算或成本分摊逻辑\n\n# 订单信息管理\n\n * 用户\n * 商品\n * 收货人\n * 收货地址\n * 收货时间\n * 订单状态\n\n# 优惠券\n\n\n# 典型问题\n\n秒杀活动\n\n超卖",normalizedContent:"# 电商\n\n\n# 基本业务架构\n\n\n\n\n# 订单\n\n订单服务一般不主动调用其他服务\n\n订单服务不负责和第三方集成\n\n订单服务不提供优惠计算或成本分摊逻辑\n\n# 订单信息管理\n\n * 用户\n * 商品\n * 收货人\n * 收货地址\n * 收货时间\n * 订单状态\n\n# 优惠券\n\n\n# 典型问题\n\n秒杀活动\n\n超卖",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"短地址服务",frontmatter:{title:"短地址服务",date:"2021-11-08T08:15:33.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/c72587/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1.html",relativePath:"03.设计/01.架构/99.解决方案/短地址服务.md",key:"v-fd8744e6",path:"/pages/c72587/",headers:[{level:2,title:"步骤一、需求分析",slug:"步骤一、需求分析",normalizedTitle:"步骤一、需求分析",charIndex:199},{level:3,title:"用例",slug:"用例",normalizedTitle:"用例",charIndex:233},{level:4,title:"问题范围",slug:"问题范围",normalizedTitle:"问题范围",charIndex:258},{level:4,title:"超出范畴的用例",slug:"超出范畴的用例",normalizedTitle:"超出范畴的用例",charIndex:464},{level:3,title:"约束和假设",slug:"约束和假设",normalizedTitle:"约束和假设",charIndex:567},{level:4,title:"状态假设",slug:"状态假设",normalizedTitle:"状态假设",charIndex:576},{level:4,title:"性能估算",slug:"性能估算",normalizedTitle:"性能估算",charIndex:717},{level:2,title:"步骤二、顶层设计",slug:"步骤二、顶层设计",normalizedTitle:"步骤二、顶层设计",charIndex:1211},{level:2,title:"步骤三、核心组件设计",slug:"步骤三、核心组件设计",normalizedTitle:"步骤三、核心组件设计",charIndex:1249},{level:3,title:"用例：用户输入一段文本，然后得到一个随机生成的链接",slug:"用例-用户输入一段文本-然后得到一个随机生成的链接",normalizedTitle:"用例：用户输入一段文本，然后得到一个随机生成的链接",charIndex:1280},{level:3,title:"用例：用户输入一个 paste 的 url 后可以看到它存储的内容",slug:"用例-用户输入一个-paste-的-url-后可以看到它存储的内容",normalizedTitle:"用例：用户输入一个 paste 的 url 后可以看到它存储的内容",charIndex:3061},{level:3,title:"用例： 服务跟踪分析页面",slug:"用例-服务跟踪分析页面",normalizedTitle:"用例： 服务跟踪分析页面",charIndex:3483},{level:3,title:"用例： 服务删除过期的 pastes",slug:"用例-服务删除过期的-pastes",normalizedTitle:"用例： 服务删除过期的 pastes",charIndex:4334},{level:2,title:"步骤四、扩展设计",slug:"步骤四、扩展设计",normalizedTitle:"步骤四、扩展设计",charIndex:4439},{level:2,title:"额外的话题",slug:"额外的话题",normalizedTitle:"额外的话题",charIndex:5365},{level:3,title:"NoSQL",slug:"nosql",normalizedTitle:"nosql",charIndex:1417},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:4896},{level:3,title:"异步和微服务",slug:"异步和微服务",normalizedTitle:"异步和微服务",charIndex:5627},{level:3,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:3043},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:5753},{level:3,title:"延迟数字",slug:"延迟数字",normalizedTitle:"延迟数字",charIndex:5767},{level:3,title:"持续进行",slug:"持续进行",normalizedTitle:"持续进行",charIndex:5794}],headersStr:"步骤一、需求分析 用例 问题范围 超出范畴的用例 约束和假设 状态假设 性能估算 步骤二、顶层设计 步骤三、核心组件设计 用例：用户输入一段文本，然后得到一个随机生成的链接 用例：用户输入一个 paste 的 url 后可以看到它存储的内容 用例： 服务跟踪分析页面 用例： 服务删除过期的 pastes 步骤四、扩展设计 额外的话题 NoSQL 缓存 异步和微服务 通信 安全 延迟数字 持续进行",content:'# 设计 Pastebin.com (或者 Bit.ly)\n\n> 本文搬运自 设计 Pastebin.com (或者 Bit.ly)\n\n注意: 为了避免重复，当前文档会直接链接到系统设计主题的相关区域，请参考链接内容以获得综合的讨论点、权衡和替代方案。\n\n设计 Bit.ly - 是一个类似的问题，区别是 pastebin 需要存储的是 paste 的内容，而不是原始的未短化的 url。\n\n\n# 步骤一、需求分析\n\n> 收集这个问题的需求和范畴。 问相关问题来明确用例和约束。 讨论一些假设。\n\n\n# 用例\n\n# 问题范围\n\n * 用户 输入一段文本，然后得到一个随机生成的链接\n   * 过期设置\n     * 默认的设置是不会过期的\n     * 可以选择设置一个过期的时间\n * 用户 输入一个 paste 的 url 后，可以看到它存储的内容\n * 用户 是匿名的\n * Service 跟踪页面分析\n   * 一个月的访问统计\n * Service 删除过期的 pastes\n * Service 需要高可用\n\n# 超出范畴的用例\n\n * 用户 可以注册一个账户\n   * 用户 通过验证邮箱\n * 用户 可以用注册的账户登录\n   * 用户 可以编辑文档\n * 用户 可以设置可见性\n * 用户 可以设置短链接\n\n\n# 约束和假设\n\n# 状态假设\n\n * 访问流量不是均匀分布的\n * 打开一个短链接应该是很快的\n * pastes 只能是文本\n * 页面访问分析数据可以不用实时\n * 一千万的用户量\n * 每个月一千万的 paste 写入量\n * 每个月一亿的 paste 读取量\n * 读写比例在 10:1\n\n# 性能估算\n\n * 每个 paste 的大小\n   * 每一个 paste 1 KB\n   * shortlink - 7 bytes\n   * expiration_length_in_minutes - 4 bytes\n   * created_at - 5 bytes\n   * paste_path - 255 bytes\n   * 总共 = ~1.27 KB\n * 每个月新的 paste 内容在 12.7GB\n   * (1.27 * 10000000)KB / 月的 paste\n   * 三年内将近 450GB 的新 paste 内容\n   * 三年内 3.6 亿短链接\n   * 假设大部分都是新的 paste，而不是需要更新已存在的 paste\n * 平均 4paste/s 的写入速度\n * 平均 40paste/s 的读取速度\n\n简单的转换指南:\n\n * 2.5 百万 req/s\n * 1 req/s = 2.5 百万 req/month\n * 40 req/s = 1 亿 req/month\n * 400 req/s = 10 亿 req/month\n\n\n# 步骤二、顶层设计\n\n> 概述一个包括所有重要的组件的高层次设计\n\n\n\n\n# 步骤三、核心组件设计\n\n> 深入每一个核心组件的细节\n\n\n# 用例：用户输入一段文本，然后得到一个随机生成的链接\n\n我们可以用一个 关系型数据库作为一个大的哈希表，用来把生成的 url 映射到一个包含 paste 文件的文件服务器和路径上。\n\n为了避免托管一个文件服务器，我们可以用一个托管的对象存储，比如 Amazon 的 S3 或者NoSQL 文档类型存储。\n\n作为一个大的哈希表的关系型数据库的替代方案，我们可以用NoSQL 键值存储。我们需要讨论选择 SQL 或 NoSQL 之间的权衡。下面的讨论是使用关系型数据库方法。\n\n * 客户端 发送一个创建 paste 的请求到作为一个反向代理启动的 Web 服务器。\n * Web 服务器 转发请求给 写接口 服务器\n * 写接口 服务器执行如下操作：\n   * 生成一个唯一的 url\n     * 检查这个 url 在 SQL 数据库 里面是否是唯一的\n     * 如果这个 url 不是唯一的，生成另外一个 url\n     * 如果我们支持自定义 url，我们可以使用用户提供的 url（也需要检查是否重复）\n   * 把生成的 url 存储到 SQL 数据库 的 pastes 表里面\n   * 存储 paste 的内容数据到 对象存储 里面\n   * 返回生成的 url\n\n向面试官阐明你需要写多少代码\n\npastes 表可以有如下结构：\n\nshortlink char(7) NOT NULL\nexpiration_length_in_minutes int NOT NULL\ncreated_at datetime NOT NULL\npaste_path varchar(255) NOT NULL\nPRIMARY KEY(shortlink)\n\n\n我们将在 shortlink 字段和 created_at 字段上创建一个数据库索引，用来提高查询的速度（避免因为扫描全表导致的长时间查询）并将数据保存在内存中，从内存里面顺序读取 1MB 的数据需要大概 250 微秒，而从 SSD 上读取则需要花费 4 倍的时间，从硬盘上则需要花费 80 倍的时间。 1\n\n为了生成唯一的 url，我们可以：\n\n * 使用 MD5 来哈希用户的 IP 地址 + 时间戳\n   * MD5 是一个普遍用来生成一个 128-bit 长度的哈希值的一种哈希方法\n   * MD5 是一致分布的\n   * 或者我们也可以用 MD5 哈希一个随机生成的数据\n * 用 Base 62 编码 MD5 哈希值\n   * 对于 urls，使用 Base 62 编码 [a-zA-Z0-9] 是比较合适的\n   * 对于每一个原始输入只会有一个 hash 结果，Base 62 是确定的（不涉及随机性）\n   * Base 64 是另外一个流行的编码方案，但是对于 urls，会因为额外的 + 和 - 字符串而产生一些问题\n   * 以下 Base 62 伪代码 执行的时间复杂度是 O(k)，k 是数字的数量 = 7：\n\ndef base_encode(num, base=62):\n    digits = []\n    while num > 0\n      remainder = modulo(num, base)\n      digits.push(remainder)\n      num = divide(num, base)\n    digits = digits.reverse\n\n\n * 取输出的前 7 个字符，结果会有 62^7 个可能的值，应该足以满足在 3 年内处理 3.6 亿个短链接的约束：\n\nurl = base_encode(md5(ip_address+timestamp))[:URL_LENGTH]\n\n\n我们将会用一个公开的 REST 风格接口：\n\n$ curl -X POST --data \'{"expiration_length_in_minutes":"60", \\"paste_contents":"Hello World!"}\' https://pastebin.com/api/v1/paste\n\n\nResponse:\n\n{\n  "shortlink": "foobar"\n}\n\n\n用于内部通信，我们可以用 RPC。\n\n\n# 用例：用户输入一个 paste 的 url 后可以看到它存储的内容\n\n * 客户端 发送一个获取 paste 请求到 Web Server\n * Web Server 转发请求给 读取接口 服务器\n * 读取接口 服务器执行如下操作：\n   * 在 SQL 数据库 检查这个生成的 url\n     * 如果这个 url 在 SQL 数据库 里面，则从 对象存储 获取这个 paste 的内容\n     * 否则，返回一个错误页面给用户\n\nREST API：\n\ncurl https://pastebin.com/api/v1/paste?shortlink=foobar\n\n\nResponse:\n\n{\n  "paste_contents": "Hello World",\n  "created_at": "YYYY-MM-DD HH:MM:SS",\n  "expiration_length_in_minutes": "60"\n}\n\n\n\n# 用例： 服务跟踪分析页面\n\n因为实时分析不是必须的，所以我们可以简单的 MapReduce Web Server 的日志，用来生成点击次数。\n\nclass HitCounts(MRJob):\n\n    def extract_url(self, line):\n        """Extract the generated url from the log line."""\n        ...\n\n    def extract_year_month(self, line):\n        """Return the year and month portions of the timestamp."""\n        ...\n\n    def mapper(self, _, line):\n        """Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        """\n        url = self.extract_url(line)\n        period = self.extract_year_month(line)\n        yield (period, url), 1\n\n    def reducer(self, key, values):\n        """Sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        """\n        yield key, sum(values)\n\n\n\n# 用例： 服务删除过期的 pastes\n\n为了删除过期的 pastes，我们可以直接搜索 SQL 数据库 中所有的过期时间比当前时间更早的记录， 所有过期的记录将从这张表里面删除（或者将其标记为过期）。\n\n\n# 步骤四、扩展设计\n\n> 给定约束条件，识别和解决瓶颈。\n\n\n\n重要提示: 不要简单的从最初的设计直接跳到最终的设计\n\n说明您将迭代地执行这样的操作：1)Benchmark/Load 测试，2)Profile 出瓶颈，3)在评估替代方案和权衡时解决瓶颈，4)重复前面，可以参考在 AWS 上设计一个可以支持百万用户的系统这个用来解决如何迭代地扩展初始设计的例子。\n\n重要的是讨论在初始设计中可能遇到的瓶颈，以及如何解决每个瓶颈。比如，在多个 Web 服务器 上添加 负载平衡器 可以解决哪些问题？ CDN 解决哪些问题？Master-Slave Replicas 解决哪些问题? 替代方案是什么和怎么对每一个替代方案进行权衡比较？\n\n我们将介绍一些组件来完成设计，并解决可伸缩性问题。内部的负载平衡器并不能减少杂乱。\n\n为了避免重复的讨论， 参考以下系统设计主题获取主要讨论要点、权衡和替代方案：\n\n * DNS\n * CDN\n * 负载均衡器\n * 水平扩展\n * 反向代理（web 服务器）\n * 应用层\n * 缓存\n * 关系型数据库管理系统 (RDBMS)\n * SQL write master-slave failover\n * 主从复制\n * 一致性模式\n * 可用性模式\n\n分析存储数据库 可以用比如 Amazon Redshift 或者 Google BigQuery 这样的数据仓库解决方案。\n\n一个像 Amazon S3 这样的 对象存储，可以轻松处理每月 12.7 GB 的新内容约束。\n\n要处理 平均 每秒 40 读请求(峰值更高)，其中热点内容的流量应该由 内存缓存 处理，而不是数据库。内存缓存 对于处理分布不均匀的流量和流量峰值也很有用。只要副本没有陷入复制写的泥潭，SQL Read Replicas 应该能够处理缓存丢失。\n\n对于单个 SQL Write Master-Slave，平均 每秒 4paste 写入 (峰值更高) 应该是可以做到的。否则，我们需要使用额外的 SQL 扩展模式:\n\n * 联合\n * 分片\n * 非规范化\n * SQL 调优\n\n我们还应该考虑将一些数据移动到 NoSQL 数据库。\n\n\n# 额外的话题\n\n> 是否更深入探讨额外主题，取决于问题的范围和面试剩余的时间。\n\n\n# NoSQL\n\n * 键值存储\n * 文档存储\n * 列型存储\n * 图数据库\n * sql 还是 nosql\n\n\n# 缓存\n\n * 在哪缓存\n   * 客户端缓存\n   * CDN 缓存\n   * Web 服务器缓存\n   * 数据库缓存\n   * 应用缓存\n * 缓存什么\n   * 数据库查询级别的缓存\n   * 对象级别的缓存\n * 何时更新缓存\n   * 缓存模式\n   * 直写模式\n   * 回写模式\n   * 刷新\n\n\n# 异步和微服务\n\n * 消息队列\n * 任务队列\n * 背压\n * 微服务\n\n\n# 通信\n\n * 讨论权衡:\n   * 跟客户端之间的外部通信 - HTTP APIs following REST\n   * 内部通信 - RPC\n * 服务发现\n\n\n# 安全\n\n参考安全。\n\n\n# 延迟数字\n\n见每个程序员都应该知道的延迟数。\n\n\n# 持续进行\n\n * 继续对系统进行基准测试和监控，以在瓶颈出现时解决它们\n * 扩展是一个迭代的过程',normalizedContent:'# 设计 pastebin.com (或者 bit.ly)\n\n> 本文搬运自 设计 pastebin.com (或者 bit.ly)\n\n注意: 为了避免重复，当前文档会直接链接到系统设计主题的相关区域，请参考链接内容以获得综合的讨论点、权衡和替代方案。\n\n设计 bit.ly - 是一个类似的问题，区别是 pastebin 需要存储的是 paste 的内容，而不是原始的未短化的 url。\n\n\n# 步骤一、需求分析\n\n> 收集这个问题的需求和范畴。 问相关问题来明确用例和约束。 讨论一些假设。\n\n\n# 用例\n\n# 问题范围\n\n * 用户 输入一段文本，然后得到一个随机生成的链接\n   * 过期设置\n     * 默认的设置是不会过期的\n     * 可以选择设置一个过期的时间\n * 用户 输入一个 paste 的 url 后，可以看到它存储的内容\n * 用户 是匿名的\n * service 跟踪页面分析\n   * 一个月的访问统计\n * service 删除过期的 pastes\n * service 需要高可用\n\n# 超出范畴的用例\n\n * 用户 可以注册一个账户\n   * 用户 通过验证邮箱\n * 用户 可以用注册的账户登录\n   * 用户 可以编辑文档\n * 用户 可以设置可见性\n * 用户 可以设置短链接\n\n\n# 约束和假设\n\n# 状态假设\n\n * 访问流量不是均匀分布的\n * 打开一个短链接应该是很快的\n * pastes 只能是文本\n * 页面访问分析数据可以不用实时\n * 一千万的用户量\n * 每个月一千万的 paste 写入量\n * 每个月一亿的 paste 读取量\n * 读写比例在 10:1\n\n# 性能估算\n\n * 每个 paste 的大小\n   * 每一个 paste 1 kb\n   * shortlink - 7 bytes\n   * expiration_length_in_minutes - 4 bytes\n   * created_at - 5 bytes\n   * paste_path - 255 bytes\n   * 总共 = ~1.27 kb\n * 每个月新的 paste 内容在 12.7gb\n   * (1.27 * 10000000)kb / 月的 paste\n   * 三年内将近 450gb 的新 paste 内容\n   * 三年内 3.6 亿短链接\n   * 假设大部分都是新的 paste，而不是需要更新已存在的 paste\n * 平均 4paste/s 的写入速度\n * 平均 40paste/s 的读取速度\n\n简单的转换指南:\n\n * 2.5 百万 req/s\n * 1 req/s = 2.5 百万 req/month\n * 40 req/s = 1 亿 req/month\n * 400 req/s = 10 亿 req/month\n\n\n# 步骤二、顶层设计\n\n> 概述一个包括所有重要的组件的高层次设计\n\n\n\n\n# 步骤三、核心组件设计\n\n> 深入每一个核心组件的细节\n\n\n# 用例：用户输入一段文本，然后得到一个随机生成的链接\n\n我们可以用一个 关系型数据库作为一个大的哈希表，用来把生成的 url 映射到一个包含 paste 文件的文件服务器和路径上。\n\n为了避免托管一个文件服务器，我们可以用一个托管的对象存储，比如 amazon 的 s3 或者nosql 文档类型存储。\n\n作为一个大的哈希表的关系型数据库的替代方案，我们可以用nosql 键值存储。我们需要讨论选择 sql 或 nosql 之间的权衡。下面的讨论是使用关系型数据库方法。\n\n * 客户端 发送一个创建 paste 的请求到作为一个反向代理启动的 web 服务器。\n * web 服务器 转发请求给 写接口 服务器\n * 写接口 服务器执行如下操作：\n   * 生成一个唯一的 url\n     * 检查这个 url 在 sql 数据库 里面是否是唯一的\n     * 如果这个 url 不是唯一的，生成另外一个 url\n     * 如果我们支持自定义 url，我们可以使用用户提供的 url（也需要检查是否重复）\n   * 把生成的 url 存储到 sql 数据库 的 pastes 表里面\n   * 存储 paste 的内容数据到 对象存储 里面\n   * 返回生成的 url\n\n向面试官阐明你需要写多少代码\n\npastes 表可以有如下结构：\n\nshortlink char(7) not null\nexpiration_length_in_minutes int not null\ncreated_at datetime not null\npaste_path varchar(255) not null\nprimary key(shortlink)\n\n\n我们将在 shortlink 字段和 created_at 字段上创建一个数据库索引，用来提高查询的速度（避免因为扫描全表导致的长时间查询）并将数据保存在内存中，从内存里面顺序读取 1mb 的数据需要大概 250 微秒，而从 ssd 上读取则需要花费 4 倍的时间，从硬盘上则需要花费 80 倍的时间。 1\n\n为了生成唯一的 url，我们可以：\n\n * 使用 md5 来哈希用户的 ip 地址 + 时间戳\n   * md5 是一个普遍用来生成一个 128-bit 长度的哈希值的一种哈希方法\n   * md5 是一致分布的\n   * 或者我们也可以用 md5 哈希一个随机生成的数据\n * 用 base 62 编码 md5 哈希值\n   * 对于 urls，使用 base 62 编码 [a-za-z0-9] 是比较合适的\n   * 对于每一个原始输入只会有一个 hash 结果，base 62 是确定的（不涉及随机性）\n   * base 64 是另外一个流行的编码方案，但是对于 urls，会因为额外的 + 和 - 字符串而产生一些问题\n   * 以下 base 62 伪代码 执行的时间复杂度是 o(k)，k 是数字的数量 = 7：\n\ndef base_encode(num, base=62):\n    digits = []\n    while num > 0\n      remainder = modulo(num, base)\n      digits.push(remainder)\n      num = divide(num, base)\n    digits = digits.reverse\n\n\n * 取输出的前 7 个字符，结果会有 62^7 个可能的值，应该足以满足在 3 年内处理 3.6 亿个短链接的约束：\n\nurl = base_encode(md5(ip_address+timestamp))[:url_length]\n\n\n我们将会用一个公开的 rest 风格接口：\n\n$ curl -x post --data \'{"expiration_length_in_minutes":"60", \\"paste_contents":"hello world!"}\' https://pastebin.com/api/v1/paste\n\n\nresponse:\n\n{\n  "shortlink": "foobar"\n}\n\n\n用于内部通信，我们可以用 rpc。\n\n\n# 用例：用户输入一个 paste 的 url 后可以看到它存储的内容\n\n * 客户端 发送一个获取 paste 请求到 web server\n * web server 转发请求给 读取接口 服务器\n * 读取接口 服务器执行如下操作：\n   * 在 sql 数据库 检查这个生成的 url\n     * 如果这个 url 在 sql 数据库 里面，则从 对象存储 获取这个 paste 的内容\n     * 否则，返回一个错误页面给用户\n\nrest api：\n\ncurl https://pastebin.com/api/v1/paste?shortlink=foobar\n\n\nresponse:\n\n{\n  "paste_contents": "hello world",\n  "created_at": "yyyy-mm-dd hh:mm:ss",\n  "expiration_length_in_minutes": "60"\n}\n\n\n\n# 用例： 服务跟踪分析页面\n\n因为实时分析不是必须的，所以我们可以简单的 mapreduce web server 的日志，用来生成点击次数。\n\nclass hitcounts(mrjob):\n\n    def extract_url(self, line):\n        """extract the generated url from the log line."""\n        ...\n\n    def extract_year_month(self, line):\n        """return the year and month portions of the timestamp."""\n        ...\n\n    def mapper(self, _, line):\n        """parse each log line, extract and transform relevant lines.\n\n        emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        """\n        url = self.extract_url(line)\n        period = self.extract_year_month(line)\n        yield (period, url), 1\n\n    def reducer(self, key, values):\n        """sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        """\n        yield key, sum(values)\n\n\n\n# 用例： 服务删除过期的 pastes\n\n为了删除过期的 pastes，我们可以直接搜索 sql 数据库 中所有的过期时间比当前时间更早的记录， 所有过期的记录将从这张表里面删除（或者将其标记为过期）。\n\n\n# 步骤四、扩展设计\n\n> 给定约束条件，识别和解决瓶颈。\n\n\n\n重要提示: 不要简单的从最初的设计直接跳到最终的设计\n\n说明您将迭代地执行这样的操作：1)benchmark/load 测试，2)profile 出瓶颈，3)在评估替代方案和权衡时解决瓶颈，4)重复前面，可以参考在 aws 上设计一个可以支持百万用户的系统这个用来解决如何迭代地扩展初始设计的例子。\n\n重要的是讨论在初始设计中可能遇到的瓶颈，以及如何解决每个瓶颈。比如，在多个 web 服务器 上添加 负载平衡器 可以解决哪些问题？ cdn 解决哪些问题？master-slave replicas 解决哪些问题? 替代方案是什么和怎么对每一个替代方案进行权衡比较？\n\n我们将介绍一些组件来完成设计，并解决可伸缩性问题。内部的负载平衡器并不能减少杂乱。\n\n为了避免重复的讨论， 参考以下系统设计主题获取主要讨论要点、权衡和替代方案：\n\n * dns\n * cdn\n * 负载均衡器\n * 水平扩展\n * 反向代理（web 服务器）\n * 应用层\n * 缓存\n * 关系型数据库管理系统 (rdbms)\n * sql write master-slave failover\n * 主从复制\n * 一致性模式\n * 可用性模式\n\n分析存储数据库 可以用比如 amazon redshift 或者 google bigquery 这样的数据仓库解决方案。\n\n一个像 amazon s3 这样的 对象存储，可以轻松处理每月 12.7 gb 的新内容约束。\n\n要处理 平均 每秒 40 读请求(峰值更高)，其中热点内容的流量应该由 内存缓存 处理，而不是数据库。内存缓存 对于处理分布不均匀的流量和流量峰值也很有用。只要副本没有陷入复制写的泥潭，sql read replicas 应该能够处理缓存丢失。\n\n对于单个 sql write master-slave，平均 每秒 4paste 写入 (峰值更高) 应该是可以做到的。否则，我们需要使用额外的 sql 扩展模式:\n\n * 联合\n * 分片\n * 非规范化\n * sql 调优\n\n我们还应该考虑将一些数据移动到 nosql 数据库。\n\n\n# 额外的话题\n\n> 是否更深入探讨额外主题，取决于问题的范围和面试剩余的时间。\n\n\n# nosql\n\n * 键值存储\n * 文档存储\n * 列型存储\n * 图数据库\n * sql 还是 nosql\n\n\n# 缓存\n\n * 在哪缓存\n   * 客户端缓存\n   * cdn 缓存\n   * web 服务器缓存\n   * 数据库缓存\n   * 应用缓存\n * 缓存什么\n   * 数据库查询级别的缓存\n   * 对象级别的缓存\n * 何时更新缓存\n   * 缓存模式\n   * 直写模式\n   * 回写模式\n   * 刷新\n\n\n# 异步和微服务\n\n * 消息队列\n * 任务队列\n * 背压\n * 微服务\n\n\n# 通信\n\n * 讨论权衡:\n   * 跟客户端之间的外部通信 - http apis following rest\n   * 内部通信 - rpc\n * 服务发现\n\n\n# 安全\n\n参考安全。\n\n\n# 延迟数字\n\n见每个程序员都应该知道的延迟数。\n\n\n# 持续进行\n\n * 继续对系统进行基准测试和监控，以在瓶颈出现时解决它们\n * 扩展是一个迭代的过程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"秒杀系统设计",frontmatter:{title:"秒杀系统设计",date:"2018-07-05T15:11:00.000Z",categories:["设计","架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/a963f0/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/99.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",relativePath:"03.设计/01.架构/99.解决方案/秒杀系统设计.md",key:"v-8da1bcae",path:"/pages/a963f0/",headers:[{level:2,title:"秒杀系统的难点",slug:"秒杀系统的难点",normalizedTitle:"秒杀系统的难点",charIndex:36},{level:2,title:"秒杀系统的思考",slug:"秒杀系统的思考",normalizedTitle:"秒杀系统的思考",charIndex:443},{level:3,title:"稳准快",slug:"稳准快",normalizedTitle:"稳准快",charIndex:455},{level:2,title:"前端优化",slug:"前端优化",normalizedTitle:"前端优化",charIndex:589},{level:3,title:"静态页面",slug:"静态页面",normalizedTitle:"静态页面",charIndex:598},{level:3,title:"按钮控制",slug:"按钮控制",normalizedTitle:"按钮控制",charIndex:790},{level:2,title:"后端优化",slug:"后端优化",normalizedTitle:"后端优化",charIndex:849},{level:3,title:"隔离",slug:"隔离",normalizedTitle:"隔离",charIndex:858},{level:3,title:"限流、熔断、降级、隔离",slug:"限流、熔断、降级、隔离",normalizedTitle:"限流、熔断、降级、隔离",charIndex:947},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:647},{level:3,title:"流量削峰",slug:"流量削峰",normalizedTitle:"流量削峰",charIndex:1141},{level:3,title:"减库存",slug:"减库存",normalizedTitle:"减库存",charIndex:527},{level:4,title:"恶意下单",slug:"恶意下单",normalizedTitle:"恶意下单",charIndex:1282},{level:4,title:"避免超卖",slug:"避免超卖",normalizedTitle:"避免超卖",charIndex:1361},{level:3,title:"URL 动态化",slug:"url-动态化",normalizedTitle:"url 动态化",charIndex:1776},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1843}],headersStr:"秒杀系统的难点 秒杀系统的思考 稳准快 前端优化 静态页面 按钮控制 后端优化 隔离 限流、熔断、降级、隔离 缓存 流量削峰 减库存 恶意下单 避免超卖 URL 动态化 参考资料",content:"# 秒杀系统设计\n\n秒杀系统所要应对的场景就是：瞬时海量请求。\n\n\n# 秒杀系统的难点\n\n * 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二：\n   * 并发读：主要是读取剩余库存量以及商品信息\n   * 并发写：主要是下单后，系统写入订单记录\n * 超卖：秒杀系统中售卖的商品一般都是性价比很高，不怎么赚钱，甚至赔钱赚哟喝的商品。一旦出现超卖现象，会给商家带来巨大的经济损失。从系统层面来看，比如某秒杀商品本来库存 100 件，但是在高并发场景下，瞬时下单量超过 100 件，处理不当，让这些下单都成功了，就会出现超卖。\n * 恶意请求：有些人为了低价购入秒杀商品，通过在多台机器上跑脚本，模拟大量用户抢商品的请求（走自己的路，让别人无路可走）。\n * 数据库崩溃：海量请求下，如果没有 MQ 削峰，没有过载保护，让所有请求都打到数据库，那么数据库基本就挂了。数据库如果挂了，也会波及其他业务，从而可能让整个系统、网站陷入瘫痪。\n * 对现有业务造成冲击\n\n\n# 秒杀系统的思考\n\n\n# 稳准快\n\n秒杀系统架构的思考角度可以概括为：稳、准、快\n\n * 稳（高可用）：系统架构要满足高可用，系统要能撑住活动。\n * 准（一致性）：商品减库存方式非常关键，不能出现超卖。\n * 快（高性能）：整个请求链路，从前端到后端，依赖组件都要做到协同优化。\n\n\n\n\n# 前端优化\n\n\n# 静态页面\n\n把秒杀商品页面静态化，减少查数据库的 IO 开销。然后，可以将这些静态页面做 CDN 缓存，如果项目是前后端分离的，还可以在反向代理服务器侧设置静态缓存。\n\n如每个商品都由 ID 来标识，那么 http://item.xxx.com/item.htm?id=xxxx 就可以作为唯一的 URL 标识。相应的页面可以提前做前端缓存，这样就不需要向后台查询商品信息。\n\n\n# 按钮控制\n\n在秒杀活动开启时间前，下单按钮禁用。\n\n此外，按钮一旦点击之后，禁用一段时间，防止有人疯狂输出。\n\n\n# 后端优化\n\n\n# 隔离\n\n秒杀活动，本质上还是一个营销活动，性质和打折、促销一样。\n\n秒杀系统设计底线原则，是不应该影响现有业务。所以，为了避免防不胜防，百密一疏的情况下，秒杀系统崩了。\n\n\n# 限流、熔断、降级、隔离\n\n * 隔离：将秒杀系统、数据与其他正常业务隔离。彼此隔离，自然互不影响。\n\n * 限流：设置阈值，超过阈值，拒绝请求。防止数据库被打死。\n\n * 降级：保证核心业务继续工作，非核心业务各安天命。\n\n * 熔断：不要影响别的系统。\n\n\n# 缓存\n\n缓存要预热，避免瞬间流量冲击。\n\n此外，防止雪崩、穿透、击穿问题的常规处理要做好。\n\n缓存也要保证高可用。\n\n\n# 流量削峰\n\n削峰的思路：排队、答题、分层过滤。\n\n * 排队：用消息队列来缓冲瞬时流量的方案。但是，消息队列自身也有上限，如果积压过多，也会处理不了。\n * 答题（摇一摇）：可以限制秒杀器并延缓请求。\n * 分层过滤：采用漏斗式的设计尽可能拦截无效请求。\n\n\n\n\n# 减库存\n\n# 恶意下单\n\n恶意下单的解决方案还是要结合安全和反作弊措施来制止：\n\n * 识别频繁下单不付款或重复下单不付款的卖家，阻断其下单。\n * 限制个人购买数\n\n# 避免超卖\n\n减库存在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：\n\nUPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END\n\n\n在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。\n\n\n# URL 动态化\n\n通过 MD5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。\n\n\n# 参考资料\n\n * 如何设计一个秒杀系统\n * 一个秒杀系统的设计思考",normalizedContent:"# 秒杀系统设计\n\n秒杀系统所要应对的场景就是：瞬时海量请求。\n\n\n# 秒杀系统的难点\n\n * 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二：\n   * 并发读：主要是读取剩余库存量以及商品信息\n   * 并发写：主要是下单后，系统写入订单记录\n * 超卖：秒杀系统中售卖的商品一般都是性价比很高，不怎么赚钱，甚至赔钱赚哟喝的商品。一旦出现超卖现象，会给商家带来巨大的经济损失。从系统层面来看，比如某秒杀商品本来库存 100 件，但是在高并发场景下，瞬时下单量超过 100 件，处理不当，让这些下单都成功了，就会出现超卖。\n * 恶意请求：有些人为了低价购入秒杀商品，通过在多台机器上跑脚本，模拟大量用户抢商品的请求（走自己的路，让别人无路可走）。\n * 数据库崩溃：海量请求下，如果没有 mq 削峰，没有过载保护，让所有请求都打到数据库，那么数据库基本就挂了。数据库如果挂了，也会波及其他业务，从而可能让整个系统、网站陷入瘫痪。\n * 对现有业务造成冲击\n\n\n# 秒杀系统的思考\n\n\n# 稳准快\n\n秒杀系统架构的思考角度可以概括为：稳、准、快\n\n * 稳（高可用）：系统架构要满足高可用，系统要能撑住活动。\n * 准（一致性）：商品减库存方式非常关键，不能出现超卖。\n * 快（高性能）：整个请求链路，从前端到后端，依赖组件都要做到协同优化。\n\n\n\n\n# 前端优化\n\n\n# 静态页面\n\n把秒杀商品页面静态化，减少查数据库的 io 开销。然后，可以将这些静态页面做 cdn 缓存，如果项目是前后端分离的，还可以在反向代理服务器侧设置静态缓存。\n\n如每个商品都由 id 来标识，那么 http://item.xxx.com/item.htm?id=xxxx 就可以作为唯一的 url 标识。相应的页面可以提前做前端缓存，这样就不需要向后台查询商品信息。\n\n\n# 按钮控制\n\n在秒杀活动开启时间前，下单按钮禁用。\n\n此外，按钮一旦点击之后，禁用一段时间，防止有人疯狂输出。\n\n\n# 后端优化\n\n\n# 隔离\n\n秒杀活动，本质上还是一个营销活动，性质和打折、促销一样。\n\n秒杀系统设计底线原则，是不应该影响现有业务。所以，为了避免防不胜防，百密一疏的情况下，秒杀系统崩了。\n\n\n# 限流、熔断、降级、隔离\n\n * 隔离：将秒杀系统、数据与其他正常业务隔离。彼此隔离，自然互不影响。\n\n * 限流：设置阈值，超过阈值，拒绝请求。防止数据库被打死。\n\n * 降级：保证核心业务继续工作，非核心业务各安天命。\n\n * 熔断：不要影响别的系统。\n\n\n# 缓存\n\n缓存要预热，避免瞬间流量冲击。\n\n此外，防止雪崩、穿透、击穿问题的常规处理要做好。\n\n缓存也要保证高可用。\n\n\n# 流量削峰\n\n削峰的思路：排队、答题、分层过滤。\n\n * 排队：用消息队列来缓冲瞬时流量的方案。但是，消息队列自身也有上限，如果积压过多，也会处理不了。\n * 答题（摇一摇）：可以限制秒杀器并延缓请求。\n * 分层过滤：采用漏斗式的设计尽可能拦截无效请求。\n\n\n\n\n# 减库存\n\n# 恶意下单\n\n恶意下单的解决方案还是要结合安全和反作弊措施来制止：\n\n * 识别频繁下单不付款或重复下单不付款的卖家，阻断其下单。\n * 限制个人购买数\n\n# 避免超卖\n\n减库存在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 sql 语句来报错；再有一种就是使用 case when 判断语句，例如这样的 sql 语句：\n\nupdate item set inventory = case when inventory >= xxx then inventory-xxx else inventory end\n\n\n在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（cache）中，可以大大提升读性能。\n\n\n# url 动态化\n\n通过 md5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。\n\n\n# 参考资料\n\n * 如何设计一个秒杀系统\n * 一个秒杀系统的设计思考",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"架构",frontmatter:{title:"架构",date:"2019-03-08T13:16:53.000Z",categories:["设计","架构"],tags:["架构"],permalink:"/pages/d9e5d2/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84/",relativePath:"03.设计/01.架构/README.md",key:"v-4bd3e31c",path:"/pages/d9e5d2/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:470},{level:3,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:103},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:597},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:565},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:655},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1045}],headersStr:"📖 内容 综合 微服务 安全 📚 资料 🚪 传送",content:"# 架构\n\n架构设计的目的是解决软件系统的复杂度带来的问题。架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体(人，财，物，时间，事情等)。架构无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。\n\n架构设计原则：合适原则、简单原则、演化原则。合适优于先进 => 演化优于一步到位 => 简单优于复杂\n\n架构设计有业务需求驱动，需要识别出主要问题，然后根据业务、技术、团队、成本等综合评估排序，优先解决当前面临的最主要的复杂度问题。\n\n架构设计一般要给出多套备选方案（3 ~ 5 个最佳），并评估各方案利弊。\n\n评估方案时，应该先列出关注的维度（如：功能性、性能、可用性、复杂度、硬件成本、运维成本等），然后根据这些维度去评估打分，再综合挑选最合适当时情况的方案。\n\n架构失败的主因：\n\n * 没那么多人，却想干那么多活\n * 没有那么多积累，却想一步登天\n * 没有那么卓越的业务场景，却幻想灵光一闪成为天才\n\n\n# 📖 内容\n\n\n# 综合\n\n * 如何设计系统\n * 系统架构面试总结\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 系统测试架构\n\n\n# 微服务\n\n * 微服务简介\n * 微服务基本原理\n\n\n# 安全\n\n * 认证和授权\n * OAuth2.0\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《大型网站系统与 Java 中间件实践》\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 《企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战》 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 《逆流而上：阿里巴巴技术成长之路》 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * RPC 实战与核心原理\n   * 微服务架构核心 20 讲\n   * DDD 实战课\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 架构\n\n架构设计的目的是解决软件系统的复杂度带来的问题。架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体(人，财，物，时间，事情等)。架构无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。\n\n架构设计原则：合适原则、简单原则、演化原则。合适优于先进 => 演化优于一步到位 => 简单优于复杂\n\n架构设计有业务需求驱动，需要识别出主要问题，然后根据业务、技术、团队、成本等综合评估排序，优先解决当前面临的最主要的复杂度问题。\n\n架构设计一般要给出多套备选方案（3 ~ 5 个最佳），并评估各方案利弊。\n\n评估方案时，应该先列出关注的维度（如：功能性、性能、可用性、复杂度、硬件成本、运维成本等），然后根据这些维度去评估打分，再综合挑选最合适当时情况的方案。\n\n架构失败的主因：\n\n * 没那么多人，却想干那么多活\n * 没有那么多积累，却想一步登天\n * 没有那么卓越的业务场景，却幻想灵光一闪成为天才\n\n\n# 📖 内容\n\n\n# 综合\n\n * 如何设计系统\n * 系统架构面试总结\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 系统测试架构\n\n\n# 微服务\n\n * 微服务简介\n * 微服务基本原理\n\n\n# 安全\n\n * 认证和授权\n * oauth2.0\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《大型网站系统与 java 中间件实践》\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 《企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战》 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 《逆流而上：阿里巴巴技术成长之路》 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * rpc 实战与核心原理\n   * 微服务架构核心 20 讲\n   * ddd 实战课\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式概述",frontmatter:{title:"设计模式概述",date:"2015-01-27T16:50:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/9a2452/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html",relativePath:"03.设计/02.设计模式/00.设计模式概述.md",key:"v-33b23c84",path:"/pages/9a2452/",headers:[{level:2,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:137},{level:3,title:"创建型模式简介",slug:"创建型模式简介",normalizedTitle:"创建型模式简介",charIndex:147},{level:3,title:"创建型模式应用",slug:"创建型模式应用",normalizedTitle:"创建型模式应用",charIndex:541},{level:3,title:"创建型模式代表",slug:"创建型模式代表",normalizedTitle:"创建型模式代表",charIndex:977},{level:3,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:1132},{level:3,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:1272},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1520},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1564}],headersStr:"创建型模式 创建型模式简介 创建型模式应用 创建型模式代表 结构型模式 行为型模式 📚 资料 🚪 传送",content:"# 设计模式概述\n\n> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n\n# 创建型模式\n\n\n# 创建型模式简介\n\n创建型模式抽象了实例化的过程。它将系统与它的对象创建、结合、表示的方式分离。\n\n创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。\n\n在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。\n\n基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。\n\n创建型模式的指导思想是：\n\n * 将系统使用的具体类封装起来。\n * 隐藏这些具体类的实例创建和结合的方式。\n\n创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。\n\n * 对象创建型模式把对象创建的一部分推迟到另一个对象中。（代表模式：单例模式、建造者模式、原型模式、抽象工厂模式）\n * 类创建型模式将它对象的创建推迟到子类中。（代表模式：工厂方法模式）\n\n\n# 创建型模式应用\n\n现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。\n\n硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。\n\n另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。\n\n创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。\n\n在以下情况中，可以考虑应用创建型模式：\n\n * 一个系统需要和它的对象和产品的创建相互独立。\n * 一组相关的对象被设计为一起使用。\n * 隐藏一个类库的具体实现，仅暴露它们的接口。\n * 创建独立复杂对象的不同表示。\n * 一个类希望它的子类实现它所创建的对象。\n * 类的实例化在运行时才指定。\n * 一个类只能有一个实例，而且这个实例能在任何时候访问到。\n * 实例应该能在不修改的情况下具有可扩展性。\n\n\n# 创建型模式代表\n\n * 单例模式 (Singleton)\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n\n\n# 结构型模式\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 装饰模式 (Decorator)\n * 组合模式 (Composite)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n\n# 行为型模式\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)\n\n\n# 📚 资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 设计模式概述\n\n> 设计模式（design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n\n# 创建型模式\n\n\n# 创建型模式简介\n\n创建型模式抽象了实例化的过程。它将系统与它的对象创建、结合、表示的方式分离。\n\n创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。\n\n在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。\n\n基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。\n\n创建型模式的指导思想是：\n\n * 将系统使用的具体类封装起来。\n * 隐藏这些具体类的实例创建和结合的方式。\n\n创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。\n\n * 对象创建型模式把对象创建的一部分推迟到另一个对象中。（代表模式：单例模式、建造者模式、原型模式、抽象工厂模式）\n * 类创建型模式将它对象的创建推迟到子类中。（代表模式：工厂方法模式）\n\n\n# 创建型模式应用\n\n现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。\n\n硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。\n\n另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。\n\n创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。\n\n在以下情况中，可以考虑应用创建型模式：\n\n * 一个系统需要和它的对象和产品的创建相互独立。\n * 一组相关的对象被设计为一起使用。\n * 隐藏一个类库的具体实现，仅暴露它们的接口。\n * 创建独立复杂对象的不同表示。\n * 一个类希望它的子类实现它所创建的对象。\n * 类的实例化在运行时才指定。\n * 一个类只能有一个实例，而且这个实例能在任何时候访问到。\n * 实例应该能在不修改的情况下具有可扩展性。\n\n\n# 创建型模式代表\n\n * 单例模式 (singleton)\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n\n\n# 结构型模式\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 装饰模式 (decorator)\n * 组合模式 (composite)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n\n# 行为型模式\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)\n\n\n# 📚 资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之简单工厂模式",frontmatter:{title:"设计模式之简单工厂模式",date:"2015-06-03T09:41:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/ff930b/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/01.简单工厂模式.md",key:"v-13d9f031",path:"/pages/ff930b/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:18},{level:3,title:"简单工厂模式思想",slug:"简单工厂模式思想",normalizedTitle:"简单工厂模式思想",charIndex:25},{level:3,title:"简单工厂模式要点",slug:"简单工厂模式要点",normalizedTitle:"简单工厂模式要点",charIndex:185},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:131},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2524}],headersStr:"简介 简单工厂模式思想 简单工厂模式要点 实例 参考资料",content:"# 设计模式之简单工厂模式\n\n\n# 简介\n\n\n# 简单工厂模式思想\n\n简单工厂模式 (Simple Factory) 又叫静态工厂方法（Static Factory Method）模式。\n\n简单工厂模式通常是定义一个工厂类，这个类可以根据不同变量返回不同类的产品实例。\n\n简单工厂模式是一种对象创建型模式。但是简单工厂模式不属于23 种 Gof 设计模式之一。\n\n\n# 简单工厂模式要点\n\n优点：简单工厂模式的工厂类是整个模式的关键。其中包含了必要的逻辑判断，根据外部信息，决定究竟应该创建哪个具体类的对象。通过使用简单工厂模式，用户无需了解对象如何创建的，只要传入必要信息就可以了。\n\n缺点：工厂类集中了所有实例的创建逻辑，违背了高内聚责任分配原则。随着系统中具体产品类不断增多，势必要不断修改工厂类，不易维护和扩展。同时，这也违背了开放封闭原则。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 实例\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n对于这四种运算来说，都需要两个操作数，差别仅在于返回的结果不同。\n\n由此，我们可以抽象化它们的共性，提炼出一个父类。这个类中包含两个操作数，一个返回结果方法，这个方法期望在子类中得以实现。\n\n以下通过具体代码来说明。\n\n\n\n【Product (Operation) 】\n\n产品角色，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n\n// Product角色，所有实例所共有的公共接口\nabstract class Operation {\n    public int numA;\n    public int numB;\n    public abstract int GetResult();\n}\n\n\n【ConcreteProduct 组】\n\n具体产品角色，实现 Product 中的接口。\n\n// ConcreteProduct 角色，实现 Product 中的接口\nclass Add extends Operation {\n    @Override\n    public int GetResult() {\n        return numA + numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Sub extends Operation {\n    @Override\n    public int GetResult() {\n        return numA - numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Mul extends Operation {\n    @Override\n    public int GetResult() {\n        return numA * numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Div extends Operation {\n    @Override\n    public int GetResult() {\n        if (numB == 0) {\n            System.out.println(\"ERROR!\");\n            return -1;\n        }\n        return numA / numB;\n    }\n}\n\n\n【Factory (OperationFactory) 】\n\n工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。\n\n// 工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑\nclass OperationFactory {\n    public static Operation CreateOperation (char operate) {\n        Operation oper = null;\n        switch(operate) {\n        case '+':\n            oper = new Add();\n            break;\n        case '-':\n            oper = new Sub();\n            break;\n        case '*':\n            oper = new Mul();\n            break;\n        case '/':\n            oper = new Div();\n            break;\n        default:\n            break;\n        }\n        return oper;\n    }\n}\n\n\n【客户端】\n\npublic class SimpleFactoryPattern {\n    public static void main(String[] args) {\n        int numA = 10;\n        int numB = 3;\n        int result = 0;\n        Operation oper = OperationFactory.CreateOperation('+');\n        oper.numA = numA;\n        oper.numB = numB;\n        result = oper.GetResult();\n        System.out.println(numA + \" + \" + numB + \" = \" + result);\n    }\n}\n\n\n【输出】\n\n10 + 3 = 13\n\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》",normalizedContent:"# 设计模式之简单工厂模式\n\n\n# 简介\n\n\n# 简单工厂模式思想\n\n简单工厂模式 (simple factory) 又叫静态工厂方法（static factory method）模式。\n\n简单工厂模式通常是定义一个工厂类，这个类可以根据不同变量返回不同类的产品实例。\n\n简单工厂模式是一种对象创建型模式。但是简单工厂模式不属于23 种 gof 设计模式之一。\n\n\n# 简单工厂模式要点\n\n优点：简单工厂模式的工厂类是整个模式的关键。其中包含了必要的逻辑判断，根据外部信息，决定究竟应该创建哪个具体类的对象。通过使用简单工厂模式，用户无需了解对象如何创建的，只要传入必要信息就可以了。\n\n缺点：工厂类集中了所有实例的创建逻辑，违背了高内聚责任分配原则。随着系统中具体产品类不断增多，势必要不断修改工厂类，不易维护和扩展。同时，这也违背了开放封闭原则。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 实例\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n对于这四种运算来说，都需要两个操作数，差别仅在于返回的结果不同。\n\n由此，我们可以抽象化它们的共性，提炼出一个父类。这个类中包含两个操作数，一个返回结果方法，这个方法期望在子类中得以实现。\n\n以下通过具体代码来说明。\n\n\n\n【product (operation) 】\n\n产品角色，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n\n// product角色，所有实例所共有的公共接口\nabstract class operation {\n    public int numa;\n    public int numb;\n    public abstract int getresult();\n}\n\n\n【concreteproduct 组】\n\n具体产品角色，实现 product 中的接口。\n\n// concreteproduct 角色，实现 product 中的接口\nclass add extends operation {\n    @override\n    public int getresult() {\n        return numa + numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass sub extends operation {\n    @override\n    public int getresult() {\n        return numa - numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass mul extends operation {\n    @override\n    public int getresult() {\n        return numa * numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass div extends operation {\n    @override\n    public int getresult() {\n        if (numb == 0) {\n            system.out.println(\"error!\");\n            return -1;\n        }\n        return numa / numb;\n    }\n}\n\n\n【factory (operationfactory) 】\n\n工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。\n\n// 工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑\nclass operationfactory {\n    public static operation createoperation (char operate) {\n        operation oper = null;\n        switch(operate) {\n        case '+':\n            oper = new add();\n            break;\n        case '-':\n            oper = new sub();\n            break;\n        case '*':\n            oper = new mul();\n            break;\n        case '/':\n            oper = new div();\n            break;\n        default:\n            break;\n        }\n        return oper;\n    }\n}\n\n\n【客户端】\n\npublic class simplefactorypattern {\n    public static void main(string[] args) {\n        int numa = 10;\n        int numb = 3;\n        int result = 0;\n        operation oper = operationfactory.createoperation('+');\n        oper.numa = numa;\n        oper.numb = numb;\n        result = oper.getresult();\n        system.out.println(numa + \" + \" + numb + \" = \" + result);\n    }\n}\n\n\n【输出】\n\n10 + 3 = 13\n\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之工厂方法模式",frontmatter:{title:"设计模式之工厂方法模式",date:"2015-06-03T10:03:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/65724c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/02.工厂方法模式.md",key:"v-a097a3be",path:"/pages/65724c/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:18},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:358},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:496},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:505},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:990},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1973},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4055},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5952},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6273}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之工厂方法模式\n\n\n# 意图\n\n工厂方法模式 (Factory Method)是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 让子类决定实例化对象的类型。\n\n * 工厂模式中，增加一种产品类，就要增加一个工厂类：因为每个工厂类只能创建一种产品的实例。\n * 工厂模式遵循“开放-封闭原则”：工厂模式中，新增一种产品并不需要修改原有类，仅仅是扩展。\n\n简单工厂模式相比于工厂方法模式\n\n优点：工厂类中包含必要的逻辑判断，可根据客户端的选择条件动态实例化需要的类。对于客户端来说，去除了对具体产品的依赖。\n\n缺点：违背了开放封闭原则。 每添加一个新的产品，都需要对原有类进行修改。增加维护成本，且不易于维护。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 适用场景\n\n * 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。\n * 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。\n * 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。\n 2. 具体产品 （Concrete Products） 是产品接口的不同实现。\n 3. 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。\n\n * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。\n * 注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。\n\n 4. 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。\n\n\n# 结构代码范式\n\n【Product】\n\n定义产品对象的接口。\n\nabstract class Product {\n    public abstract void use();\n}\n\n\n【ConcreteProduct】\n\n实现 Product 接口。\n\nclass ConcreteProduct extends Product {\n    public ConcreteProduct() {\n        System.out.println("创建 ConcreteProduct 产品");\n    }\n\n    @Override\n    public void Use() {\n        System.out.println("使用 ConcreteProduct 产品");\n    }\n}\n\n\n【Creator】\n\n声明工厂方法，它会返回一个产品类型的对象。 Creator 也可以实现一个默认的工厂方法 factoryMethod() ，以返回一个默认的具体产品类型。\n\ninterface Creator {\n    public Product factoryMethod();\n}\n\n\n【ConcreteCreator】\n\n覆写 Creator 中的工厂方法 factoryMethod() 。\n\nclass ConcreteCreator implements Creator {\n    @Override\n    public Product factoryMethod() {\n        return new ConcreteProduct();\n    }\n}\n\n\n【客户端】\n\npublic class factoryMethodPattern {\n    public static void main(String[] args) {\n        Creator factory = new ConcreteCreator();\n        Product product = factory.factoryMethod();\n        product.Use();\n    }\n}\n\n\n【输出】\n\n创建 ConcreteProduct 产品\n使用 ConcreteProduct 产品\n\n\n\n# 伪代码\n\n以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。\n\n\n\n基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。\n\n如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。\n\n如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。\n\n你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。\n\n// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供\n// 该方法的实现。\nclass Dialog is\n    // 创建者还可提供一些工厂方法的默认实现。\n    abstract method createButton():Button\n\n    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务\n    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方\n    // 法并使其返回不同类型的产品来间接修改业务逻辑。\n    method render() is\n        // 调用工厂方法创建一个产品对象。\n        Button okButton = createButton()\n        // 现在使用产品。\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n\n// 具体创建者将重写工厂方法以改变其所返回的产品类型。\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n\n// 产品接口中将声明所有具体产品都必须实现的操作。\ninterface Button is\n    method render()\n    method onClick(f)\n\n// 具体产品需提供产品接口的各种实现。\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // 根据 Windows 样式渲染按钮。\n    method onClick(f) is\n        // 绑定本地操作系统点击事件。\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // 返回一个按钮的 HTML 表述。\n    method onClick(f) is\n        // 绑定网络浏览器的点击事件。\n\n\nclass Application is\n    field dialog: Dialog\n\n    // 程序根据当前配置或环境设定选择创建者的类型。\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == "Windows") then\n            dialog = new WindowsDialog()\n        else if (config.OS == "Web") then\n            dialog = new WebDialog()\n        else\n            throw new Exception("错误！未知的操作系统。")\n\n    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口\n    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子\n    // 类传递给客户端。\n    method main() is\n        this.initialize()\n        dialog.render()\n\n\n\n# 案例\n\n使用示例： 工厂方法模式在 Java 代码中得到了广泛使用。 当你需要在代码中提供高层次的灵活性时， 该模式会非常实用。\n\n核心 Java 程序库中有该模式的应用：\n\n * java.util.Calendar#getInstance()\n * java.util.ResourceBundle#getBundle()\n * java.text.NumberFormat#getInstance()\n * java.nio.charset.Charset#forName()\n * java.net.URLStreamHandlerFactory#createURLStreamHandler(String) （根据协议返回不同的单例对象）\n * java.util.EnumSet#of()\n * javax.xml.bind.JAXBContext#createMarshaller() 及其他类似的方法。\n\n识别方法： 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。\n\n还是以 简单工厂模式 里的例子来进行说明。\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n两种模式的 Product 和 ConcreteProduct 角色代码没有区别，不再赘述。\n\n差异在于 Factory 角色部分，以及客户端部分，请在代码中体会。\n\n【Creator 角色】\n\n// Creator 角色，定义返回产品实例的公共工厂方法\ninterface OperationFactory {\n    public Operation factoryMethod();\n}\n\n\n【ConcreteCreator 角色】\n\n和简单工厂模式相比，每一种产品都会有一个具体的工厂类负责生产实例。\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass AddFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Add();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass SubFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Sub();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass MulFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Mul();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass DivFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Div();\n    }\n}\n\n\n【Client 角色】\n\n与简单工厂模式中无需关注具体创建不同，工厂模式中需要指定具体工厂，以负责生产具体对应的产品。\n\n// Client 角色，需要指定具体工厂，以负责生产具体产品\npublic class factoryMethodPattern {\n    public static void main(String[] args) {\n        OperationFactory factory = new SubFactory();\n        Operation oper = factory.factoryMethod();\n        oper.numA = 3;\n        oper.numB = 2;\n        double result = oper.getResult();\n        System.out.println("result = " + result);\n    }\n}\n\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之工厂方法模式\n\n\n# 意图\n\n工厂方法模式 (factory method)是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 让子类决定实例化对象的类型。\n\n * 工厂模式中，增加一种产品类，就要增加一个工厂类：因为每个工厂类只能创建一种产品的实例。\n * 工厂模式遵循“开放-封闭原则”：工厂模式中，新增一种产品并不需要修改原有类，仅仅是扩展。\n\n简单工厂模式相比于工厂方法模式\n\n优点：工厂类中包含必要的逻辑判断，可根据客户端的选择条件动态实例化需要的类。对于客户端来说，去除了对具体产品的依赖。\n\n缺点：违背了开放封闭原则。 每添加一个新的产品，都需要对原有类进行修改。增加维护成本，且不易于维护。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 适用场景\n\n * 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。\n * 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。\n * 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 产品 （product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。\n 2. 具体产品 （concrete products） 是产品接口的不同实现。\n 3. 创建者 （creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。\n\n * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。\n * 注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。\n\n 4. 具体创建者 （concrete creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。\n\n\n# 结构代码范式\n\n【product】\n\n定义产品对象的接口。\n\nabstract class product {\n    public abstract void use();\n}\n\n\n【concreteproduct】\n\n实现 product 接口。\n\nclass concreteproduct extends product {\n    public concreteproduct() {\n        system.out.println("创建 concreteproduct 产品");\n    }\n\n    @override\n    public void use() {\n        system.out.println("使用 concreteproduct 产品");\n    }\n}\n\n\n【creator】\n\n声明工厂方法，它会返回一个产品类型的对象。 creator 也可以实现一个默认的工厂方法 factorymethod() ，以返回一个默认的具体产品类型。\n\ninterface creator {\n    public product factorymethod();\n}\n\n\n【concretecreator】\n\n覆写 creator 中的工厂方法 factorymethod() 。\n\nclass concretecreator implements creator {\n    @override\n    public product factorymethod() {\n        return new concreteproduct();\n    }\n}\n\n\n【客户端】\n\npublic class factorymethodpattern {\n    public static void main(string[] args) {\n        creator factory = new concretecreator();\n        product product = factory.factorymethod();\n        product.use();\n    }\n}\n\n\n【输出】\n\n创建 concreteproduct 产品\n使用 concreteproduct 产品\n\n\n\n# 伪代码\n\n以下示例演示了如何使用工厂方法开发跨平台 ui （用户界面） 组件， 并同时避免客户代码与具体 ui 类之间的耦合。\n\n\n\n基础对话框类使用不同的 ui 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 windows 系统中的按钮在 linux 系统中仍然是按钮。\n\n如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 windows 样式渲染按钮。\n\n如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。\n\n你可以使用此方法开发其他 ui 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。\n\n// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供\n// 该方法的实现。\nclass dialog is\n    // 创建者还可提供一些工厂方法的默认实现。\n    abstract method createbutton():button\n\n    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务\n    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方\n    // 法并使其返回不同类型的产品来间接修改业务逻辑。\n    method render() is\n        // 调用工厂方法创建一个产品对象。\n        button okbutton = createbutton()\n        // 现在使用产品。\n        okbutton.onclick(closedialog)\n        okbutton.render()\n\n\n// 具体创建者将重写工厂方法以改变其所返回的产品类型。\nclass windowsdialog extends dialog is\n    method createbutton():button is\n        return new windowsbutton()\n\nclass webdialog extends dialog is\n    method createbutton():button is\n        return new htmlbutton()\n\n\n// 产品接口中将声明所有具体产品都必须实现的操作。\ninterface button is\n    method render()\n    method onclick(f)\n\n// 具体产品需提供产品接口的各种实现。\nclass windowsbutton implements button is\n    method render(a, b) is\n        // 根据 windows 样式渲染按钮。\n    method onclick(f) is\n        // 绑定本地操作系统点击事件。\n\nclass htmlbutton implements button is\n    method render(a, b) is\n        // 返回一个按钮的 html 表述。\n    method onclick(f) is\n        // 绑定网络浏览器的点击事件。\n\n\nclass application is\n    field dialog: dialog\n\n    // 程序根据当前配置或环境设定选择创建者的类型。\n    method initialize() is\n        config = readapplicationconfigfile()\n\n        if (config.os == "windows") then\n            dialog = new windowsdialog()\n        else if (config.os == "web") then\n            dialog = new webdialog()\n        else\n            throw new exception("错误！未知的操作系统。")\n\n    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口\n    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子\n    // 类传递给客户端。\n    method main() is\n        this.initialize()\n        dialog.render()\n\n\n\n# 案例\n\n使用示例： 工厂方法模式在 java 代码中得到了广泛使用。 当你需要在代码中提供高层次的灵活性时， 该模式会非常实用。\n\n核心 java 程序库中有该模式的应用：\n\n * java.util.calendar#getinstance()\n * java.util.resourcebundle#getbundle()\n * java.text.numberformat#getinstance()\n * java.nio.charset.charset#forname()\n * java.net.urlstreamhandlerfactory#createurlstreamhandler(string) （根据协议返回不同的单例对象）\n * java.util.enumset#of()\n * javax.xml.bind.jaxbcontext#createmarshaller() 及其他类似的方法。\n\n识别方法： 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。\n\n还是以 简单工厂模式 里的例子来进行说明。\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n两种模式的 product 和 concreteproduct 角色代码没有区别，不再赘述。\n\n差异在于 factory 角色部分，以及客户端部分，请在代码中体会。\n\n【creator 角色】\n\n// creator 角色，定义返回产品实例的公共工厂方法\ninterface operationfactory {\n    public operation factorymethod();\n}\n\n\n【concretecreator 角色】\n\n和简单工厂模式相比，每一种产品都会有一个具体的工厂类负责生产实例。\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass addfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new add();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass subfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new sub();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass mulfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new mul();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass divfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new div();\n    }\n}\n\n\n【client 角色】\n\n与简单工厂模式中无需关注具体创建不同，工厂模式中需要指定具体工厂，以负责生产具体对应的产品。\n\n// client 角色，需要指定具体工厂，以负责生产具体产品\npublic class factorymethodpattern {\n    public static void main(string[] args) {\n        operationfactory factory = new subfactory();\n        operation oper = factory.factorymethod();\n        oper.numa = 3;\n        oper.numb = 2;\n        double result = oper.getresult();\n        system.out.println("result = " + result);\n    }\n}\n\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之抽象工厂模式",frontmatter:{title:"设计模式之抽象工厂模式",date:"2015-06-03T10:26:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/340aa0/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/03.抽象工厂模式.md",key:"v-3a239cb0",path:"/pages/340aa0/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:18},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:514},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:644},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:653},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:1041},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:3350},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5944},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:8014},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8408}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之抽象工厂模式\n\n\n# 意图\n\n抽象工厂模式 （Abstract Factory）是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。\n\n**优点 **\n\n * 抽象工厂模式隔离了具体类的生成，用户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。\n\n * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。\n\n * 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开放封闭原则”。\n\n缺点\n\n * 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n\n# 适用场景\n\n抽象工厂模式适用场景：\n\n一个系统要独立于它的产品的创建、组合和表示时。\n\n一个系统要由多个产品系列中的一个来配置时。\n\n当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n\n当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象产品 （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。\n 2. 具体产品 （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。\n 3. 抽象工厂 （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。\n 4. 具体工厂 （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。\n 5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。\n\n\n# 结构代码范式\n\n【AbstractProduct】\n\n声明一个接口，这个接口中包含产品对象类型。\n\nabstract class AbstractProductA {\n    public abstract void show();\n}\n\nabstract class AbstractProductB {\n    public abstract void show();\n}\n\n\n【ConcreteProduct】\n\n定义一个产品对象，这个产品对象是由相关的具体工厂创建的。\n\nclass ConcreteProductA1 extends AbstractProductA {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductA1");\n    }\n}\n\nclass ConcreteProductA2 extends AbstractProductA {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductA2");\n    }\n}\n\nclass ConcreteProductB1 extends AbstractProductB {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductB1");\n    }\n}\n\nclass ConcreteProductB2 extends AbstractProductB {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductB2");\n    }\n}\n\n\n【AbstractFactory】\n\n声明一个接口，这个接口中包含创建抽象产品对象的方法。\n\nabstract class AbstractFactory {\n    public abstract AbstractProductA createProductA();\n    public abstract AbstractProductB createProductB();\n}\n\n\n【ConcreteFactory】\n\n实现创建具体产品对象的方法。\n\nclass ConcreteFactory1 extends AbstractFactory {\n    @Override\n    public AbstractProductA createProductA() {\n        return new ConcreteProductA1();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ConcreteProductB1();\n    }\n}\n\nclass ConcreteFactory2 extends AbstractFactory {\n    @Override\n    public AbstractProductA createProductA() {\n        return new ConcreteProductA2();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ConcreteProductB2();\n    }\n}\n\n\n【客户端】\n\n只使用 AbstractFactory 和 AbstractProduct 声明的接口。\n\npublic class AbstarctFactoryPattern {\n    public static void main(String[] args) {\n        AbstractFactory  factory1  = new ConcreteFactory1();\n        AbstractProductA productA1 = factory1.createProductA();\n        AbstractProductB productB1 = factory1.createProductB();\n        productA1.show();\n        productB1.show();\n\n        AbstractFactory  factory2  = new ConcreteFactory2();\n        AbstractProductA productA2 = factory2.createProductA();\n        AbstractProductB productB2 = factory2.createProductB();\n        productA2.show();\n        productB2.show();\n    }\n}\n\n\n【输出】\n\nConcreteProductA1\nConcreteProductB1\nConcreteProductA2\nConcreteProductB2\n\n\n\n# 伪代码\n\n下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。\n\n\n\n跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。\n\n抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。\n\n其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。\n\n使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。\n\n这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。\n\n// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列\n// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产\n// 品可有多个变体，但不同变体的产品不能搭配使用。\ninterface GUIFactory is\n    method createButton():Button\n    method createCheckbox():Checkbox\n\n\n// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配\n// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进\n// 行实例化。\nclass WinFactory implements GUIFactory is\n    method createButton():Button is\n        return new WinButton()\n    method createCheckbox():Checkbox is\n        return new WinCheckbox()\n\n// 每个具体工厂中都会包含一个相应的产品变体。\nclass MacFactory implements GUIFactory is\n    method createButton():Button is\n        return new MacButton()\n    method createCheckbox():Checkbox is\n        return new MacCheckbox()\n\n\n// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。\ninterface Button is\n    method paint()\n\n// 具体产品由相应的具体工厂创建。\nclass WinButton implements Button is\n    method paint() is\n        // 根据 Windows 样式渲染按钮。\n\nclass MacButton implements Button is\n    method paint() is\n        // 根据 macOS 样式渲染按钮\n\n// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产\n// 品之间才能够正确地进行交互。\ninterface Checkbox is\n    method paint()\n\nclass WinCheckbox implements Checkbox is\n    method paint() is\n        // 根据 Windows 样式渲染复选框。\n\nclass MacCheckbox implements Checkbox is\n    method paint() is\n        // 根据 macOS 样式渲染复选框。\n\n// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂\n// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。\nclass Application is\n    private field factory: GUIFactory\n    private field button: Button\n    constructor Application(factory: GUIFactory) is\n        this.factory = factory\n    method createUI() is\n        this.button = factory.createButton()\n    method paint() is\n        button.paint()\n\n\n// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初\n// 始化阶段）。\nclass ApplicationConfigurator is\n    method main() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == "Windows") then\n            factory = new WinFactory()\n        else if (config.OS == "Mac") then\n            factory = new MacFactory()\n        else\n            throw new Exception("错误！未知的操作系统。")\n\n        Application app = new Application(factory)\n\n\n\n# 案例\n\n众所周知，苹果和三星这两家世界级的电子产品厂商都生产手机和电脑。\n\n我们以生产手机和电脑为例，演示一下抽象工厂模式的应用\n\n【AbstractProduct 角色】\n\n首先，定义手机和电脑两个抽象接口，他们都有各自的产品信息。\n\ninterface Telephone {\n    public String getProductInfo();\n}\n\ninterface Computer {\n    public String getProductInfo();\n}\n\n\n【ConcreteProduct 角色】\n\nConcreteProduct 根据 AbstractProduct 来定义具体的产品属性、方法。\n\n在我们的例子中，苹果、三星两家公司的手机和电脑都有各自的具体产品信息。\n\nclass AppleTelephone implements Telephone {\n\n    @Override\n    public String getProductInfo() {\n        return "苹果手机，采用ios系统";\n    }\n}\n\nclass SamsungTelephone implements Telephone {\n\n    @Override\n    public String getProductInfo() {\n        return "三星手机，采用android系统";\n    }\n}\n\nclass AppleComputer implements Computer {\n\n    @Override\n    public String getProductInfo() {\n        return "苹果电脑，采用mac系统";\n    }\n}\n\nclass SamsungComputer implements Computer {\n\n    @Override\n    public String getProductInfo() {\n        return "三星电脑，采用windows系统";\n    }\n}\n\n\n【AbstractFactory 角色】\n\n苹果，三星这两个厂商都生产手机和电脑。所以它们可以有一个抽象父类或父接口，提供生产手机和生产电脑的方法。\n\ninterface ElectronicFactory {\n\n    public Telephone produceTelephone();\n\n    public Computer produceComputer();\n}\n\n\n【ConcreteFactory 角色】\n\n苹果、三星工厂分别实现父接口，生产不同类型的产品。\n\nclass AppleFactory implements ElectronicFactory {\n\n    @Override\n    public Telephone produceTelephone() {\n        return new AppleTelephone();\n    }\n\n    @Override\n    public Computer produceComputer() {\n        return new AppleComputer();\n    }\n}\n\nclass SamsungFactory implements ElectronicFactory {\n\n    @Override\n    public Telephone produceTelephone() {\n        return new SamsungTelephone();\n    }\n\n    @Override\n    public Computer produceComputer() {\n        return new SamsungComputer();\n    }\n}\n\n\n【客户端】\n\npublic class PhoneFactoryDemo {\n    public static void main(String[] args) {\n        ElectronicFactory appleFactory = new AppleFactory();\n        Telephone phone = appleFactory.produceTelephone();\n        System.out.println(phone.getProductInfo());\n        Computer computer = appleFactory.produceComputer();\n        System.out.println(computer.getProductInfo());\n    }\n}\n\n\n【输出】\n\n苹果手机，采用ios系统\n苹果电脑，采用mac系统\n\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。\n * 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之抽象工厂模式\n\n\n# 意图\n\n抽象工厂模式 （abstract factory）是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。\n\n**优点 **\n\n * 抽象工厂模式隔离了具体类的生成，用户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。\n\n * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。\n\n * 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开放封闭原则”。\n\n缺点\n\n * 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n\n# 适用场景\n\n抽象工厂模式适用场景：\n\n一个系统要独立于它的产品的创建、组合和表示时。\n\n一个系统要由多个产品系列中的一个来配置时。\n\n当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n\n当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象产品 （abstract product） 为构成系列产品的一组不同但相关的产品声明接口。\n 2. 具体产品 （concrete product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。\n 3. 抽象工厂 （abstract factory） 接口声明了一组创建各种抽象产品的方法。\n 4. 具体工厂 （concrete factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。\n 5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。\n\n\n# 结构代码范式\n\n【abstractproduct】\n\n声明一个接口，这个接口中包含产品对象类型。\n\nabstract class abstractproducta {\n    public abstract void show();\n}\n\nabstract class abstractproductb {\n    public abstract void show();\n}\n\n\n【concreteproduct】\n\n定义一个产品对象，这个产品对象是由相关的具体工厂创建的。\n\nclass concreteproducta1 extends abstractproducta {\n    @override\n    public void show() {\n        system.out.println("concreteproducta1");\n    }\n}\n\nclass concreteproducta2 extends abstractproducta {\n    @override\n    public void show() {\n        system.out.println("concreteproducta2");\n    }\n}\n\nclass concreteproductb1 extends abstractproductb {\n    @override\n    public void show() {\n        system.out.println("concreteproductb1");\n    }\n}\n\nclass concreteproductb2 extends abstractproductb {\n    @override\n    public void show() {\n        system.out.println("concreteproductb2");\n    }\n}\n\n\n【abstractfactory】\n\n声明一个接口，这个接口中包含创建抽象产品对象的方法。\n\nabstract class abstractfactory {\n    public abstract abstractproducta createproducta();\n    public abstract abstractproductb createproductb();\n}\n\n\n【concretefactory】\n\n实现创建具体产品对象的方法。\n\nclass concretefactory1 extends abstractfactory {\n    @override\n    public abstractproducta createproducta() {\n        return new concreteproducta1();\n    }\n\n    @override\n    public abstractproductb createproductb() {\n        return new concreteproductb1();\n    }\n}\n\nclass concretefactory2 extends abstractfactory {\n    @override\n    public abstractproducta createproducta() {\n        return new concreteproducta2();\n    }\n\n    @override\n    public abstractproductb createproductb() {\n        return new concreteproductb2();\n    }\n}\n\n\n【客户端】\n\n只使用 abstractfactory 和 abstractproduct 声明的接口。\n\npublic class abstarctfactorypattern {\n    public static void main(string[] args) {\n        abstractfactory  factory1  = new concretefactory1();\n        abstractproducta producta1 = factory1.createproducta();\n        abstractproductb productb1 = factory1.createproductb();\n        producta1.show();\n        productb1.show();\n\n        abstractfactory  factory2  = new concretefactory2();\n        abstractproducta producta2 = factory2.createproducta();\n        abstractproductb productb2 = factory2.createproductb();\n        producta2.show();\n        productb2.show();\n    }\n}\n\n\n【输出】\n\nconcreteproducta1\nconcreteproductb1\nconcreteproducta2\nconcreteproductb2\n\n\n\n# 伪代码\n\n下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 ui 类耦合， 就能创建跨平台的 ui 元素， 同时确保所创建的元素与指定的操作系统匹配。\n\n\n\n跨平台应用中的相同 ui 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 ui 元素与当前操作系统风格一致。 你一定不希望在 windows 系统下运行的应用程序中显示 macos 的控件。\n\n抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 ui 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 ui 元素。\n\n其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 ui 元素。 这样可以避免生成错误类型的元素。\n\n使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 ui 元素。 此外， 客户端代码还支持未来添加新的工厂或 ui 元素。\n\n这样一来， 每次在应用程序中添加新的 ui 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 ui 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。\n\n// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列\n// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产\n// 品可有多个变体，但不同变体的产品不能搭配使用。\ninterface guifactory is\n    method createbutton():button\n    method createcheckbox():checkbox\n\n\n// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配\n// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进\n// 行实例化。\nclass winfactory implements guifactory is\n    method createbutton():button is\n        return new winbutton()\n    method createcheckbox():checkbox is\n        return new wincheckbox()\n\n// 每个具体工厂中都会包含一个相应的产品变体。\nclass macfactory implements guifactory is\n    method createbutton():button is\n        return new macbutton()\n    method createcheckbox():checkbox is\n        return new maccheckbox()\n\n\n// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。\ninterface button is\n    method paint()\n\n// 具体产品由相应的具体工厂创建。\nclass winbutton implements button is\n    method paint() is\n        // 根据 windows 样式渲染按钮。\n\nclass macbutton implements button is\n    method paint() is\n        // 根据 macos 样式渲染按钮\n\n// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产\n// 品之间才能够正确地进行交互。\ninterface checkbox is\n    method paint()\n\nclass wincheckbox implements checkbox is\n    method paint() is\n        // 根据 windows 样式渲染复选框。\n\nclass maccheckbox implements checkbox is\n    method paint() is\n        // 根据 macos 样式渲染复选框。\n\n// 客户端代码仅通过抽象类型（guifactory、button 和 checkbox）使用工厂\n// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。\nclass application is\n    private field factory: guifactory\n    private field button: button\n    constructor application(factory: guifactory) is\n        this.factory = factory\n    method createui() is\n        this.button = factory.createbutton()\n    method paint() is\n        button.paint()\n\n\n// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初\n// 始化阶段）。\nclass applicationconfigurator is\n    method main() is\n        config = readapplicationconfigfile()\n\n        if (config.os == "windows") then\n            factory = new winfactory()\n        else if (config.os == "mac") then\n            factory = new macfactory()\n        else\n            throw new exception("错误！未知的操作系统。")\n\n        application app = new application(factory)\n\n\n\n# 案例\n\n众所周知，苹果和三星这两家世界级的电子产品厂商都生产手机和电脑。\n\n我们以生产手机和电脑为例，演示一下抽象工厂模式的应用\n\n【abstractproduct 角色】\n\n首先，定义手机和电脑两个抽象接口，他们都有各自的产品信息。\n\ninterface telephone {\n    public string getproductinfo();\n}\n\ninterface computer {\n    public string getproductinfo();\n}\n\n\n【concreteproduct 角色】\n\nconcreteproduct 根据 abstractproduct 来定义具体的产品属性、方法。\n\n在我们的例子中，苹果、三星两家公司的手机和电脑都有各自的具体产品信息。\n\nclass appletelephone implements telephone {\n\n    @override\n    public string getproductinfo() {\n        return "苹果手机，采用ios系统";\n    }\n}\n\nclass samsungtelephone implements telephone {\n\n    @override\n    public string getproductinfo() {\n        return "三星手机，采用android系统";\n    }\n}\n\nclass applecomputer implements computer {\n\n    @override\n    public string getproductinfo() {\n        return "苹果电脑，采用mac系统";\n    }\n}\n\nclass samsungcomputer implements computer {\n\n    @override\n    public string getproductinfo() {\n        return "三星电脑，采用windows系统";\n    }\n}\n\n\n【abstractfactory 角色】\n\n苹果，三星这两个厂商都生产手机和电脑。所以它们可以有一个抽象父类或父接口，提供生产手机和生产电脑的方法。\n\ninterface electronicfactory {\n\n    public telephone producetelephone();\n\n    public computer producecomputer();\n}\n\n\n【concretefactory 角色】\n\n苹果、三星工厂分别实现父接口，生产不同类型的产品。\n\nclass applefactory implements electronicfactory {\n\n    @override\n    public telephone producetelephone() {\n        return new appletelephone();\n    }\n\n    @override\n    public computer producecomputer() {\n        return new applecomputer();\n    }\n}\n\nclass samsungfactory implements electronicfactory {\n\n    @override\n    public telephone producetelephone() {\n        return new samsungtelephone();\n    }\n\n    @override\n    public computer producecomputer() {\n        return new samsungcomputer();\n    }\n}\n\n\n【客户端】\n\npublic class phonefactorydemo {\n    public static void main(string[] args) {\n        electronicfactory applefactory = new applefactory();\n        telephone phone = applefactory.producetelephone();\n        system.out.println(phone.getproductinfo());\n        computer computer = applefactory.producecomputer();\n        system.out.println(computer.getproductinfo());\n    }\n}\n\n\n【输出】\n\n苹果手机，采用ios系统\n苹果电脑，采用mac系统\n\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。\n * 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之建造者模式",frontmatter:{title:"设计模式之建造者模式",date:"2015-06-03T10:32:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/bf03f3/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/04.建造者模式.md",key:"v-1bdc9712",path:"/pages/bf03f3/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:366},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:484},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2487},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5469},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5912},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6212}],headersStr:"意图 适用场景 结构 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之建造者模式\n\n\n# 意图\n\n建造者模式（Builder）是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n\n使用建造者模式，用户就只需要指定需要建造的类型，具体的建造过程和细节并不需要知道。\n\n建造者模式允许修改一个产品的内部表示。\n\n它将构造和表示两块代码隔离开来。\n\n它很好的控制了构建过程。\n\n\n\n建造者模式流程说明：\n\n 1. 客户端创建 Director 对象并配置它所需要的 Builder 对象。\n 2. Director 负责通知 builder 何时建造 product 的部件。\n 3. Builder 处理 director 的请求并添加 product 的部件。\n 4. 客户端从 builder 处获得 product。\n\n\n# 适用场景\n\n * 使用建造者模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。\n * 当你希望使用代码创建不同形式的产品时， 可使用建造者模式。\n * 使用建造者构造组合树或其他复杂对象。\n\n\n# 结构\n\n\n\n 1. 建造者 （Builder） 接口声明在所有类型建造者中通用的产品构造步骤。\n 2. 具体建造者 （Concrete Builders） 提供构造过程的不同实现。 具体建造者也可以构造不遵循通用接口的产品。\n 3. 产品 （Products） 是最终生成的对象。 由不同建造者构造的产品无需属于同一类层次结构或接口。\n 4. 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。\n 5. 客户端 （Client） 必须将某个建造者对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用建造者对象完成后续所有的构造任务。 但在客户端将建造者对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的建造者。\n\n【Product】产品类，由多个部件构成。\n\nclass Product {\n    List<String> parts = new ArrayList<String>();\n\n    public void AddPart(String part) {\n        parts.add(part);\n    }\n\n    public void show() {\n        System.out.println("============== 产品创建 ==============");\n        for (String part : parts) {\n            System.out.println(part);\n        }\n    }\n}\n\n\n【Builder】\n\n抽象建造者，确定产品由 ABC 三个部件构成，并声明一个得到产品建造后结果的方法 getResult。\n\ninterface Builder {\n    public void buildPartA();\n    public void buildPartB();\n    public void buildPartC();\n    public Product getResult();\n}\n\n\n【ConcreteBuilder】\n\n实现 Builder 接口中的具体方法。\n\nclass ConcreteBuilder implements Builder {\n    private Product product = new Product();\n\n    @Override\n    public void buildPartA() {\n        product.AddPart("部件A");\n    }\n\n    @Override\n    public void buildPartB() {\n        product.AddPart("部件B");\n    }\n\n    @Override\n    public void buildPartC() {\n        product.AddPart("部件C");\n    }\n\n    @Override\n    public Product getResult() {\n        return product;\n    }\n}\n\n\n【Director】\n\n指挥者类，指挥建造 Product 的过程（控制构建各部分组件的顺序）。\n\nclass Director {\n    public void construct(Builder builder) {\n        builder.buildPartC();\n        builder.buildPartA();\n        builder.buildPartB();\n    }\n}\n\n\n【客户端】\n\n用户并不需要知道具体的建造过程，只需指定建造 Product 具体类型。\n\npublic class BuilderPattern {\n    public static void main(String[] args) {\n        Director director = new Director();\n        Builder builder = new ConcreteBuilder();\n\n        director.construct(builder);\n        Product product = builder.getResult();\n        product.show();\n    }\n}\n\n\n【输出】\n\n============== 产品创建 ==============\n部件C\n部件A\n部件B\n\n\n\n# 伪代码\n\n下面关于建造者模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （Car）——及其相应的使用手册 （Manual）。\n\n\n\n// 只有当产品较为复杂且需要详细配置时，使用建造者模式才有意义。下面的两个\n// 产品尽管没有同样的接口，但却相互关联。\nclass Car is\n    // 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（\n    // 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。\n\nclass Manual is\n    // 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。\n\n\n// 建造者接口声明了创建产品对象不同部件的方法。\ninterface Builder is\n    method reset()\n    method setSeats(...)\n    method setEngine(...)\n    method setTripComputer(...)\n    method setGPS(...)\n\n// 具体建造者类将遵循建造者接口并提供生成步骤的具体实现。你的程序中可能会\n// 有多个以不同方式实现的建造者变体。\nclass CarBuilder implements Builder is\n    private field car:Car\n\n    // 一个新的建造者实例必须包含一个在后续组装过程中使用的空产品对象。\n    constructor CarBuilder() is\n        this.reset()\n\n    // reset（重置）方法可清除正在生成的对象。\n    method reset() is\n        this.car = new Car()\n\n    // 所有生成步骤都会与同一个产品实例进行交互。\n    method setSeats(...) is\n        // 设置汽车座位的数量。\n\n    method setEngine(...) is\n        // 安装指定的引擎。\n\n    method setTripComputer(...) is\n        // 安装行车电脑。\n\n    method setGPS(...) is\n        // 安装全球定位系统。\n\n    // 具体建造者需要自行提供获取结果的方法。这是因为不同类型的建造者可能\n    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在建造者接口中\n    // 声明这些方法（至少在静态类型的编程语言中是这样的）。\n    //\n    // 通常在建造者实例将结果返回给客户端后，它们应该做好生成另一个产品的\n    // 准备。因此建造者实例通常会在 `getProduct（获取产品）`方法主体末尾\n    // 调用重置方法。但是该行为并不是必需的，你也可让建造者等待客户端明确\n    // 调用重置方法后再去处理之前的结果。\n    method getProduct():Car is\n        product = this.car\n        this.reset()\n        return product\n\n// 建造者与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。\nclass CarManualBuilder implements Builder is\n    private field manual:Manual\n\n    constructor CarManualBuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new Manual()\n\n    method setSeats(...) is\n        // 添加关于汽车座椅功能的文档。\n\n    method setEngine(...) is\n        // 添加关于引擎的介绍。\n\n    method setTripComputer(...) is\n        // 添加关于行车电脑的介绍。\n\n    method setGPS(...) is\n        // 添加关于 GPS 的介绍。\n\n    method getProduct():Manual is\n        // 返回使用手册并重置建造者。\n\n\n// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时\n// 会很有帮助。由于客户端可以直接控制建造者，所以严格意义上来说，主管类并\n// 不是必需的。\nclass Director is\n    private field builder:Builder\n\n    // 主管可同由客户端代码传递给自身的任何建造者实例进行交互。客户端可通\n    // 过这种方式改变最新组装完毕的产品的最终类型。\n    method setBuilder(builder:Builder)\n        this.builder = builder\n\n    // 主管可使用同样的生成步骤创建多个产品变体。\n    method constructSportsCar(builder: Builder) is\n        builder.reset()\n        builder.setSeats(2)\n        builder.setEngine(new SportEngine())\n        builder.setTripComputer(true)\n        builder.setGPS(true)\n\n    method constructSUV(builder: Builder) is\n        // ...\n\n\n// 客户端代码会创建建造者对象并将其传递给主管，然后执行构造过程。最终结果\n// 将需要从建造者对象中获取。\nclass Application is\n\n    method makeCar() is\n        director = new Director()\n\n        CarBuilder builder = new CarBuilder()\n        director.constructSportsCar(builder)\n        Car car = builder.getProduct()\n\n        CarManualBuilder builder = new CarManualBuilder()\n        director.constructSportsCar(builder)\n\n        // 最终产品通常需要从建造者对象中获取，因为主管不知晓具体建造者和\n        // 产品的存在，也不会对其产生依赖。\n        Manual manual = builder.getProduct()\n\n\n\n# 案例\n\n使用示例： 建造者模式是 Java 世界中的一个著名模式。 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。\n\n建造者在 Java 核心程序库中得到了广泛的应用：\n\n * java.lang.StringBuilder#append() （ 非同步 ）\n * java.lang.StringBuffer#append() （ 同步 ）\n * java.nio.ByteBuffer#put() （还有 Char­Buffer、 Short­Buffer、 Int­Buffer、 Long­Buffer、 Float­Buffer 和 Double­Buffer）\n * java.lang.Appendable的所有实现\n\n识别方法： 建造者模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 建造者方法通常支持方法链 （例如 someBuilder->setValueA(1)->setValueB(2)->create() ）\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或建造者模式 （更灵活但更加复杂）。\n * 建造者重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 建造者则允许你在获取产品前执行一些额外构造步骤。\n * 你可以在创建复杂组合模式树时使用建造者， 因为这可使其构造步骤以递归的方式运行。\n * 你可以结合使用建造者和桥接模式： 主管类负责抽象工作， 各种不同的建造者负责实现工作。\n * 抽象工厂、 建造者和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之建造者模式\n\n\n# 意图\n\n建造者模式（builder）是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n\n使用建造者模式，用户就只需要指定需要建造的类型，具体的建造过程和细节并不需要知道。\n\n建造者模式允许修改一个产品的内部表示。\n\n它将构造和表示两块代码隔离开来。\n\n它很好的控制了构建过程。\n\n\n\n建造者模式流程说明：\n\n 1. 客户端创建 director 对象并配置它所需要的 builder 对象。\n 2. director 负责通知 builder 何时建造 product 的部件。\n 3. builder 处理 director 的请求并添加 product 的部件。\n 4. 客户端从 builder 处获得 product。\n\n\n# 适用场景\n\n * 使用建造者模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。\n * 当你希望使用代码创建不同形式的产品时， 可使用建造者模式。\n * 使用建造者构造组合树或其他复杂对象。\n\n\n# 结构\n\n\n\n 1. 建造者 （builder） 接口声明在所有类型建造者中通用的产品构造步骤。\n 2. 具体建造者 （concrete builders） 提供构造过程的不同实现。 具体建造者也可以构造不遵循通用接口的产品。\n 3. 产品 （products） 是最终生成的对象。 由不同建造者构造的产品无需属于同一类层次结构或接口。\n 4. 主管 （director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。\n 5. 客户端 （client） 必须将某个建造者对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用建造者对象完成后续所有的构造任务。 但在客户端将建造者对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的建造者。\n\n【product】产品类，由多个部件构成。\n\nclass product {\n    list<string> parts = new arraylist<string>();\n\n    public void addpart(string part) {\n        parts.add(part);\n    }\n\n    public void show() {\n        system.out.println("============== 产品创建 ==============");\n        for (string part : parts) {\n            system.out.println(part);\n        }\n    }\n}\n\n\n【builder】\n\n抽象建造者，确定产品由 abc 三个部件构成，并声明一个得到产品建造后结果的方法 getresult。\n\ninterface builder {\n    public void buildparta();\n    public void buildpartb();\n    public void buildpartc();\n    public product getresult();\n}\n\n\n【concretebuilder】\n\n实现 builder 接口中的具体方法。\n\nclass concretebuilder implements builder {\n    private product product = new product();\n\n    @override\n    public void buildparta() {\n        product.addpart("部件a");\n    }\n\n    @override\n    public void buildpartb() {\n        product.addpart("部件b");\n    }\n\n    @override\n    public void buildpartc() {\n        product.addpart("部件c");\n    }\n\n    @override\n    public product getresult() {\n        return product;\n    }\n}\n\n\n【director】\n\n指挥者类，指挥建造 product 的过程（控制构建各部分组件的顺序）。\n\nclass director {\n    public void construct(builder builder) {\n        builder.buildpartc();\n        builder.buildparta();\n        builder.buildpartb();\n    }\n}\n\n\n【客户端】\n\n用户并不需要知道具体的建造过程，只需指定建造 product 具体类型。\n\npublic class builderpattern {\n    public static void main(string[] args) {\n        director director = new director();\n        builder builder = new concretebuilder();\n\n        director.construct(builder);\n        product product = builder.getresult();\n        product.show();\n    }\n}\n\n\n【输出】\n\n============== 产品创建 ==============\n部件c\n部件a\n部件b\n\n\n\n# 伪代码\n\n下面关于建造者模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （car）——及其相应的使用手册 （manual）。\n\n\n\n// 只有当产品较为复杂且需要详细配置时，使用建造者模式才有意义。下面的两个\n// 产品尽管没有同样的接口，但却相互关联。\nclass car is\n    // 一辆汽车可能配备有 gps 设备、行车电脑和几个座位。不同型号的汽车（\n    // 运动型轿车、suv 和敞篷车）可能会安装或启用不同的功能。\n\nclass manual is\n    // 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。\n\n\n// 建造者接口声明了创建产品对象不同部件的方法。\ninterface builder is\n    method reset()\n    method setseats(...)\n    method setengine(...)\n    method settripcomputer(...)\n    method setgps(...)\n\n// 具体建造者类将遵循建造者接口并提供生成步骤的具体实现。你的程序中可能会\n// 有多个以不同方式实现的建造者变体。\nclass carbuilder implements builder is\n    private field car:car\n\n    // 一个新的建造者实例必须包含一个在后续组装过程中使用的空产品对象。\n    constructor carbuilder() is\n        this.reset()\n\n    // reset（重置）方法可清除正在生成的对象。\n    method reset() is\n        this.car = new car()\n\n    // 所有生成步骤都会与同一个产品实例进行交互。\n    method setseats(...) is\n        // 设置汽车座位的数量。\n\n    method setengine(...) is\n        // 安装指定的引擎。\n\n    method settripcomputer(...) is\n        // 安装行车电脑。\n\n    method setgps(...) is\n        // 安装全球定位系统。\n\n    // 具体建造者需要自行提供获取结果的方法。这是因为不同类型的建造者可能\n    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在建造者接口中\n    // 声明这些方法（至少在静态类型的编程语言中是这样的）。\n    //\n    // 通常在建造者实例将结果返回给客户端后，它们应该做好生成另一个产品的\n    // 准备。因此建造者实例通常会在 `getproduct（获取产品）`方法主体末尾\n    // 调用重置方法。但是该行为并不是必需的，你也可让建造者等待客户端明确\n    // 调用重置方法后再去处理之前的结果。\n    method getproduct():car is\n        product = this.car\n        this.reset()\n        return product\n\n// 建造者与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。\nclass carmanualbuilder implements builder is\n    private field manual:manual\n\n    constructor carmanualbuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new manual()\n\n    method setseats(...) is\n        // 添加关于汽车座椅功能的文档。\n\n    method setengine(...) is\n        // 添加关于引擎的介绍。\n\n    method settripcomputer(...) is\n        // 添加关于行车电脑的介绍。\n\n    method setgps(...) is\n        // 添加关于 gps 的介绍。\n\n    method getproduct():manual is\n        // 返回使用手册并重置建造者。\n\n\n// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时\n// 会很有帮助。由于客户端可以直接控制建造者，所以严格意义上来说，主管类并\n// 不是必需的。\nclass director is\n    private field builder:builder\n\n    // 主管可同由客户端代码传递给自身的任何建造者实例进行交互。客户端可通\n    // 过这种方式改变最新组装完毕的产品的最终类型。\n    method setbuilder(builder:builder)\n        this.builder = builder\n\n    // 主管可使用同样的生成步骤创建多个产品变体。\n    method constructsportscar(builder: builder) is\n        builder.reset()\n        builder.setseats(2)\n        builder.setengine(new sportengine())\n        builder.settripcomputer(true)\n        builder.setgps(true)\n\n    method constructsuv(builder: builder) is\n        // ...\n\n\n// 客户端代码会创建建造者对象并将其传递给主管，然后执行构造过程。最终结果\n// 将需要从建造者对象中获取。\nclass application is\n\n    method makecar() is\n        director = new director()\n\n        carbuilder builder = new carbuilder()\n        director.constructsportscar(builder)\n        car car = builder.getproduct()\n\n        carmanualbuilder builder = new carmanualbuilder()\n        director.constructsportscar(builder)\n\n        // 最终产品通常需要从建造者对象中获取，因为主管不知晓具体建造者和\n        // 产品的存在，也不会对其产生依赖。\n        manual manual = builder.getproduct()\n\n\n\n# 案例\n\n使用示例： 建造者模式是 java 世界中的一个著名模式。 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。\n\n建造者在 java 核心程序库中得到了广泛的应用：\n\n * java.lang.stringbuilder#append() （ 非同步 ）\n * java.lang.stringbuffer#append() （ 同步 ）\n * java.nio.bytebuffer#put() （还有 char­buffer、 short­buffer、 int­buffer、 long­buffer、 float­buffer 和 double­buffer）\n * java.lang.appendable的所有实现\n\n识别方法： 建造者模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 建造者方法通常支持方法链 （例如 somebuilder->setvaluea(1)->setvalueb(2)->create() ）\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或建造者模式 （更灵活但更加复杂）。\n * 建造者重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 建造者则允许你在获取产品前执行一些额外构造步骤。\n * 你可以在创建复杂组合模式树时使用建造者， 因为这可使其构造步骤以递归的方式运行。\n * 你可以结合使用建造者和桥接模式： 主管类负责抽象工作， 各种不同的建造者负责实现工作。\n * 抽象工厂、 建造者和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之原型模式",frontmatter:{title:"设计模式之原型模式",date:"2015-06-03T15:00:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/1af8ee/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/05.原型模式.md",key:"v-68de8656",path:"/pages/1af8ee/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:3,title:"浅拷贝与深拷贝",slug:"浅拷贝与深拷贝",normalizedTitle:"浅拷贝与深拷贝",charIndex:468},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:617},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:746},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:957},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3085},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:3258},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3668}],headersStr:"意图 浅拷贝与深拷贝 适用场景 结构 伪代码 案例 与其他模式的关系 参考资料",content:"# 设计模式之原型模式\n\n\n# 意图\n\n原型模式（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n\n原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件：\n\n * 实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 CloneNotSupportedException 异常。\n * 重写 Object 类中的 clone 方法。Java 中，所有类的父类都是 Object 类，Object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，Prototype 类需要将 clone 方法的作用域修改为 public 类型。\n\n\n# 浅拷贝与深拷贝\n\n浅拷贝是指当对象的字段值被复制时，字段引用的对象不会被复制。\n\n例如：如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那麽两个对象将引用同一个字符串。\n\n深拷贝是指当一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝。\n\n\n# 适用场景\n\n * 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。\n * 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。\n\n\n# 结构\n\n\n\n 1. 原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。\n 2. 具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。\n 3. 客户端 （Client） 可以复制实现了原型接口的任何对象。\n\n\n# 伪代码\n\n在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。\n\n\n\n所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。\n\n// 基础原型。\nabstract class Shape is\n    field X: int\n    field Y: int\n    field color: string\n\n    // 常规构造函数。\n    constructor Shape() is\n        // ...\n\n    // 原型构造函数。使用已有对象的数值来初始化一个新对象。\n    constructor Shape(source: Shape) is\n        this()\n        this.X = source.X\n        this.Y = source.Y\n        this.color = source.color\n\n    // clone（克隆）操作会返回一个形状子类。\n    abstract method clone():Shape\n\n\n// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运\n// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生\n// 成的克隆对象。这可以保持克隆结果的一致。\nclass Rectangle extends Shape is\n    field width: int\n    field height: int\n\n    constructor Rectangle(source: Rectangle) is\n        // 需要调用父构造函数来复制父类中定义的私有成员变量。\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():Shape is\n        return new Rectangle(this)\n\n\nclass Circle extends Shape is\n    field radius: int\n\n    constructor Circle(source: Circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():Shape is\n        return new Circle(this)\n\n\n// 客户端代码中的某个位置。\nclass Application is\n    field shapes: array of Shape\n\n    constructor Application() is\n        Circle circle = new Circle()\n        circle.X = 10\n        circle.Y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        Circle anotherCircle = circle.clone()\n        shapes.add(anotherCircle)\n        // 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内\n        // 容完全一样。\n\n        Rectangle rectangle = new Rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businessLogic() is\n        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与\n        // 其完全相同的复制品。\n        Array shapesCopy = new Array of Shapes.\n\n        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。\n        // 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`\n        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，\n        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。\n        foreach (s in shapes) do\n            shapesCopy.add(s.clone())\n\n        // `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有\n        // 子元素的复制品。\n\n\n\n# 案例\n\n使用示例： Java 的 Cloneable （可克隆） 接口就是立即可用的原型模式。\n\n任何类都可通过实现该接口来实现可被克隆的性质。\n\n * java.lang.Object#clone() （类必须实现 java.lang.Cloneable 接口）\n\n识别方法： 原型可以简单地通过 clone或 copy等方法来识别。\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 原型可用于保存命令模式的历史记录。\n * 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程",normalizedContent:"# 设计模式之原型模式\n\n\n# 意图\n\n原型模式（prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n\n原型模式主要用于对象的复制，它的核心是就是类图中的原型类 prototype。prototype 类需要具备以下两个条件：\n\n * 实现 cloneable 接口。在 java 语言有一个 cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 clonenotsupportedexception 异常。\n * 重写 object 类中的 clone 方法。java 中，所有类的父类都是 object 类，object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，prototype 类需要将 clone 方法的作用域修改为 public 类型。\n\n\n# 浅拷贝与深拷贝\n\n浅拷贝是指当对象的字段值被复制时，字段引用的对象不会被复制。\n\n例如：如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那麽两个对象将引用同一个字符串。\n\n深拷贝是指当一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝。\n\n\n# 适用场景\n\n * 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。\n * 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。\n\n\n# 结构\n\n\n\n 1. 原型 （prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。\n 2. 具体原型 （concrete prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。\n 3. 客户端 （client） 可以复制实现了原型接口的任何对象。\n\n\n# 伪代码\n\n在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。\n\n\n\n所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。\n\n// 基础原型。\nabstract class shape is\n    field x: int\n    field y: int\n    field color: string\n\n    // 常规构造函数。\n    constructor shape() is\n        // ...\n\n    // 原型构造函数。使用已有对象的数值来初始化一个新对象。\n    constructor shape(source: shape) is\n        this()\n        this.x = source.x\n        this.y = source.y\n        this.color = source.color\n\n    // clone（克隆）操作会返回一个形状子类。\n    abstract method clone():shape\n\n\n// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运\n// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生\n// 成的克隆对象。这可以保持克隆结果的一致。\nclass rectangle extends shape is\n    field width: int\n    field height: int\n\n    constructor rectangle(source: rectangle) is\n        // 需要调用父构造函数来复制父类中定义的私有成员变量。\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():shape is\n        return new rectangle(this)\n\n\nclass circle extends shape is\n    field radius: int\n\n    constructor circle(source: circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():shape is\n        return new circle(this)\n\n\n// 客户端代码中的某个位置。\nclass application is\n    field shapes: array of shape\n\n    constructor application() is\n        circle circle = new circle()\n        circle.x = 10\n        circle.y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        circle anothercircle = circle.clone()\n        shapes.add(anothercircle)\n        // 变量 `anothercircle（另一个圆）`与 `circle（圆）`对象的内\n        // 容完全一样。\n\n        rectangle rectangle = new rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businesslogic() is\n        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与\n        // 其完全相同的复制品。\n        array shapescopy = new array of shapes.\n\n        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。\n        // 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`\n        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，\n        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。\n        foreach (s in shapes) do\n            shapescopy.add(s.clone())\n\n        // `shapescopy（形状副本）`数组中包含 `shape（形状）`数组所有\n        // 子元素的复制品。\n\n\n\n# 案例\n\n使用示例： java 的 cloneable （可克隆） 接口就是立即可用的原型模式。\n\n任何类都可通过实现该接口来实现可被克隆的性质。\n\n * java.lang.object#clone() （类必须实现 java.lang.cloneable 接口）\n\n识别方法： 原型可以简单地通过 clone或 copy等方法来识别。\n\n\n# 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 原型可用于保存命令模式的历史记录。\n * 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之单例模式",frontmatter:{title:"设计模式之单例模式",date:"2015-06-03T09:24:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/cf046f/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/06.单例模式.md",key:"v-72ea5972",path:"/pages/cf046f/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:744},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:1204},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1339},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:2485},{level:3,title:"数据库连接类",slug:"数据库连接类",normalizedTitle:"数据库连接类",charIndex:1350},{level:3,title:"懒汉式",slug:"懒汉式",normalizedTitle:"懒汉式",charIndex:3859},{level:3,title:"饿汉式",slug:"饿汉式",normalizedTitle:"饿汉式",charIndex:4387},{level:3,title:"双重锁的形式",slug:"双重锁的形式",normalizedTitle:"双重锁的形式",charIndex:4816},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5554},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5778}],headersStr:"意图 适用场景 结构 伪代码 案例 数据库连接类 懒汉式 饿汉式 双重锁的形式 与其他模式的关系 参考资料",content:'# 设计模式之单例模式\n\n\n# 意图\n\n单例模式（Singleton）是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n\n单例 （Singleton） 类声明了一个名为 get­Instance 获取实例的静态方法来返回其所属类的一个相同实例。\n\n单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 get­Instance 方法必须是获取单例对象的唯一方式。\n\n所有单例的实现都包含以下两个相同的步骤：\n\n * 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n * 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n\n如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。\n\n单例模式的优点：\n\n * ✔ 你可以保证一个类只有一个实例。\n * ✔ 你获得了一个指向该实例的全局访问节点。\n * ✔ 仅在首次请求单例对象时对其进行初始化。\n\n单例模式的缺点：\n\n * ❌ 违反了单一职责原则。 该模式同时解决了两个问题。\n * ❌ 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。\n * ❌ 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。\n * ❌ 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。\n\n\n# 适用场景\n\n * 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 ⚡ 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。\n * 如果你需要更加严格地控制全局变量， 可以使用单例模式。 ⚡ 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。\n\n请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例 方法， 即 getInstance 中的代码即可实现。\n\n举例来说，一些资源管理器常常设计成单例模式。\n\n在计算机系统中，需要管理的资源包括软件外部资源，譬如每台计算机可以有若干个打印机，但只能有一个 Printer Spooler， 以避免两个打印作业同时输出到打印机中。\n\n每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。任务管理器中难以启动两个相同的 task。\n\n\n# 结构\n\n\n\n 1. 单例 （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。\n    * 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。\n\n\n# 伪代码\n\n在本例中， 数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass Database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: Database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor Database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query("SELECT ...")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query("SELECT ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 案例\n\n使用示例： 许多开发者将单例模式视为一种反模式。 因此它在 Java 代码中的使用频率正在逐步减少。\n\n尽管如此， Java 核心程序库中仍有相当多的单例示例：\n\n * java.lang.Runtime#getRuntime()\n * java.awt.Desktop#getDesktop()\n * java.lang.System#getSecurityManager()\n\n识别方法： 单例可以通过返回相同缓存对象的静态构建方法来识别。\n\n\n# 数据库连接类\n\n数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass Database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: Database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor Database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query("SELECT ...")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query("SELECT ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 懒汉式\n\n懒汉式的实现思路是：你不找懒汉，懒汉根本就懒得去初始化自己。\n\ninstance 初始时没有初始化，只有当第一次调 getInstance() 时才创建实例。\n\n缺点：当有两个线程调 getInstance() 方法，当它们同时执行到 if (null == instance) 这行代码，instance 为 null。\n\n继续向下执行，会生成两个实例，违背了单例模式的初衷。\n\npublic class LazySingleton {\n    private LazySingleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static LazySingleton instance = null;\n\n    public static LazySingleton getInstance() {\n        if (null == instance) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n\n\n\n# 饿汉式\n\n懒汉式的实现思路是：饿汉根本等不及别人来找他，不管三七二十一先初始化了自身的实例，生怕自己饿着了。\n\n类默认先直接初始化一个实例，以后调用 getInstance() 总是返回这个已创建好的实例。\n\n缺点：在没有必要获取实例时，已经预先产生了开销。\n\n优点：规避了懒汉式方法的线程问题，不用显示编写线程安全代码。\n\npublic class HungerSinleton {\n    private HungerSinleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static HungerSinleton instance = new HungerSinleton();\n\n    public static HungerSinleton getInstance() {\n        return instance;\n    }\n}\n\n\n\n# 双重锁的形式\n\n如果既不想在没有调用 getInstance() 方法时产生开销，又不想发生线程安全问题，就可以采用双重锁的形式。\n\npublic class SyncSingleton {\n    private SyncSingleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static SyncSingleton instance = null;\n\n    public static SyncSingleton getInstance() {\n        if (null == instance) {\n            synchronized(SyncSingleton.class) {\n                if (null == instance) {\n                    instance = new SyncSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n> 注：在外面判断了 instance 实例是否存在，为什么在锁定后又要在内部又判断一次？\n> \n> 这是因为，如果 instance 为 null 时有两个线程同时调用 getInstance()，由于 synchronized 机制，只允许一个线程进入，另一个需要等待。\n> \n> 这时如果没有第二道 instance 是否为 null 的判断，就可能发生第一个线程创建一个实例，而第二个线程又创建一个实例的情况。\n\n\n# 与其他模式的关系\n\n * 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n * 抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之单例模式\n\n\n# 意图\n\n单例模式（singleton）是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n\n单例 （singleton） 类声明了一个名为 get­instance 获取实例的静态方法来返回其所属类的一个相同实例。\n\n单例的构造函数必须对客户端 （client） 代码隐藏。 调用 get­instance 方法必须是获取单例对象的唯一方式。\n\n所有单例的实现都包含以下两个相同的步骤：\n\n * 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n * 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n\n如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。\n\n单例模式的优点：\n\n * ✔ 你可以保证一个类只有一个实例。\n * ✔ 你获得了一个指向该实例的全局访问节点。\n * ✔ 仅在首次请求单例对象时对其进行初始化。\n\n单例模式的缺点：\n\n * ❌ 违反了单一职责原则。 该模式同时解决了两个问题。\n * ❌ 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。\n * ❌ 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。\n * ❌ 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。\n\n\n# 适用场景\n\n * 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 ⚡ 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。\n * 如果你需要更加严格地控制全局变量， 可以使用单例模式。 ⚡ 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。\n\n请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例 方法， 即 getinstance 中的代码即可实现。\n\n举例来说，一些资源管理器常常设计成单例模式。\n\n在计算机系统中，需要管理的资源包括软件外部资源，譬如每台计算机可以有若干个打印机，但只能有一个 printer spooler， 以避免两个打印作业同时输出到打印机中。\n\n每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。任务管理器中难以启动两个相同的 task。\n\n\n# 结构\n\n\n\n 1. 单例 （singleton） 类声明了一个名为 get­instance获取实例的静态方法来返回其所属类的一个相同实例。\n    * 单例的构造函数必须对客户端 （client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。\n\n\n# 伪代码\n\n在本例中， 数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getinstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getinstance() is\n        if (database.instance == null) then\n            acquirethreadlock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (database.instance == null) then\n                    database.instance = new database()\n        return database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass application is\n    method main() is\n        database foo = database.getinstance()\n        foo.query("select ...")\n        // ...\n        database bar = database.getinstance()\n        bar.query("select ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 案例\n\n使用示例： 许多开发者将单例模式视为一种反模式。 因此它在 java 代码中的使用频率正在逐步减少。\n\n尽管如此， java 核心程序库中仍有相当多的单例示例：\n\n * java.lang.runtime#getruntime()\n * java.awt.desktop#getdesktop()\n * java.lang.system#getsecuritymanager()\n\n识别方法： 单例可以通过返回相同缓存对象的静态构建方法来识别。\n\n\n# 数据库连接类\n\n数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getinstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getinstance() is\n        if (database.instance == null) then\n            acquirethreadlock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (database.instance == null) then\n                    database.instance = new database()\n        return database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass application is\n    method main() is\n        database foo = database.getinstance()\n        foo.query("select ...")\n        // ...\n        database bar = database.getinstance()\n        bar.query("select ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 懒汉式\n\n懒汉式的实现思路是：你不找懒汉，懒汉根本就懒得去初始化自己。\n\ninstance 初始时没有初始化，只有当第一次调 getinstance() 时才创建实例。\n\n缺点：当有两个线程调 getinstance() 方法，当它们同时执行到 if (null == instance) 这行代码，instance 为 null。\n\n继续向下执行，会生成两个实例，违背了单例模式的初衷。\n\npublic class lazysingleton {\n    private lazysingleton() {\n        system.out.println("singleton()");\n    }\n\n    private static lazysingleton instance = null;\n\n    public static lazysingleton getinstance() {\n        if (null == instance) {\n            instance = new lazysingleton();\n        }\n        return instance;\n    }\n}\n\n\n\n# 饿汉式\n\n懒汉式的实现思路是：饿汉根本等不及别人来找他，不管三七二十一先初始化了自身的实例，生怕自己饿着了。\n\n类默认先直接初始化一个实例，以后调用 getinstance() 总是返回这个已创建好的实例。\n\n缺点：在没有必要获取实例时，已经预先产生了开销。\n\n优点：规避了懒汉式方法的线程问题，不用显示编写线程安全代码。\n\npublic class hungersinleton {\n    private hungersinleton() {\n        system.out.println("singleton()");\n    }\n\n    private static hungersinleton instance = new hungersinleton();\n\n    public static hungersinleton getinstance() {\n        return instance;\n    }\n}\n\n\n\n# 双重锁的形式\n\n如果既不想在没有调用 getinstance() 方法时产生开销，又不想发生线程安全问题，就可以采用双重锁的形式。\n\npublic class syncsingleton {\n    private syncsingleton() {\n        system.out.println("singleton()");\n    }\n\n    private static syncsingleton instance = null;\n\n    public static syncsingleton getinstance() {\n        if (null == instance) {\n            synchronized(syncsingleton.class) {\n                if (null == instance) {\n                    instance = new syncsingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n> 注：在外面判断了 instance 实例是否存在，为什么在锁定后又要在内部又判断一次？\n> \n> 这是因为，如果 instance 为 null 时有两个线程同时调用 getinstance()，由于 synchronized 机制，只允许一个线程进入，另一个需要等待。\n> \n> 这时如果没有第二道 instance 是否为 null 的判断，就可能发生第一个线程创建一个实例，而第二个线程又创建一个实例的情况。\n\n\n# 与其他模式的关系\n\n * 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n * 抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之适配器模式",frontmatter:{title:"设计模式之适配器模式",date:"2015-01-14T18:31:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/2115cf/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/07.适配器模式.md",key:"v-b5457c16",path:"/pages/2115cf/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:255},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:39},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:426},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:802},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1404},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:2749},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:3182},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3609}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之适配器模式\n\n\n# 意图\n\n适配器模式 (Adapter)是一种结构型设计模式， 它能使不兼容的对象能够相互合作。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：\n\n * 适配器实现与其中一个现有对象兼容的接口。\n * 现有对象可以使用该接口安全地调用适配器方法。\n * 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。\n\n\n# 适用场景\n\n * 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n * 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n\n# 结构\n\n适配器实现了其中一个对象的接口， 并对另一个对象进行封装。\n\n\n\n\n# 结构说明\n\n 1. 客户端 （Client） 是包含当前程序业务逻辑的类。\n 2. 客户端接口 （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。\n 3. 服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。\n 4. 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n 5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# 结构代码范式\n\n【Target】\n\n定义用户实际需要的接口。\n\nabstract class Target {\n    public abstract void Request();\n}\n\n\n【Adaptee】\n\n定义一个需要适配的接口。\n\nclass Adaptee {\n    public void SpecificRequest() {\n        System.out.println("特殊请求");\n    }\n}\n\n\n【Adapter】\n\n通过在内部包装一个 Adaptee 对象，把源接口转换成目标接口。\n\nclass Adapter extends Target {\n    private Adaptee adaptee = new Adaptee();\n\n    @Override\n    public void Request() {\n        adaptee.SpecificRequest();\n    }\n}\n\n\n【客户端】\n\npublic class AdapterPattern {\n    public static void main(String[] args) {\n        Target target = new Adapter();\n        target.Request();\n    }\n}\n\n\n【输出】\n\n特殊请求\n\n\n\n# 伪代码\n\n\n\n适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。\n\n// 假设你有两个接口相互兼容的类：圆孔（Round­Hole）和圆钉（Round­Peg）。\nclass RoundHole is\n    constructor RoundHole(radius) { ... }\n\n    method getRadius() is\n        // 返回孔的半径。\n\n    method fits(peg: RoundPeg) is\n        return this.getRadius() >= peg.getRadius()\n\nclass RoundPeg is\n    constructor RoundPeg(radius) { ... }\n\n    method getRadius() is\n        // 返回钉子的半径。\n\n\n// 但还有一个不兼容的类：方钉（Square­Peg）。\nclass SquarePeg is\n    constructor SquarePeg(width) { ... }\n\n    method getWidth() is\n        // 返回方钉的宽度。\n\n\n// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适\n// 配器对象作为圆钉。\nclass SquarePegAdapter extends RoundPeg is\n    // 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。\n    private field peg: SquarePeg\n\n    constructor SquarePegAdapter(peg: SquarePeg) is\n        this.peg = peg\n\n    method getRadius() is\n        // 适配器会假扮为一个圆钉，\n        // 其半径刚好能与适配器实际封装的方钉搭配起来。\n        return peg.getWidth() * Math.sqrt(2) / 2\n\n\n// 客户端代码中的某个位置。\nhole = new RoundHole(5)\nrpeg = new RoundPeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new SquarePeg(5)\nlarge_sqpeg = new SquarePeg(10)\nhole.fits(small_sqpeg) // 此处无法编译（类型不一致）。\n\nsmall_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)\nlarge_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n\n\n\n# 案例\n\n适配器模式在 Java 代码中很常见。\n\nJava 核心程序库中有一些标准的适配器：\n\n * java.util.Arrays#asList()\n * java.util.Collections#list()\n * java.util.Collections#enumeration()\n * java.io.InputStreamReader(InputStream) （返回 Reader对象）\n * java.io.OutputStreamWriter(OutputStream) （返回 Writer对象）\n * javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal()\n\n识别方法： 适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。 当适配器的任何方法被调用时， 它会将参数转换为合适的格式， 然后将调用定向到其封装对象中的一个或多个方法。\n\n\n# 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之适配器模式\n\n\n# 意图\n\n适配器模式 (adapter)是一种结构型设计模式， 它能使不兼容的对象能够相互合作。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：\n\n * 适配器实现与其中一个现有对象兼容的接口。\n * 现有对象可以使用该接口安全地调用适配器方法。\n * 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。\n\n\n# 适用场景\n\n * 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n * 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n\n# 结构\n\n适配器实现了其中一个对象的接口， 并对另一个对象进行封装。\n\n\n\n\n# 结构说明\n\n 1. 客户端 （client） 是包含当前程序业务逻辑的类。\n 2. 客户端接口 （client interface） 描述了其他类与客户端代码合作时必须遵循的协议。\n 3. 服务 （service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。\n 4. 适配器 （adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n 5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# 结构代码范式\n\n【target】\n\n定义用户实际需要的接口。\n\nabstract class target {\n    public abstract void request();\n}\n\n\n【adaptee】\n\n定义一个需要适配的接口。\n\nclass adaptee {\n    public void specificrequest() {\n        system.out.println("特殊请求");\n    }\n}\n\n\n【adapter】\n\n通过在内部包装一个 adaptee 对象，把源接口转换成目标接口。\n\nclass adapter extends target {\n    private adaptee adaptee = new adaptee();\n\n    @override\n    public void request() {\n        adaptee.specificrequest();\n    }\n}\n\n\n【客户端】\n\npublic class adapterpattern {\n    public static void main(string[] args) {\n        target target = new adapter();\n        target.request();\n    }\n}\n\n\n【输出】\n\n特殊请求\n\n\n\n# 伪代码\n\n\n\n适配器假扮成一个圆钉 （round­peg）， 其半径等于方钉 （square­peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。\n\n// 假设你有两个接口相互兼容的类：圆孔（round­hole）和圆钉（round­peg）。\nclass roundhole is\n    constructor roundhole(radius) { ... }\n\n    method getradius() is\n        // 返回孔的半径。\n\n    method fits(peg: roundpeg) is\n        return this.getradius() >= peg.getradius()\n\nclass roundpeg is\n    constructor roundpeg(radius) { ... }\n\n    method getradius() is\n        // 返回钉子的半径。\n\n\n// 但还有一个不兼容的类：方钉（square­peg）。\nclass squarepeg is\n    constructor squarepeg(width) { ... }\n\n    method getwidth() is\n        // 返回方钉的宽度。\n\n\n// 适配器类让你能够将方钉放入圆孔中。它会对 roundpeg 类进行扩展，以接收适\n// 配器对象作为圆钉。\nclass squarepegadapter extends roundpeg is\n    // 在实际情况中，适配器中会包含一个 squarepeg 类的实例。\n    private field peg: squarepeg\n\n    constructor squarepegadapter(peg: squarepeg) is\n        this.peg = peg\n\n    method getradius() is\n        // 适配器会假扮为一个圆钉，\n        // 其半径刚好能与适配器实际封装的方钉搭配起来。\n        return peg.getwidth() * math.sqrt(2) / 2\n\n\n// 客户端代码中的某个位置。\nhole = new roundhole(5)\nrpeg = new roundpeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new squarepeg(5)\nlarge_sqpeg = new squarepeg(10)\nhole.fits(small_sqpeg) // 此处无法编译（类型不一致）。\n\nsmall_sqpeg_adapter = new squarepegadapter(small_sqpeg)\nlarge_sqpeg_adapter = new squarepegadapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n\n\n\n# 案例\n\n适配器模式在 java 代码中很常见。\n\njava 核心程序库中有一些标准的适配器：\n\n * java.util.arrays#aslist()\n * java.util.collections#list()\n * java.util.collections#enumeration()\n * java.io.inputstreamreader(inputstream) （返回 reader对象）\n * java.io.outputstreamwriter(outputstream) （返回 writer对象）\n * javax.xml.bind.annotation.adapters.xmladapter#marshal() 和 #unmarshal()\n\n识别方法： 适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。 当适配器的任何方法被调用时， 它会将参数转换为合适的格式， 然后将调用定向到其封装对象中的一个或多个方法。\n\n\n# 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之桥接模式",frontmatter:{title:"设计模式之桥接模式",date:"2015-01-16T10:32:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/b05f5f/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/08.桥接模式.md",key:"v-0569b6f8",path:"/pages/b05f5f/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:240},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:37},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:377},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:757},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2241},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3777},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:4100},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4475}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之桥接模式\n\n\n# 意图\n\n桥接模式 (Bridge) 是一种结构型设计模式， 可将抽象部分与实现部分分离，使它们都可以独立的变化。\n\n如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。\n\n设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。\n\n\n# 适用场景\n\n * 如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。\n * 如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n * 如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象部分 （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。\n 2. 实现部分 （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。\n    * 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。\n 3. 具体实现 （Concrete Implementations） 中包括特定于平台的代码。\n 4. 精确抽象 （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。\n 5. 通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。\n\n\n# 结构代码范式\n\n【Implementor】定义实现接口。\n\ninterface Implementor {\n    // 实现抽象部分需要的某些具体功能\n    public void operationImpl();\n}\n\n\n【Abstraction】定义抽象接口。\n\nabstract class Abstraction {\n    // 持有一个 Implementor 对象，形成聚合关系\n    protected Implementor implementor;\n\n    public Abstraction(Implementor implementor) {\n        this.implementor = implementor;\n    }\n\n    // 可能需要转调实现部分的具体实现\n    public void operation() {\n        implementor.operationImpl();\n    }\n}\n\n\n【ConcreteImplementor】实现 Implementor 中定义的接口。\n\nclass ConcreteImplementorA implements Implementor {\n    @Override\n    public void operationImpl() {\n        // 真正的实现\n        System.out.println("具体实现A");\n    }\n}\n\nclass ConcreteImplementorB implements Implementor {\n    @Override\n    public void operationImpl() {\n        // 真正的实现\n        System.out.println("具体实现B");\n    }\n}\n\n\n【RefinedAbstraction】扩展 Abstraction 类。\n\nclass RefinedAbstraction extends Abstraction {\n\n    public RefinedAbstraction(Implementor implementor) {\n        super(implementor);\n    }\n\n    public void otherOperation() {\n        // 实现一定的功能，可能会使用具体实现部分的实现方法,\n        // 但是本方法更大的可能是使用 Abstraction 中定义的方法，\n        // 通过组合使用 Abstraction 中定义的方法来完成更多的功能。\n    }\n}\n\n\n【客户端】\n\npublic class BridgePattern {\n    public static void main(String[] args) {\n        Implementor implementor = new ConcreteImplementorA();\n        RefinedAbstraction abstraction = new RefinedAbstraction(implementor);\n        abstraction.operation();\n        abstraction.otherOperation();\n    }\n}\n\n\n【输出】\n\n具体实现A\n其他操作\n\n\n\n# 伪代码\n\n\n\n遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。\n\n你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。\n\n客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。\n\n// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实\n// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。\nclass RemoteControl is\n    protected field device: Device\n    constructor RemoteControl(device: Device) is\n        this.device = device\n    method togglePower() is\n        if (device.isEnabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumeDown() is\n        device.setVolume(device.getVolume() - 10)\n    method volumeUp() is\n        device.setVolume(device.getVolume() + 10)\n    method channelDown() is\n        device.setChannel(device.getChannel() - 1)\n    method channelUp() is\n        device.setChannel(device.getChannel() + 1)\n\n\n// 你可以独立于设备类的方式从抽象层中扩展类。\nclass AdvancedRemoteControl extends RemoteControl is\n    method mute() is\n        device.setVolume(0)\n\n\n// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相\n// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而\n// 抽象接口则会基于这些操作定义较高层次的操作。\ninterface Device is\n    method isEnabled()\n    method enable()\n    method disable()\n    method getVolume()\n    method setVolume(percent)\n    method getChannel()\n    method setChannel(channel)\n\n\n// 所有设备都遵循相同的接口。\nclass Tv implements Device is\n    // ...\n\nclass Radio implements Device is\n    // ...\n\n\n// 客户端代码中的某个位置。\ntv = new Tv()\nremote = new RemoteControl(tv)\nremote.togglePower()\n\nradio = new Radio()\nremote = new AdvancedRemoteControl(radio)\n\n\n\n# 案例\n\n使用示例： 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。\n\n识别方法： 桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。\n\nJava 中桥接模式应用最经典的代表无疑是日志组件 slf4j 的桥接 jar 包。\n\n假如，你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n\n# 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之桥接模式\n\n\n# 意图\n\n桥接模式 (bridge) 是一种结构型设计模式， 可将抽象部分与实现部分分离，使它们都可以独立的变化。\n\n如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。\n\n设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。\n\n\n# 适用场景\n\n * 如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。\n * 如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n * 如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象部分 （abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。\n 2. 实现部分 （implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。\n    * 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。\n 3. 具体实现 （concrete implementations） 中包括特定于平台的代码。\n 4. 精确抽象 （refined abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。\n 5. 通常情况下， 客户端 （client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。\n\n\n# 结构代码范式\n\n【implementor】定义实现接口。\n\ninterface implementor {\n    // 实现抽象部分需要的某些具体功能\n    public void operationimpl();\n}\n\n\n【abstraction】定义抽象接口。\n\nabstract class abstraction {\n    // 持有一个 implementor 对象，形成聚合关系\n    protected implementor implementor;\n\n    public abstraction(implementor implementor) {\n        this.implementor = implementor;\n    }\n\n    // 可能需要转调实现部分的具体实现\n    public void operation() {\n        implementor.operationimpl();\n    }\n}\n\n\n【concreteimplementor】实现 implementor 中定义的接口。\n\nclass concreteimplementora implements implementor {\n    @override\n    public void operationimpl() {\n        // 真正的实现\n        system.out.println("具体实现a");\n    }\n}\n\nclass concreteimplementorb implements implementor {\n    @override\n    public void operationimpl() {\n        // 真正的实现\n        system.out.println("具体实现b");\n    }\n}\n\n\n【refinedabstraction】扩展 abstraction 类。\n\nclass refinedabstraction extends abstraction {\n\n    public refinedabstraction(implementor implementor) {\n        super(implementor);\n    }\n\n    public void otheroperation() {\n        // 实现一定的功能，可能会使用具体实现部分的实现方法,\n        // 但是本方法更大的可能是使用 abstraction 中定义的方法，\n        // 通过组合使用 abstraction 中定义的方法来完成更多的功能。\n    }\n}\n\n\n【客户端】\n\npublic class bridgepattern {\n    public static void main(string[] args) {\n        implementor implementor = new concreteimplementora();\n        refinedabstraction abstraction = new refinedabstraction(implementor);\n        abstraction.operation();\n        abstraction.otheroperation();\n    }\n}\n\n\n【输出】\n\n具体实现a\n其他操作\n\n\n\n# 伪代码\n\n\n\n遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。\n\n你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。\n\n客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。\n\n// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实\n// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。\nclass remotecontrol is\n    protected field device: device\n    constructor remotecontrol(device: device) is\n        this.device = device\n    method togglepower() is\n        if (device.isenabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumedown() is\n        device.setvolume(device.getvolume() - 10)\n    method volumeup() is\n        device.setvolume(device.getvolume() + 10)\n    method channeldown() is\n        device.setchannel(device.getchannel() - 1)\n    method channelup() is\n        device.setchannel(device.getchannel() + 1)\n\n\n// 你可以独立于设备类的方式从抽象层中扩展类。\nclass advancedremotecontrol extends remotecontrol is\n    method mute() is\n        device.setvolume(0)\n\n\n// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相\n// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而\n// 抽象接口则会基于这些操作定义较高层次的操作。\ninterface device is\n    method isenabled()\n    method enable()\n    method disable()\n    method getvolume()\n    method setvolume(percent)\n    method getchannel()\n    method setchannel(channel)\n\n\n// 所有设备都遵循相同的接口。\nclass tv implements device is\n    // ...\n\nclass radio implements device is\n    // ...\n\n\n// 客户端代码中的某个位置。\ntv = new tv()\nremote = new remotecontrol(tv)\nremote.togglepower()\n\nradio = new radio()\nremote = new advancedremotecontrol(radio)\n\n\n\n# 案例\n\n使用示例： 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 api 供应商协作时会特别有用。\n\n识别方法： 桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。\n\njava 中桥接模式应用最经典的代表无疑是日志组件 slf4j 的桥接 jar 包。\n\n假如，你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n\n# 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之组合模式",frontmatter:{title:"设计模式之组合模式",date:"2015-01-14T15:33:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/85c0a3/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/09.组合模式.md",key:"v-4e6d8200",path:"/pages/85c0a3/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:108},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:40},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:343},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:677},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2859},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4836},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5097},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5659}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之组合模式\n\n\n# 意图\n\n组合模式 (Component) 是一种结构型设计模式，将对象组合成树形结构以表示“部分-整体”的层次结构。\n\n组合模式使得用户对单个对象和组合对象的使用具有唯一性。\n\n\n# 适用场景\n\n组合模式的适用场景：\n\n * 想要表示对象的部分-整体层次结构。\n * 想要客户端忽略组合对象与单个对象的差异，客户端将统一地使用组合结构中的所有对象。\n\n关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的 文件系统。\n\n文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也 可以是目录。\n\n按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。\n 2. 叶节点 （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。\n 3. 容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。\n 4. 客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。\n\n\n# 结构代码范式\n\nComponent : 组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 Component 的子部件。\n\nabstract class Component {\n    protected String name;\n\n    public Component(String name) {\n        this.name = name;\n    }\n\n    public abstract void Add(Component c);\n    public abstract void Remove(Component c);\n    public abstract void Display(int depth);\n}\n\n\nLeaf : 表示叶节点对象。叶子节点没有子节点。\n\nclass Leaf extends Component {\n\n    public Leaf(String name) {\n        super(name);\n    }\n\n    @Override\n    public void Add(Component c) {\n        System.out.println("Can not add to a leaf");\n    }\n\n    @Override\n    public void Remove(Component c) {\n        System.out.println("Can not remove from a leaf");\n    }\n\n    @Override\n    public void Display(int depth) {\n        String temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        System.out.println(temp + name);\n    }\n\n}\n\n\nComposite : 定义枝节点行为，用来存储子部件，在 Component 接口中实现与子部件相关的操作。例如 Add 和 Remove。\n\nclass Composite extends Component {\n\n    private List<Component> children = new ArrayList<Component>();\n\n    public Composite(String name) {\n        super(name);\n    }\n\n    @Override\n    public void Add(Component c) {\n        children.add(c);\n    }\n\n    @Override\n    public void Remove(Component c) {\n        children.remove(c);\n    }\n\n    @Override\n    public void Display(int depth) {\n        String temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        System.out.println(temp + name);\n\n        for (Component c : children) {\n            c.Display(depth + 2);\n        }\n    }\n\n}\n\n\nClient : 通过 Component 接口操作结构中的对象。\n\npublic class CompositePattern {\n\n    public static void main(String[] args) {\n        Composite root = new Composite("root");\n        root.Add(new Leaf("Leaf A"));\n        root.Add(new Leaf("Leaf B"));\n\n        Composite compX = new Composite("Composite X");\n        compX.Add(new Leaf("Leaf XA"));\n        compX.Add(new Leaf("Leaf XB"));\n        root.Add(compX);\n\n        Composite compXY = new Composite("Composite XY");\n        compXY.Add(new Leaf("Leaf XYA"));\n        compXY.Add(new Leaf("Leaf XYB"));\n        compX.Add(compXY);\n\n        root.Display(1);\n    }\n\n}\n\n\n\n# 伪代码\n\n在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。\n\n\n\n组合图形Compound­Graphic 是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。\n\n通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。\n\n// 组件接口会声明组合中简单和复杂对象的通用操作。\ninterface Graphic is\n    method move(x, y)\n    method draw()\n\n// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象\n// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。\nclass Dot implements Graphic is\n    field x, y\n\n    constructor Dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // 在坐标位置(X,Y)处绘制一个点。\n\n// 所有组件类都可以扩展其他组件。\nclass Circle extends Dot is\n    field radius\n\n    constructor Circle(x, y, radius) { ... }\n\n    method draw() is\n        // 在坐标位置(X,Y)处绘制一个半径为 R 的圆。\n\n// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项\n// 目，然后“汇总”结果。\nclass CompoundGraphic implements Graphic is\n    field children: array of Graphic\n\n    // 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。\n    method add(child: Graphic) is\n        // 在子项目数组中添加一个子项目。\n\n    method remove(child: Graphic) is\n        // 从子项目数组中移除一个子项目。\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和\n    // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，\n    // 最后组合将会完成整个对象树的遍历工作。\n    method draw() is\n        // 1. 对于每个子部件：\n        //     - 绘制该部件。\n        //     - 更新边框坐标。\n        // 2. 根据边框坐标绘制一个虚线长方形。\n\n\n// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同\n// 时支持简单叶节点组件和复杂组件。\nclass ImageEditor is\n    field all: CompoundGraphic\n\n    method load() is\n        all = new CompoundGraphic()\n        all.add(new Dot(1, 2))\n        all.add(new Circle(5, 3, 10))\n        // ...\n\n    // 将所需组件组合为复杂的组合组件。\n    method groupSelected(components: array of Graphic) is\n        group = new CompoundGraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // 所有组件都将被绘制。\n        all.draw()\n\n\n\n# 案例\n\n使用实例： 组合模式在 Java 代码中很常见,常用于表示与图形打交道的用户界面组件或代码的层次结构。\n\n下面是一些来自 Java 标准程序库中的组合示例：\n\n * java.awt.Container#add(Component) （几乎广泛存在于 Swing 组件中）\n * javax.faces.component.UIComponent#getChildren() （几乎广泛存在于 JSF UI 组件中）\n\n识别方法： 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。\n * 责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n * 你可以使用迭代器模式来遍历组合树。\n * 你可以使用访问者模式对整个组合树执行操作。\n * 你可以使用享元模式实现组合树的共享叶节点以节省内存。\n * 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之组合模式\n\n\n# 意图\n\n组合模式 (component) 是一种结构型设计模式，将对象组合成树形结构以表示“部分-整体”的层次结构。\n\n组合模式使得用户对单个对象和组合对象的使用具有唯一性。\n\n\n# 适用场景\n\n组合模式的适用场景：\n\n * 想要表示对象的部分-整体层次结构。\n * 想要客户端忽略组合对象与单个对象的差异，客户端将统一地使用组合结构中的所有对象。\n\n关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的 文件系统。\n\n文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也 可以是目录。\n\n按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 组件 （component） 接口描述了树中简单项目和复杂项目所共有的操作。\n 2. 叶节点 （leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。\n 3. 容器 （container）——又名 “组合 （composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。\n 4. 客户端 （client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。\n\n\n# 结构代码范式\n\ncomponent : 组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 component 的子部件。\n\nabstract class component {\n    protected string name;\n\n    public component(string name) {\n        this.name = name;\n    }\n\n    public abstract void add(component c);\n    public abstract void remove(component c);\n    public abstract void display(int depth);\n}\n\n\nleaf : 表示叶节点对象。叶子节点没有子节点。\n\nclass leaf extends component {\n\n    public leaf(string name) {\n        super(name);\n    }\n\n    @override\n    public void add(component c) {\n        system.out.println("can not add to a leaf");\n    }\n\n    @override\n    public void remove(component c) {\n        system.out.println("can not remove from a leaf");\n    }\n\n    @override\n    public void display(int depth) {\n        string temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        system.out.println(temp + name);\n    }\n\n}\n\n\ncomposite : 定义枝节点行为，用来存储子部件，在 component 接口中实现与子部件相关的操作。例如 add 和 remove。\n\nclass composite extends component {\n\n    private list<component> children = new arraylist<component>();\n\n    public composite(string name) {\n        super(name);\n    }\n\n    @override\n    public void add(component c) {\n        children.add(c);\n    }\n\n    @override\n    public void remove(component c) {\n        children.remove(c);\n    }\n\n    @override\n    public void display(int depth) {\n        string temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        system.out.println(temp + name);\n\n        for (component c : children) {\n            c.display(depth + 2);\n        }\n    }\n\n}\n\n\nclient : 通过 component 接口操作结构中的对象。\n\npublic class compositepattern {\n\n    public static void main(string[] args) {\n        composite root = new composite("root");\n        root.add(new leaf("leaf a"));\n        root.add(new leaf("leaf b"));\n\n        composite compx = new composite("composite x");\n        compx.add(new leaf("leaf xa"));\n        compx.add(new leaf("leaf xb"));\n        root.add(compx);\n\n        composite compxy = new composite("composite xy");\n        compxy.add(new leaf("leaf xya"));\n        compxy.add(new leaf("leaf xyb"));\n        compx.add(compxy);\n\n        root.display(1);\n    }\n\n}\n\n\n\n# 伪代码\n\n在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。\n\n\n\n组合图形compound­graphic 是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。\n\n通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。\n\n// 组件接口会声明组合中简单和复杂对象的通用操作。\ninterface graphic is\n    method move(x, y)\n    method draw()\n\n// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象\n// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。\nclass dot implements graphic is\n    field x, y\n\n    constructor dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // 在坐标位置(x,y)处绘制一个点。\n\n// 所有组件类都可以扩展其他组件。\nclass circle extends dot is\n    field radius\n\n    constructor circle(x, y, radius) { ... }\n\n    method draw() is\n        // 在坐标位置(x,y)处绘制一个半径为 r 的圆。\n\n// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项\n// 目，然后“汇总”结果。\nclass compoundgraphic implements graphic is\n    field children: array of graphic\n\n    // 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。\n    method add(child: graphic) is\n        // 在子项目数组中添加一个子项目。\n\n    method remove(child: graphic) is\n        // 从子项目数组中移除一个子项目。\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和\n    // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，\n    // 最后组合将会完成整个对象树的遍历工作。\n    method draw() is\n        // 1. 对于每个子部件：\n        //     - 绘制该部件。\n        //     - 更新边框坐标。\n        // 2. 根据边框坐标绘制一个虚线长方形。\n\n\n// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同\n// 时支持简单叶节点组件和复杂组件。\nclass imageeditor is\n    field all: compoundgraphic\n\n    method load() is\n        all = new compoundgraphic()\n        all.add(new dot(1, 2))\n        all.add(new circle(5, 3, 10))\n        // ...\n\n    // 将所需组件组合为复杂的组合组件。\n    method groupselected(components: array of graphic) is\n        group = new compoundgraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // 所有组件都将被绘制。\n        all.draw()\n\n\n\n# 案例\n\n使用实例： 组合模式在 java 代码中很常见,常用于表示与图形打交道的用户界面组件或代码的层次结构。\n\n下面是一些来自 java 标准程序库中的组合示例：\n\n * java.awt.container#add(component) （几乎广泛存在于 swing 组件中）\n * javax.faces.component.uicomponent#getchildren() （几乎广泛存在于 jsf ui 组件中）\n\n识别方法： 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。\n * 责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n * 你可以使用迭代器模式来遍历组合树。\n * 你可以使用访问者模式对整个组合树执行操作。\n * 你可以使用享元模式实现组合树的共享叶节点以节省内存。\n * 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之装饰模式",frontmatter:{title:"设计模式之装饰模式",date:"2015-01-15T15:41:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/2e24a8/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/10.装饰模式.md",key:"v-2c19e87c",path:"/pages/2e24a8/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适合场景",slug:"适合场景",normalizedTitle:"适合场景",charIndex:315},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:40},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:431},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:793},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2787},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5767},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:6129},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6807}],headersStr:"意图 适合场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之装饰模式\n\n\n# 意图\n\n装饰模式 (Decorator) 是一种结构型设计模式，动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。\n\n * 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n * 装饰对象包含一个真实对象的引用（reference）。\n * 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n * 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n# 适合场景\n\n * 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n * 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 部件 （Component） 声明封装器和被封装对象的公用接口。\n 2. 具体部件 （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。\n 3. 基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。\n 4. 具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。\n 5. 客户端 （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。\n\n\n# 结构代码范式\n\nComponent : 定义一个对象接口，可以给这些对象动态地添加职责。\n\ninterface Component {\n    public void operation();\n}\n\n\nConcreteComponent : 实现 Component 定义的接口。\n\nclass ConcreteComponent implements Component {\n    @Override\n    public void operation() {\n        System.out.println("初始行为");\n    }\n}\n\n\nDecorator : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。\n\nclass Decorator implements Component {\n    // 持有一个 Component 对象，和 Component 形成聚合关系\n    protected Component component;\n\n    // 传入要进一步修饰的对象\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    @Override\n    // 调用要修饰对象的原方法\n    public void operation() {\n        component.operation();\n    }\n}\n\n\nConcreteDecorator : 具体的装饰对象，起到给 Component 添加职责的功能。\n\nclass ConcreteDecoratorA extends Decorator {\n    private String addedState = "新属性1";\n\n    public ConcreteDecoratorA(Component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        System.out.println("添加属性: " + addedState);\n    }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n    public ConcreteDecoratorB(Component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        AddedBehavior();\n    }\n\n    public void AddedBehavior() {\n        System.out.println("添加行为");\n    }\n}\n\n\n【客户端】\n\npublic class DecoratorPattern {\n    public static void main(String[] args) {\n        Component component = new ConcreteComponent();\n        component.operation();\n\n        System.out.println("======================================");\n        Decorator decoratorA = new ConcreteDecoratorA(component);\n        decoratorA.operation();\n\n        System.out.println("======================================");\n        Decorator decoratorB = new ConcreteDecoratorB(decoratorA);\n        decoratorB.operation();\n    }\n}\n\n\n【输出】\n\n初始行为\n======================================\n初始行为\n添加属性: 新属性1\n======================================\n初始行为\n添加属性: 新属性1\n添加行为\n\n\n\n# 伪代码\n\n\n\n在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。\n\n程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：\n\n * 当数据即将被写入磁盘前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。\n * 当数据刚从磁盘读出后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。\n\n// 装饰可以改变组件接口所定义的操作。\ninterface DataSource is\n    method writeData(data)\n    method readData():data\n\n// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。\nclass FileDataSource implements DataSource is\n    constructor FileDataSource(filename) { ... }\n\n    method writeData(data) is\n        // 将数据写入文件。\n\n    method readData():data is\n        // 从文件读取数据。\n\n// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封\n// 装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并\n// 且负责对其进行初始化。\nclass DataSourceDecorator implements DataSource is\n    protected field wrappee: DataSource\n\n    constructor DataSourceDecorator(source: DataSource) is\n        wrappee = source\n\n    // 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些\n    // 额外的行为。\n    method writeData(data) is\n        wrappee.writeData(data)\n\n    // 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式\n    // 可简化装饰类的扩展工作。\n    method readData():data is\n        return wrappee.readData()\n\n// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。\n// 装饰必须在调用封装对象之前或之后执行额外的行为。\nclass EncryptionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. 对传递数据进行加密。\n        // 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法。\n\n    method readData():data is\n        // 1. 通过被封装对象的 readData（读取数据）方法获取数据。\n        // 2. 如果数据被加密就尝试解密。\n        // 3. 返回结果。\n\n// 你可以将对象封装在多层装饰中。\nclass CompressionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. 压缩传递数据。\n        // 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。\n\n    method readData():data is\n        // 1. 通过被封装对象的 readData（读取数据）方法获取数据。\n        // 2. 如果数据被压缩就尝试解压。\n        // 3. 返回结果。\n\n\n// 选项 1：装饰组件的简单示例\nclass Application is\n    method dumbUsageExample() is\n        source = new FileDataSource("somefile.dat")\n        source.writeData(salaryRecords)\n        // 已将明码数据写入目标文件。\n\n        source = new CompressionDecorator(source)\n        source.writeData(salaryRecords)\n        // 已将压缩数据写入目标文件。\n\n        source = new EncryptionDecorator(source)\n        // 源变量中现在包含：\n        // Encryption > Compression > FileDataSource\n        source.writeData(salaryRecords)\n        // 已将压缩且加密的数据写入目标文件。\n\n\n// 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心\n// 数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配\n// 置器获取的。\nclass SalaryManager is\n    field source: DataSource\n\n    constructor SalaryManager(source: DataSource) { ... }\n\n    method load() is\n        return source.readData()\n\n    method save() is\n        source.writeData(salaryRecords)\n    // ...其他有用的方法...\n\n\n// 程序可在运行时根据配置或环境组装不同的装饰堆桟。\nclass ApplicationConfigurator is\n    method configurationExample() is\n        source = new FileDataSource("salary.dat")\n        if (enabledEncryption)\n            source = new EncryptionDecorator(source)\n        if (enabledCompression)\n            source = new CompressionDecorator(source)\n\n        logger = new SalaryManager(source)\n        salary = logger.load()\n    // ...\n\n\n\n# 案例\n\n使用示例： 装饰模式在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。\n\nJava 核心程序库中有一些关于装饰的示例：\n\n * java.io.InputStream、 Output­Stream、 Reader 和 Writer 的所有代码都有以自身类型的对象作为参数的构造函数。\n * java.util.Collections； checked­XXX()、 synchronized­XXX() 和 unmodifiable­XXX() 方法。\n * javax.servlet.http.HttpServletRequestWrapper 和 Http­Servlet­Response­Wrapper\n\n识别方法： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。\n\n\n# 与其他模式的关系\n\n * 适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   * 责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n * 组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之装饰模式\n\n\n# 意图\n\n装饰模式 (decorator) 是一种结构型设计模式，动态地给一个对象添加一些额外的职责。就增加功能来说，decorator 模式相比生成子类更为灵活。\n\n * 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n * 装饰对象包含一个真实对象的引用（reference）。\n * 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n * 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n# 适合场景\n\n * 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n * 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 部件 （component） 声明封装器和被封装对象的公用接口。\n 2. 具体部件 （concrete component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。\n 3. 基础装饰 （base decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。\n 4. 具体装饰类 （concrete decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。\n 5. 客户端 （client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。\n\n\n# 结构代码范式\n\ncomponent : 定义一个对象接口，可以给这些对象动态地添加职责。\n\ninterface component {\n    public void operation();\n}\n\n\nconcretecomponent : 实现 component 定义的接口。\n\nclass concretecomponent implements component {\n    @override\n    public void operation() {\n        system.out.println("初始行为");\n    }\n}\n\n\ndecorator : 装饰抽象类，继承了 component， 从外类来扩展 component 类的功能，但对于 component 来说，是无需知道 decorator 的存在的。\n\nclass decorator implements component {\n    // 持有一个 component 对象，和 component 形成聚合关系\n    protected component component;\n\n    // 传入要进一步修饰的对象\n    public decorator(component component) {\n        this.component = component;\n    }\n\n    @override\n    // 调用要修饰对象的原方法\n    public void operation() {\n        component.operation();\n    }\n}\n\n\nconcretedecorator : 具体的装饰对象，起到给 component 添加职责的功能。\n\nclass concretedecoratora extends decorator {\n    private string addedstate = "新属性1";\n\n    public concretedecoratora(component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        system.out.println("添加属性: " + addedstate);\n    }\n}\n\nclass concretedecoratorb extends decorator {\n    public concretedecoratorb(component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        addedbehavior();\n    }\n\n    public void addedbehavior() {\n        system.out.println("添加行为");\n    }\n}\n\n\n【客户端】\n\npublic class decoratorpattern {\n    public static void main(string[] args) {\n        component component = new concretecomponent();\n        component.operation();\n\n        system.out.println("======================================");\n        decorator decoratora = new concretedecoratora(component);\n        decoratora.operation();\n\n        system.out.println("======================================");\n        decorator decoratorb = new concretedecoratorb(decoratora);\n        decoratorb.operation();\n    }\n}\n\n\n【输出】\n\n初始行为\n======================================\n初始行为\n添加属性: 新属性1\n======================================\n初始行为\n添加属性: 新属性1\n添加行为\n\n\n\n# 伪代码\n\n\n\n在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。\n\n程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：\n\n * 当数据即将被写入磁盘前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。\n * 当数据刚从磁盘读出后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。\n\n// 装饰可以改变组件接口所定义的操作。\ninterface datasource is\n    method writedata(data)\n    method readdata():data\n\n// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。\nclass filedatasource implements datasource is\n    constructor filedatasource(filename) { ... }\n\n    method writedata(data) is\n        // 将数据写入文件。\n\n    method readdata():data is\n        // 从文件读取数据。\n\n// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封\n// 装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并\n// 且负责对其进行初始化。\nclass datasourcedecorator implements datasource is\n    protected field wrappee: datasource\n\n    constructor datasourcedecorator(source: datasource) is\n        wrappee = source\n\n    // 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些\n    // 额外的行为。\n    method writedata(data) is\n        wrappee.writedata(data)\n\n    // 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式\n    // 可简化装饰类的扩展工作。\n    method readdata():data is\n        return wrappee.readdata()\n\n// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。\n// 装饰必须在调用封装对象之前或之后执行额外的行为。\nclass encryptiondecorator extends datasourcedecorator is\n    method writedata(data) is\n        // 1. 对传递数据进行加密。\n        // 2. 将加密后数据传递给被封装对象 writedata（写入数据）方法。\n\n    method readdata():data is\n        // 1. 通过被封装对象的 readdata（读取数据）方法获取数据。\n        // 2. 如果数据被加密就尝试解密。\n        // 3. 返回结果。\n\n// 你可以将对象封装在多层装饰中。\nclass compressiondecorator extends datasourcedecorator is\n    method writedata(data) is\n        // 1. 压缩传递数据。\n        // 2. 将压缩后数据传递给被封装对象 writedata（写入数据）方法。\n\n    method readdata():data is\n        // 1. 通过被封装对象的 readdata（读取数据）方法获取数据。\n        // 2. 如果数据被压缩就尝试解压。\n        // 3. 返回结果。\n\n\n// 选项 1：装饰组件的简单示例\nclass application is\n    method dumbusageexample() is\n        source = new filedatasource("somefile.dat")\n        source.writedata(salaryrecords)\n        // 已将明码数据写入目标文件。\n\n        source = new compressiondecorator(source)\n        source.writedata(salaryrecords)\n        // 已将压缩数据写入目标文件。\n\n        source = new encryptiondecorator(source)\n        // 源变量中现在包含：\n        // encryption > compression > filedatasource\n        source.writedata(salaryrecords)\n        // 已将压缩且加密的数据写入目标文件。\n\n\n// 选项 2：客户端使用外部数据源。salarymanager（工资管理器）对象并不关心\n// 数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配\n// 置器获取的。\nclass salarymanager is\n    field source: datasource\n\n    constructor salarymanager(source: datasource) { ... }\n\n    method load() is\n        return source.readdata()\n\n    method save() is\n        source.writedata(salaryrecords)\n    // ...其他有用的方法...\n\n\n// 程序可在运行时根据配置或环境组装不同的装饰堆桟。\nclass applicationconfigurator is\n    method configurationexample() is\n        source = new filedatasource("salary.dat")\n        if (enabledencryption)\n            source = new encryptiondecorator(source)\n        if (enabledcompression)\n            source = new compressiondecorator(source)\n\n        logger = new salarymanager(source)\n        salary = logger.load()\n    // ...\n\n\n\n# 案例\n\n使用示例： 装饰模式在 java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。\n\njava 核心程序库中有一些关于装饰的示例：\n\n * java.io.inputstream、 output­stream、 reader 和 writer 的所有代码都有以自身类型的对象作为参数的构造函数。\n * java.util.collections； checked­xxx()、 synchronized­xxx() 和 unmodifiable­xxx() 方法。\n * javax.servlet.http.httpservletrequestwrapper 和 http­servlet­response­wrapper\n\n识别方法： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。\n\n\n# 与其他模式的关系\n\n * 适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   * 责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n * 组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之外观模式",frontmatter:{title:"设计模式之外观模式",date:"2015-01-19T15:15:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/ea331b/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/11.外观模式.md",key:"v-25c50554",path:"/pages/ea331b/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:286},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:37},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:379},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:729},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1890},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3061},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:3456},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3921}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之外观模式\n\n\n# 意图\n\n外观模式 (Facade) 是一种结构型设计模式， 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n * 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。\n * 外观模式实现了子系统与客户之间的松耦合关系。\n * 外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以再系统易用性与通用性之间选择。\n * 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。\n\n\n# 适用场景\n\n * 如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n * 如果需要将子系统组织为多层结构， 可以使用外观。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 外观 （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。\n\n 2. 创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。\n\n 3. 复杂子系统 （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。\n    \n    子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。\n\n 4. 客户端 （Client） 使用外观代替对子系统对象的直接调用。\n\n\n# 结构代码范式\n\nFacade : 了解每个子系统类的功能，负责分发客户端的请求给各个子系统去处理。\n\nclass Class1 {\n    public void op1() {\n        System.out.println("方法1");\n    }\n}\n\nclass Class2 {\n    public void op2() {\n        System.out.println("方法2");\n    }\n}\n\nclass Class3 {\n    public void op3() {\n        System.out.println("方法3");\n    }\n}\n\n\nSubsystem Classes : 实现子系统功能。在不感知 Facade 的情况下，处理 Facade 对象分配的工作，\n\nclass Facade {\n    private Class1 one = new Class1();\n    private Class2 two = new Class2();\n    private Class3 three = new Class3();\n\n    public void op1() {\n        System.out.println("Facade op1()");\n        one.op1();\n    }\n\n    public void op2() {\n        System.out.println("Facade op2()");\n        two.op2();\n    }\n\n    public void op3() {\n        System.out.println("Facade op3()");\n        three.op3();\n    }\n\n    public void Method() {\n        System.out.println("Facade Method()");\n        three.op3();\n        two.op2();\n        one.op1();\n    }\n}\n\n\n【客户端】\n\npublic class FacadePattern {\n    public static void main(String[] args) {\n        Facade facade = new Facade();\n        facade.Method();\n\n        facade.op1();\n    }\n}\n\n\n【输出】\n\nFacade Method()\n方法3\n方法2\n方法1\nFacade op1()\n方法1\n\n\n\n# 伪代码\n\n在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。\n\n\n\n你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。\n\n// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法\n// 对其进行简化。\n\nclass VideoFile\n// ...\n\nclass OggCompressionCodec\n// ...\n\nclass MPEG4CompressionCodec\n// ...\n\nclass CodecFactory\n// ...\n\nclass BitrateReader\n// ...\n\nclass AudioMixer\n// ...\n\n\n// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在\n// 功能性和简洁性之间做出的权衡。\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = new CodecFactory.extract(file)\n        if (format == "mp4")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，\n// 那只需重写外观类即可。\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert("funny-cats-video.ogg", "mp4")\n        mp4.save()\n\n\n\n# 案例\n\n使用示例： 使用 Java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 API 协作时特别有用。\n\n下面是一些核心 Java 程序库中的外观示例：\n\n * javax.faces.context.FacesContext 在底层使用了 Life­Cycle、 View­Handler 和 Navigation­Handler 这几个类， 但绝大多数客户端不知道。\n * javax.faces.context.ExternalContext 在内部使用了 Servlet­Context、 Http­Session、 Http­Servlet­Request、 Http­Servlet­Response 和其他一些类。\n\n识别方法： 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。\n\n\n# 与其他模式的关系\n\n * 外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。\n * 享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。\n * 外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之外观模式\n\n\n# 意图\n\n外观模式 (facade) 是一种结构型设计模式， 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n * 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。\n * 外观模式实现了子系统与客户之间的松耦合关系。\n * 外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以再系统易用性与通用性之间选择。\n * 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。\n\n\n# 适用场景\n\n * 如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n * 如果需要将子系统组织为多层结构， 可以使用外观。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 外观 （facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。\n\n 2. 创建附加外观 （additional facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。\n\n 3. 复杂子系统 （complex subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。\n    \n    子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。\n\n 4. 客户端 （client） 使用外观代替对子系统对象的直接调用。\n\n\n# 结构代码范式\n\nfacade : 了解每个子系统类的功能，负责分发客户端的请求给各个子系统去处理。\n\nclass class1 {\n    public void op1() {\n        system.out.println("方法1");\n    }\n}\n\nclass class2 {\n    public void op2() {\n        system.out.println("方法2");\n    }\n}\n\nclass class3 {\n    public void op3() {\n        system.out.println("方法3");\n    }\n}\n\n\nsubsystem classes : 实现子系统功能。在不感知 facade 的情况下，处理 facade 对象分配的工作，\n\nclass facade {\n    private class1 one = new class1();\n    private class2 two = new class2();\n    private class3 three = new class3();\n\n    public void op1() {\n        system.out.println("facade op1()");\n        one.op1();\n    }\n\n    public void op2() {\n        system.out.println("facade op2()");\n        two.op2();\n    }\n\n    public void op3() {\n        system.out.println("facade op3()");\n        three.op3();\n    }\n\n    public void method() {\n        system.out.println("facade method()");\n        three.op3();\n        two.op2();\n        one.op1();\n    }\n}\n\n\n【客户端】\n\npublic class facadepattern {\n    public static void main(string[] args) {\n        facade facade = new facade();\n        facade.method();\n\n        facade.op1();\n    }\n}\n\n\n【输出】\n\nfacade method()\n方法3\n方法2\n方法1\nfacade op1()\n方法1\n\n\n\n# 伪代码\n\n在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。\n\n\n\n你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。\n\n// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法\n// 对其进行简化。\n\nclass videofile\n// ...\n\nclass oggcompressioncodec\n// ...\n\nclass mpeg4compressioncodec\n// ...\n\nclass codecfactory\n// ...\n\nclass bitratereader\n// ...\n\nclass audiomixer\n// ...\n\n\n// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在\n// 功能性和简洁性之间做出的权衡。\nclass videoconverter is\n    method convert(filename, format):file is\n        file = new videofile(filename)\n        sourcecodec = new codecfactory.extract(file)\n        if (format == "mp4")\n            destinationcodec = new mpeg4compressioncodec()\n        else\n            destinationcodec = new oggcompressioncodec()\n        buffer = bitratereader.read(filename, sourcecodec)\n        result = bitratereader.convert(buffer, destinationcodec)\n        result = (new audiomixer()).fix(result)\n        return new file(result)\n\n// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，\n// 那只需重写外观类即可。\nclass application is\n    method main() is\n        convertor = new videoconverter()\n        mp4 = convertor.convert("funny-cats-video.ogg", "mp4")\n        mp4.save()\n\n\n\n# 案例\n\n使用示例： 使用 java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 api 协作时特别有用。\n\n下面是一些核心 java 程序库中的外观示例：\n\n * javax.faces.context.facescontext 在底层使用了 life­cycle、 view­handler 和 navigation­handler 这几个类， 但绝大多数客户端不知道。\n * javax.faces.context.externalcontext 在内部使用了 servlet­context、 http­session、 http­servlet­request、 http­servlet­response 和其他一些类。\n\n识别方法： 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。\n\n\n# 与其他模式的关系\n\n * 外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。\n * 享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。\n * 外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之享元模式",frontmatter:{title:"设计模式之享元模式",date:"2015-01-19T09:48:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/9147e7/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/12.享元模式.md",key:"v-6e2d857c",path:"/pages/9147e7/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:111},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:40},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:164},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:749},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2624},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4181},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:4406},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4633}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之享元模式\n\n\n# 意图\n\n享元模式 (Flyweight) 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n\n\n# 适用场景\n\n * 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。\n 2. 享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。\n 3. 情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。\n 4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。\n 5. 客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。\n 6. 享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。\n\n\n# 结构代码范式\n\nFlyweight : 它是所有具体享元类的超类或接口，通过这个接口，Flyweight 可以接受并作用于外部状态。\n\nabstract class Flyweight {\n    public abstract void operation(int extrinsicstates);\n}\n\n\nConcreteFlyweight : 是继承 Flyweight 超类或实现 Flyweight 接口，并为内部状态增加存储空间。\n\nclass ConcreteFlyweight extends Flyweight {\n    @Override\n    public void operation(int extrinsicstates) {\n        System.out.println("共享的Flyweight : " + extrinsicstates);\n    }\n}\n\n\nUnsharedConcreteFlyweight : 指那些不需要共享的 Flyweight 子类，因为 Flyweight 接口共享成为可能，但它并不强制共享。\n\nclass UnsharedConcreteFlyweight extends Flyweight {\n    @Override\n    public void operation(int extrinsicstates) {\n        System.out.println("不共享的Flyweight : " + extrinsicstates);\n    }\n}\n\n\nFlywightFactory :是一个享元工厂，用来创建并管理 Flyweight 对象。它主要是用来确保合理地共享 Flyweight ，当用户请求一个 Flyweight 时， FlyweightFactory 对象提供一个已创建的实例或创建一个（如果对象不存在的话）。\n\nclass FlywightFactory {\n    private Hashtable<String, Flyweight> flyweights = new Hashtable<String, Flyweight>();\n\n    public FlywightFactory() {\n        flyweights.put("X", new ConcreteFlyweight());\n        flyweights.put("Y", new ConcreteFlyweight());\n        flyweights.put("Z", new ConcreteFlyweight());\n    }\n\n    public Flyweight getFlyweight(String key) {\n        return ((Flyweight)flyweights.get(key));\n    }\n}\n\n\n客户端\n\npublic class FlyweightPattern {\n    public static void main(String[] args) {\n        int extrinsicstates = 1;\n        FlywightFactory factory = new FlywightFactory();\n\n        Flyweight fx = factory.getFlyweight("X");\n        fx.operation(extrinsicstates);\n\n        Flyweight fy = factory.getFlyweight("Y");\n        fy.operation(++extrinsicstates);\n\n        Flyweight fz = factory.getFlyweight("Z");\n        fz.operation(++extrinsicstates);\n\n        Flyweight uf = new UnsharedConcreteFlyweight();\n        uf.operation(++extrinsicstates);\n    }\n}\n\n\n输出\n\n共享的Flyweight : 1\n共享的Flyweight : 2\n共享的Flyweight : 3\n不共享的Flyweight : 4\n\n\n\n# 伪代码\n\n\n\n在本例中， 享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存。\n\n该模式从主要的 树Tree 类中抽取内在状态， 并将其移动到享元类 树种类Tree­Type 之中。\n\n最初程序需要在多个对象中存储相同数据， 而现在仅需在几个享元对象中保存数据， 然后在作为情景的 树对象中连入享元即可。 客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为， 并能在需要时复用对象。\n\n// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一\n// 的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜\n// 色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗\n// 费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象\n// 中，然后让众多的单个树对象去引用它。\nclass TreeType is\n    field name\n    field color\n    field texture\n    constructor TreeType(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. 创建特定类型、颜色和纹理的位图。\n        // 2. 在画布坐标 (X,Y) 处绘制位图。\n\n// 享元工厂决定是否复用已有享元或者创建一个新的对象。\nclass TreeFactory is\n    static field treeTypes: collection of tree types\n    static method getTreeType(name, color, texture) is\n        type = treeTypes.find(name, color, texture)\n        if (type == null)\n            type = new TreeType(name, color, texture)\n            treeTypes.add(type)\n        return type\n\n// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们\n// 体积很小：仅有两个整型坐标和一个引用成员变量。\nclass Tree is\n    field x,y\n    field type: TreeType\n    constructor Tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// 树（Tree）和森林（Forest）类是享元的客户端。如果不打算继续对树类进行开\n// 发，你可以将它们合并。\nclass Forest is\n    field trees: collection of Trees\n\n    method plantTree(x, y, name, color, texture) is\n        type = TreeFactory.getTreeType(name, color, texture)\n        tree = new Tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n\n\n\n# 案例\n\n使用示例： 享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。\n\n享元模式在核心 Java 程序库中的示例：\n\n * java.lang.Integer#valueOf(int) （以及 Boolean、 Byte、 Character、 Short、 Long 和 Big­Decimal）\n\n识别方法： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。\n\n\n# 与其他模式的关系\n\n * 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。\n * 享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之享元模式\n\n\n# 意图\n\n享元模式 (flyweight) 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n\n\n# 适用场景\n\n * 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。\n 2. 享元 （flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。\n 3. 情景 （context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。\n 4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。\n 5. 客户端 （client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。\n 6. 享元工厂 （flyweight factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。\n\n\n# 结构代码范式\n\nflyweight : 它是所有具体享元类的超类或接口，通过这个接口，flyweight 可以接受并作用于外部状态。\n\nabstract class flyweight {\n    public abstract void operation(int extrinsicstates);\n}\n\n\nconcreteflyweight : 是继承 flyweight 超类或实现 flyweight 接口，并为内部状态增加存储空间。\n\nclass concreteflyweight extends flyweight {\n    @override\n    public void operation(int extrinsicstates) {\n        system.out.println("共享的flyweight : " + extrinsicstates);\n    }\n}\n\n\nunsharedconcreteflyweight : 指那些不需要共享的 flyweight 子类，因为 flyweight 接口共享成为可能，但它并不强制共享。\n\nclass unsharedconcreteflyweight extends flyweight {\n    @override\n    public void operation(int extrinsicstates) {\n        system.out.println("不共享的flyweight : " + extrinsicstates);\n    }\n}\n\n\nflywightfactory :是一个享元工厂，用来创建并管理 flyweight 对象。它主要是用来确保合理地共享 flyweight ，当用户请求一个 flyweight 时， flyweightfactory 对象提供一个已创建的实例或创建一个（如果对象不存在的话）。\n\nclass flywightfactory {\n    private hashtable<string, flyweight> flyweights = new hashtable<string, flyweight>();\n\n    public flywightfactory() {\n        flyweights.put("x", new concreteflyweight());\n        flyweights.put("y", new concreteflyweight());\n        flyweights.put("z", new concreteflyweight());\n    }\n\n    public flyweight getflyweight(string key) {\n        return ((flyweight)flyweights.get(key));\n    }\n}\n\n\n客户端\n\npublic class flyweightpattern {\n    public static void main(string[] args) {\n        int extrinsicstates = 1;\n        flywightfactory factory = new flywightfactory();\n\n        flyweight fx = factory.getflyweight("x");\n        fx.operation(extrinsicstates);\n\n        flyweight fy = factory.getflyweight("y");\n        fy.operation(++extrinsicstates);\n\n        flyweight fz = factory.getflyweight("z");\n        fz.operation(++extrinsicstates);\n\n        flyweight uf = new unsharedconcreteflyweight();\n        uf.operation(++extrinsicstates);\n    }\n}\n\n\n输出\n\n共享的flyweight : 1\n共享的flyweight : 2\n共享的flyweight : 3\n不共享的flyweight : 4\n\n\n\n# 伪代码\n\n\n\n在本例中， 享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存。\n\n该模式从主要的 树tree 类中抽取内在状态， 并将其移动到享元类 树种类tree­type 之中。\n\n最初程序需要在多个对象中存储相同数据， 而现在仅需在几个享元对象中保存数据， 然后在作为情景的 树对象中连入享元即可。 客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为， 并能在需要时复用对象。\n\n// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一\n// 的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜\n// 色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗\n// 费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象\n// 中，然后让众多的单个树对象去引用它。\nclass treetype is\n    field name\n    field color\n    field texture\n    constructor treetype(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. 创建特定类型、颜色和纹理的位图。\n        // 2. 在画布坐标 (x,y) 处绘制位图。\n\n// 享元工厂决定是否复用已有享元或者创建一个新的对象。\nclass treefactory is\n    static field treetypes: collection of tree types\n    static method gettreetype(name, color, texture) is\n        type = treetypes.find(name, color, texture)\n        if (type == null)\n            type = new treetype(name, color, texture)\n            treetypes.add(type)\n        return type\n\n// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们\n// 体积很小：仅有两个整型坐标和一个引用成员变量。\nclass tree is\n    field x,y\n    field type: treetype\n    constructor tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// 树（tree）和森林（forest）类是享元的客户端。如果不打算继续对树类进行开\n// 发，你可以将它们合并。\nclass forest is\n    field trees: collection of trees\n\n    method planttree(x, y, name, color, texture) is\n        type = treefactory.gettreetype(name, color, texture)\n        tree = new tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n\n\n\n# 案例\n\n使用示例： 享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。\n\n享元模式在核心 java 程序库中的示例：\n\n * java.lang.integer#valueof(int) （以及 boolean、 byte、 character、 short、 long 和 big­decimal）\n\n识别方法： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。\n\n\n# 与其他模式的关系\n\n * 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。\n * 享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之代理模式",frontmatter:{title:"设计模式之代理模式",date:"2015-01-19T11:38:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/5a865c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/13.代理模式.md",key:"v-51d6ac9c",path:"/pages/5a865c/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:184},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:36},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:500},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:771},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1363},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3597},{level:3,title:"注解+反射+代理消除重复代码",slug:"注解-反射-代理消除重复代码",normalizedTitle:"注解+反射+代理消除重复代码",charIndex:3927},{level:4,title:"问题版本",slug:"问题版本",normalizedTitle:"问题版本",charIndex:4250},{level:4,title:"优化版本",slug:"优化版本",normalizedTitle:"优化版本",charIndex:6314},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:11151},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11430}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 注解+反射+代理消除重复代码 问题版本 优化版本 与其他模式的关系 参考资料",content:'# 设计模式之代理模式\n\n\n# 意图\n\n代理模式 (Proxy) 是一种结构型设计模式， 为其他对象提供一种代理以控制对这个对象的访问。\n\n * 代理模式介绍了一种访问对象的间接等级。\n * 一个远程代理可以隐藏一个对象在不同地址空间的细节。\n * 一个虚拟代理可以根据需要最优化创建对象的开销。\n * 而安全代理和智能指引都允许访问对象的同时处理其他事务。\n\n\n# 适用场景\n\n * 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n * 访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n * 本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n * 记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n * 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n 2. 服务 （Service） 类提供了一些实用的业务逻辑。\n 3. 代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。\n 4. 客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。\n\n\n# 结构代码范式\n\nSubject : 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。\n\nabstract class Subject {\n    public abstract void Request();\n}\n\n\nRealSubject : 定义 Proxy 所代表的真实实体。\n\nclass RealSubject extends Subject {\n    @Override\n    public void Request() {\n        System.out.println("真实的请求");\n    }\n}\n\n\nProxy : 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass Proxy extends Subject {\n    private RealSubject real;\n\n    @Override\n    public void Request() {\n        if (null == real) {\n            real = new RealSubject();\n        }\n        real.Request();\n    }\n}\n\n\n\n# 伪代码\n\n本例演示如何使用代理模式在第三方腾讯视频 （TencentVideo， 代码示例中记为 TV） 程序库中添加延迟初始化和缓存。\n\n\n\n程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。\n\n代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。\n\n// 远程服务接口。\ninterface ThirdPartyTVLib is\n    method listVideos()\n    method getVideoInfo(id)\n    method downloadVideo(id)\n\n// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于\n// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息\n// 一模一样，程序的速度依然会减慢。\nclass ThirdPartyTVClass implements ThirdPartyTVLib is\n    method listVideos() is\n        // 向腾讯视频发送一个 API 请求。\n\n    method getVideoInfo(id) is\n        // 获取某个视频的元数据。\n\n    method downloadVideo(id) is\n        // 从腾讯视频下载一个视频文件。\n\n// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无\n// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签\n// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入\n// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。\nclass CachedTVClass implements ThirdPartyTVLib is\n    private field service: ThirdPartyTVLib\n    private field listCache, videoCache\n    field needReset\n\n    constructor CachedTVClass(service: ThirdPartyTVLib) is\n        this.service = service\n\n    method listVideos() is\n        if (listCache == null || needReset)\n            listCache = service.listVideos()\n        return listCache\n\n    method getVideoInfo(id) is\n        if (videoCache == null || needReset)\n            videoCache = service.getVideoInfo(id)\n        return videoCache\n\n    method downloadVideo(id) is\n        if (!downloadExists(id) || needReset)\n            service.downloadVideo(id)\n\n// 之前直接与服务对象交互的 GUI 类不需要改变，前提是它仅通过接口与服务对\n// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实\n// 现了相同的接口。\nclass TVManager is\n    protected field service: ThirdPartyTVLib\n\n    constructor TVManager(service: ThirdPartyTVLib) is\n        this.service = service\n\n    method renderVideoPage(id) is\n        info = service.getVideoInfo(id)\n        // 渲染视频页面。\n\n    method renderListPanel() is\n        list = service.listVideos()\n        // 渲染视频缩略图列表。\n\n    method reactOnUserInput() is\n        renderVideoPage()\n        renderListPanel()\n\n// 程序可在运行时对代理进行配置。\nclass Application is\n    method init() is\n        aTVService = new ThirdPartyTVClass()\n        aTVProxy = new CachedTVClass(aTVService)\n        manager = new TVManager(aTVProxy)\n        manager.reactOnUserInput()\n\n\n\n# 案例\n\n使用示例： 尽管代理模式在绝大多数 Java 程序中并不常见， 但它在一些特殊情况下仍然非常方便。 当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的。\n\nJava 标准程序库中的一些代理模式的示例：\n\n * java.lang.reflect.Proxy\n * java.rmi.*\n * javax.ejb.EJB （查看评论）\n * javax.inject.Inject （查看评论）\n * javax.persistence.PersistenceContext\n\n识别方法： 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。\n\n\n# 注解+反射+代理消除重复代码\n\n假设银行提供了一些 API 接口，对参数的序列化有点特殊，不使用 JSON，而是需要我们把参数依次拼在一起构成一个大字符串。\n\n按照银行提供的 API 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。因为每一种参数都有固定长度，未达到长度时需要做填充处理：\n\n * 字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；\n * 数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；\n * 货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行 左填充。\n\n对所有参数做 MD5 操作作为签名（为了方便理解，Demo 中不涉及加盐处理）。\n\n# 问题版本\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.http.client.fluent.Request;\nimport org.apache.http.entity.ContentType;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class BankService {\n\n    public static String createUser(String name, String identity, String mobile, int age) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-10s", name).replace(\' \', \'_\'));\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-18s", identity).replace(\' \', \'_\'));\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%05d", age));\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-11s", mobile).replace(\' \', \'_\'));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post("http://localhost:45678/reflection/bank/createUser")\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n\n    public static String pay(long userId, BigDecimal amount) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%020d", userId));\n        //金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%010d", amount.setScale(2, RoundingMode.DOWN).multiply(new BigDecimal("100")).longValue()));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post("http://localhost:45678/reflection/bank/pay")\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n}\n\n\n在以上的代码版本中，存在以下问题：\n\n * 三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 Bug；\n * 处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；\n * 实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；\n * 代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。\n\n# 优化版本\n\n针对上面代码版本中的问题，可以使用 注解+反射+代理模式 解决重复代码。\n\n【注解一】\n\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Inherited\npublic @interface BankAPI {\n\n    String desc() default "";\n\n    String url() default "";\n\n}\n\n\n【注解二】\n\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@Documented\n@Inherited\npublic @interface BankAPIField {\n\n    int order() default -1;\n\n    int length() default -1;\n\n    String type() default "";\n\n}\n\n\n【抽象类】\n\nabstract class AbstractAPI {}\n\n\n【代理类】\n\n@Slf4j\npublic class BetterBankService {\n\n    public static String createUser(String name, String identity, String mobile, int age) throws IOException {\n        CreateUserAPI createUserAPI = new CreateUserAPI();\n        createUserAPI.setName(name);\n        createUserAPI.setIdentity(identity);\n        createUserAPI.setAge(age);\n        createUserAPI.setMobile(mobile);\n        return remoteCall(createUserAPI);\n    }\n\n    public static String pay(long userId, BigDecimal amount) throws IOException {\n        PayAPI payAPI = new PayAPI();\n        payAPI.setUserId(userId);\n        payAPI.setAmount(amount);\n        return remoteCall(payAPI);\n    }\n\n    private static String remoteCall(AbstractAPI api) throws IOException {\n        //从BankAPI注解获取请求地址\n        BankAPI bankAPI = api.getClass().getAnnotation(BankAPI.class);\n        bankAPI.url();\n        StringBuilder stringBuilder = new StringBuilder();\n        Arrays.stream(api.getClass().getDeclaredFields()) //获得所有字段\n            .filter(field -> field.isAnnotationPresent(BankAPIField.class)) //查找标记了注解的字段\n            .sorted(Comparator.comparingInt(a -> a.getAnnotation(BankAPIField.class).order())) //根据注解中的order对字段排序\n            .peek(field -> field.setAccessible(true)) //设置可以访问私有字段\n            .forEach(field -> {\n                //获得注解\n                BankAPIField bankAPIField = field.getAnnotation(BankAPIField.class);\n                Object value = "";\n                try {\n                    //反射获取字段值\n                    value = field.get(api);\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                //根据字段类型以正确的填充方式格式化字符串\n                switch (bankAPIField.type()) {\n                    case "S": {\n                        stringBuilder.append(\n                            String.format("%-" + bankAPIField.length() + "s", value.toString()).replace(\' \', \'_\'));\n                        break;\n                    }\n                    case "N": {\n                        stringBuilder.append(\n                            String.format("%" + bankAPIField.length() + "s", value.toString()).replace(\' \', \'0\'));\n                        break;\n                    }\n                    case "M": {\n                        if (!(value instanceof BigDecimal)) {\n                            throw new RuntimeException(\n                                String.format("{} 的 {} 必须是BigDecimal", api, field));\n                        }\n                        stringBuilder.append(String.format("%0" + bankAPIField.length() + "d",\n                            ((BigDecimal) value).setScale(2, RoundingMode.DOWN)\n                                .multiply(new BigDecimal("100"))\n                                .longValue()));\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n        //签名逻辑\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        String param = stringBuilder.toString();\n        long begin = System.currentTimeMillis();\n        //发请求\n        String result = Request.Post("http://localhost:45678/reflection" + bankAPI.url())\n            .bodyString(param, ContentType.APPLICATION_JSON)\n            .execute().returnContent().asString();\n        log.info("调用银行API {} url:{} 参数:{} 耗时:{}ms", bankAPI.desc(), bankAPI.url(), param,\n            System.currentTimeMillis() - begin);\n        return result;\n    }\n\n}\n\n\n【注解修饰的 API 接口一】\n\nimport lombok.Data;\n\n@BankAPI(url = "/bank/createUser", desc = "创建用户接口")\n@Data\npublic class CreateUserAPI extends AbstractAPI {\n\n    @BankAPIField(order = 1, type = "S", length = 10)\n    private String name;\n    @BankAPIField(order = 2, type = "S", length = 18)\n    private String identity;\n    @BankAPIField(order = 4, type = "S", length = 11)\n    private String mobile;\n    @BankAPIField(order = 3, type = "N", length = 5)\n    private int age;\n\n}\n\n\n【注解修饰的 API 接口二】\n\nimport lombok.Data;\n\nimport java.math.BigDecimal;\n\n@BankAPI(url = "/bank/pay", desc = "支付接口")\n@Data\npublic class PayAPI extends AbstractAPI {\n\n    @BankAPIField(order = 1, type = "N", length = 20)\n    private long userId;\n    @BankAPIField(order = 2, type = "M", length = 10)\n    private BigDecimal amount;\n\n}\n\n\n\n# 与其他模式的关系\n\n * 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n * 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之代理模式\n\n\n# 意图\n\n代理模式 (proxy) 是一种结构型设计模式， 为其他对象提供一种代理以控制对这个对象的访问。\n\n * 代理模式介绍了一种访问对象的间接等级。\n * 一个远程代理可以隐藏一个对象在不同地址空间的细节。\n * 一个虚拟代理可以根据需要最优化创建对象的开销。\n * 而安全代理和智能指引都允许访问对象的同时处理其他事务。\n\n\n# 适用场景\n\n * 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n * 访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n * 本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n * 记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n * 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 服务接口 （service interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n 2. 服务 （service） 类提供了一些实用的业务逻辑。\n 3. 代理 （proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。\n 4. 客户端 （client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。\n\n\n# 结构代码范式\n\nsubject : 定义了 realsubject 和 proxy 的公共接口，这样就在任何使用 realsubject 的地方都可以使用 proxy 。\n\nabstract class subject {\n    public abstract void request();\n}\n\n\nrealsubject : 定义 proxy 所代表的真实实体。\n\nclass realsubject extends subject {\n    @override\n    public void request() {\n        system.out.println("真实的请求");\n    }\n}\n\n\nproxy : 保存一个引用使得代理可以访问实体，并提供一个与 subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass proxy extends subject {\n    private realsubject real;\n\n    @override\n    public void request() {\n        if (null == real) {\n            real = new realsubject();\n        }\n        real.request();\n    }\n}\n\n\n\n# 伪代码\n\n本例演示如何使用代理模式在第三方腾讯视频 （tencentvideo， 代码示例中记为 tv） 程序库中添加延迟初始化和缓存。\n\n\n\n程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。\n\n代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。\n\n// 远程服务接口。\ninterface thirdpartytvlib is\n    method listvideos()\n    method getvideoinfo(id)\n    method downloadvideo(id)\n\n// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于\n// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息\n// 一模一样，程序的速度依然会减慢。\nclass thirdpartytvclass implements thirdpartytvlib is\n    method listvideos() is\n        // 向腾讯视频发送一个 api 请求。\n\n    method getvideoinfo(id) is\n        // 获取某个视频的元数据。\n\n    method downloadvideo(id) is\n        // 从腾讯视频下载一个视频文件。\n\n// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无\n// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签\n// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入\n// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。\nclass cachedtvclass implements thirdpartytvlib is\n    private field service: thirdpartytvlib\n    private field listcache, videocache\n    field needreset\n\n    constructor cachedtvclass(service: thirdpartytvlib) is\n        this.service = service\n\n    method listvideos() is\n        if (listcache == null || needreset)\n            listcache = service.listvideos()\n        return listcache\n\n    method getvideoinfo(id) is\n        if (videocache == null || needreset)\n            videocache = service.getvideoinfo(id)\n        return videocache\n\n    method downloadvideo(id) is\n        if (!downloadexists(id) || needreset)\n            service.downloadvideo(id)\n\n// 之前直接与服务对象交互的 gui 类不需要改变，前提是它仅通过接口与服务对\n// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实\n// 现了相同的接口。\nclass tvmanager is\n    protected field service: thirdpartytvlib\n\n    constructor tvmanager(service: thirdpartytvlib) is\n        this.service = service\n\n    method rendervideopage(id) is\n        info = service.getvideoinfo(id)\n        // 渲染视频页面。\n\n    method renderlistpanel() is\n        list = service.listvideos()\n        // 渲染视频缩略图列表。\n\n    method reactonuserinput() is\n        rendervideopage()\n        renderlistpanel()\n\n// 程序可在运行时对代理进行配置。\nclass application is\n    method init() is\n        atvservice = new thirdpartytvclass()\n        atvproxy = new cachedtvclass(atvservice)\n        manager = new tvmanager(atvproxy)\n        manager.reactonuserinput()\n\n\n\n# 案例\n\n使用示例： 尽管代理模式在绝大多数 java 程序中并不常见， 但它在一些特殊情况下仍然非常方便。 当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的。\n\njava 标准程序库中的一些代理模式的示例：\n\n * java.lang.reflect.proxy\n * java.rmi.*\n * javax.ejb.ejb （查看评论）\n * javax.inject.inject （查看评论）\n * javax.persistence.persistencecontext\n\n识别方法： 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。\n\n\n# 注解+反射+代理消除重复代码\n\n假设银行提供了一些 api 接口，对参数的序列化有点特殊，不使用 json，而是需要我们把参数依次拼在一起构成一个大字符串。\n\n按照银行提供的 api 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。因为每一种参数都有固定长度，未达到长度时需要做填充处理：\n\n * 字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；\n * 数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；\n * 货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行 左填充。\n\n对所有参数做 md5 操作作为签名（为了方便理解，demo 中不涉及加盐处理）。\n\n# 问题版本\n\nimport org.apache.commons.codec.digest.digestutils;\nimport org.apache.http.client.fluent.request;\nimport org.apache.http.entity.contenttype;\n\nimport java.io.ioexception;\nimport java.math.bigdecimal;\nimport java.math.roundingmode;\n\npublic class bankservice {\n\n    public static string createuser(string name, string identity, string mobile, int age) throws ioexception {\n        stringbuilder stringbuilder = new stringbuilder();\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-10s", name).replace(\' \', \'_\'));\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-18s", identity).replace(\' \', \'_\'));\n        //数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%05d", age));\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-11s", mobile).replace(\' \', \'_\'));\n        //最后加上md5作为签名\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        return request.post("http://localhost:45678/reflection/bank/createuser")\n                .bodystring(stringbuilder.tostring(), contenttype.application_json)\n                .execute().returncontent().asstring();\n    }\n\n    public static string pay(long userid, bigdecimal amount) throws ioexception {\n        stringbuilder stringbuilder = new stringbuilder();\n        //数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%020d", userid));\n        //金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%010d", amount.setscale(2, roundingmode.down).multiply(new bigdecimal("100")).longvalue()));\n        //最后加上md5作为签名\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        return request.post("http://localhost:45678/reflection/bank/pay")\n                .bodystring(stringbuilder.tostring(), contenttype.application_json)\n                .execute().returncontent().asstring();\n    }\n}\n\n\n在以上的代码版本中，存在以下问题：\n\n * 三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 bug；\n * 处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；\n * 实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；\n * 代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。\n\n# 优化版本\n\n针对上面代码版本中的问题，可以使用 注解+反射+代理模式 解决重复代码。\n\n【注解一】\n\nimport java.lang.annotation.*;\n\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\n@documented\n@inherited\npublic @interface bankapi {\n\n    string desc() default "";\n\n    string url() default "";\n\n}\n\n\n【注解二】\n\nimport java.lang.annotation.*;\n\n@retention(retentionpolicy.runtime)\n@target(elementtype.field)\n@documented\n@inherited\npublic @interface bankapifield {\n\n    int order() default -1;\n\n    int length() default -1;\n\n    string type() default "";\n\n}\n\n\n【抽象类】\n\nabstract class abstractapi {}\n\n\n【代理类】\n\n@slf4j\npublic class betterbankservice {\n\n    public static string createuser(string name, string identity, string mobile, int age) throws ioexception {\n        createuserapi createuserapi = new createuserapi();\n        createuserapi.setname(name);\n        createuserapi.setidentity(identity);\n        createuserapi.setage(age);\n        createuserapi.setmobile(mobile);\n        return remotecall(createuserapi);\n    }\n\n    public static string pay(long userid, bigdecimal amount) throws ioexception {\n        payapi payapi = new payapi();\n        payapi.setuserid(userid);\n        payapi.setamount(amount);\n        return remotecall(payapi);\n    }\n\n    private static string remotecall(abstractapi api) throws ioexception {\n        //从bankapi注解获取请求地址\n        bankapi bankapi = api.getclass().getannotation(bankapi.class);\n        bankapi.url();\n        stringbuilder stringbuilder = new stringbuilder();\n        arrays.stream(api.getclass().getdeclaredfields()) //获得所有字段\n            .filter(field -> field.isannotationpresent(bankapifield.class)) //查找标记了注解的字段\n            .sorted(comparator.comparingint(a -> a.getannotation(bankapifield.class).order())) //根据注解中的order对字段排序\n            .peek(field -> field.setaccessible(true)) //设置可以访问私有字段\n            .foreach(field -> {\n                //获得注解\n                bankapifield bankapifield = field.getannotation(bankapifield.class);\n                object value = "";\n                try {\n                    //反射获取字段值\n                    value = field.get(api);\n                } catch (illegalaccessexception e) {\n                    e.printstacktrace();\n                }\n                //根据字段类型以正确的填充方式格式化字符串\n                switch (bankapifield.type()) {\n                    case "s": {\n                        stringbuilder.append(\n                            string.format("%-" + bankapifield.length() + "s", value.tostring()).replace(\' \', \'_\'));\n                        break;\n                    }\n                    case "n": {\n                        stringbuilder.append(\n                            string.format("%" + bankapifield.length() + "s", value.tostring()).replace(\' \', \'0\'));\n                        break;\n                    }\n                    case "m": {\n                        if (!(value instanceof bigdecimal)) {\n                            throw new runtimeexception(\n                                string.format("{} 的 {} 必须是bigdecimal", api, field));\n                        }\n                        stringbuilder.append(string.format("%0" + bankapifield.length() + "d",\n                            ((bigdecimal) value).setscale(2, roundingmode.down)\n                                .multiply(new bigdecimal("100"))\n                                .longvalue()));\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n        //签名逻辑\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        string param = stringbuilder.tostring();\n        long begin = system.currenttimemillis();\n        //发请求\n        string result = request.post("http://localhost:45678/reflection" + bankapi.url())\n            .bodystring(param, contenttype.application_json)\n            .execute().returncontent().asstring();\n        log.info("调用银行api {} url:{} 参数:{} 耗时:{}ms", bankapi.desc(), bankapi.url(), param,\n            system.currenttimemillis() - begin);\n        return result;\n    }\n\n}\n\n\n【注解修饰的 api 接口一】\n\nimport lombok.data;\n\n@bankapi(url = "/bank/createuser", desc = "创建用户接口")\n@data\npublic class createuserapi extends abstractapi {\n\n    @bankapifield(order = 1, type = "s", length = 10)\n    private string name;\n    @bankapifield(order = 2, type = "s", length = 18)\n    private string identity;\n    @bankapifield(order = 4, type = "s", length = 11)\n    private string mobile;\n    @bankapifield(order = 3, type = "n", length = 5)\n    private int age;\n\n}\n\n\n【注解修饰的 api 接口二】\n\nimport lombok.data;\n\nimport java.math.bigdecimal;\n\n@bankapi(url = "/bank/pay", desc = "支付接口")\n@data\npublic class payapi extends abstractapi {\n\n    @bankapifield(order = 1, type = "n", length = 20)\n    private long userid;\n    @bankapifield(order = 2, type = "m", length = 10)\n    private bigdecimal amount;\n\n}\n\n\n\n# 与其他模式的关系\n\n * 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n * 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之模板方法模式",frontmatter:{title:"设计模式之模板方法模式",date:"2015-01-06T09:43:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/6eaeb4/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/14.模板方法模式.md",key:"v-f82d5ee0",path:"/pages/6eaeb4/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:18},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:486},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:83},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:622},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:766},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1899},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3653},{level:2,title:"案例",slug:"案例-2",normalizedTitle:"案例",charIndex:3653},{level:3,title:"消除 if ... else 和重复代码",slug:"消除-if-else-和重复代码",normalizedTitle:"消除 if ... else 和重复代码",charIndex:5897},{level:4,title:"问题 1.0 版本",slug:"问题-1-0-版本",normalizedTitle:"问题 1.0 版本",charIndex:6060},{level:4,title:"修正版本",slug:"修正版本",normalizedTitle:"修正版本",charIndex:11542},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:14810},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15006}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 案例 消除 if ... else 和重复代码 问题 1.0 版本 修正版本 与其他模式的关系 参考资料",content:'# 设计模式之模板方法模式\n\n\n# 意图\n\n模板方法模式 (Template Method) 是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。，没有关联关系。 因此，在模板方法模式的类结构图中，只有继承关系。\n\n模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。\n\n代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。\n\n在模板方法模式中，首先父类会定义一个算法的框架，即实现算法所必须的所有方法。\n\n * 其中，具有共性的代码放在父类的具体方法中。\n\n * 各个子类特殊性的代码放在子类的具体方法中。但是父类中需要有对应抽象方法声明。\n\n * 钩子方法可以让子类决定是否对算法的不同点进行挂钩。\n\n\n# 适用场景\n\n * 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n * 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象类 （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象类型， 也可以提供一些默认实现。\n 2. 具体类 （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。\n\n\n# 结构代码范式\n\nAbstractClass : 抽象类，定义并实现一个模板方法。这个模板方法定义了算法的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类去实现。顶级逻辑也有可能调用一些具体方法。\n\nabstract class AbstractClass {\n    public abstract void PrimitiveOperation1();\n    public abstract void PrimitiveOperation2();\n\n    public void TemplateMethod() {\n        PrimitiveOperation1();\n        PrimitiveOperation2();\n    }\n}\n\n\nConcreteClass : 实现实现父类所定义的一个或多个抽象方法。\n\nclass ConcreteClassA extends AbstractClass {\n    @Override\n    public void PrimitiveOperation1() {\n        System.out.println("具体A类方法1");\n    }\n\n    @Override\n    public void PrimitiveOperation2() {\n        System.out.println("具体A类方法2");\n    }\n}\n\nclass ConcreteClassB extends AbstractClass {\n    @Override\n    public void PrimitiveOperation1() {\n        System.out.println("具体B类方法1");\n    }\n\n    @Override\n    public void PrimitiveOperation2() {\n        System.out.println("具体B类方法2");\n    }\n}\n\n\n客户端\n\npublic class TemplateMethodPattern {\n    public static void main(String[] args) {\n        AbstractClass objA = new ConcreteClassA();\n        AbstractClass objB = new ConcreteClassB();\n        objA.TemplateMethod();\n        objB.TemplateMethod();\n    }\n}\n\n\n\n# 伪代码\n\n本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。\n\n\n\n一款简单游戏的 AI 类。\n\n游戏中所有的种族都有几乎同类的单位和建筑。 因此你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n\n// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算\n// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。\nclass GameAI is\n    // 模板方法定义了某个算法的框架。\n    method turn() is\n        collectResources()\n        buildStructures()\n        buildUnits()\n        attack()\n\n    // 某些步骤可在基类中直接实现。\n    method collectResources() is\n        foreach (s in this.builtStructures) do\n            s.collect()\n\n    // 某些可定义为抽象类型。\n    abstract method buildStructures()\n    abstract method buildUnits()\n\n    // 一个类可包含多个模板方法。\n    method attack() is\n        enemy = closestEnemy()\n        if (enemy == null)\n            sendScouts(map.center)\n        else\n            sendWarriors(enemy.position)\n\n    abstract method sendScouts(position)\n    abstract method sendWarriors(position)\n\n// 具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。\nclass OrcsAI extends GameAI is\n    method buildStructures() is\n        if (there are some resources) then\n            // 建造农场，接着是谷仓，然后是要塞。\n\n    method buildUnits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // 建造苦工，将其加入侦查编组。\n            else\n                // 建造兽族步兵，将其加入战士编组。\n\n    // ...\n\n    method sendScouts(position) is\n        if (scouts.length > 0) then\n            // 将侦查编组送到指定位置。\n\n    method sendWarriors(position) is\n        if (warriors.length > 5) then\n            // 将战斗编组送到指定位置。\n\n// 子类可以重写部分默认的操作。\nclass MonstersAI extends GameAI is\n    method collectResources() is\n        // 怪物不会采集资源。\n\n    method buildStructures() is\n        // 怪物不会建造建筑。\n\n    method buildUnits() is\n        // 怪物不会建造单位。\n\n\n\n# 案例\n\n模板方法模式应用场景十分广泛。\n\n在《Head First》的模板方法模式章节里列举了一个十分具有代表性的例子。\n\n现实生活中，茶和咖啡是随处可见的饮料。冲泡一杯茶或冲泡一杯咖啡的过程是怎样的？\n\n我们来整理一下流程。\n\n * 泡茶： 烧开水 ==> 冲泡茶叶 ==> 倒入杯中 ==> 添加柠檬\n * 泡咖啡： 烧开水 ==> 冲泡咖啡 ==> 倒入杯中 ==> 添加糖和牛奶\n\n由以上处理步骤不难发现，准备这两种饮料的处理过程非常相似。我们可以使用模板类方法去限定制作饮料的算法框架。\n\n其中相同的具有共性的步骤（如烧开水、倒入杯中），直接在抽象类中给出具体实现。\n\n而对于有差异性的步骤，则在各自的具体类中给出实现。\n\n【抽象类】\n\nabstract class Beverage {\n\n    // 模板方法，决定了算法骨架。相当于TemplateMethod()方法\n    public void prepareBeverage() {\n        boilWater();\n        brew();\n        pourInCup();\n        if (customWantsCondiments())\n        {\n            addCondiments();\n        }\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void boilWater() {\n        System.out.println("烧开水");\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void pourInCup() {\n        System.out.println("倒入杯中");\n    }\n\n    // 钩子方法，决定某些算法步骤是否挂钩在算法中\n    public boolean customWantsCondiments() {\n        return true;\n    }\n\n    // 特殊操作，在子类中具体实现\n    public abstract void brew();\n\n    // 特殊操作，在子类中具体实现\n    public abstract void addCondiments();\n\n}\n\n\n【具体类】\n\nclass Tea extends Beverage {\n\n    @Override\n    public void brew() {\n        System.out.println("冲泡茶叶");\n    }\n\n    @Override\n    public void addCondiments() {\n        System.out.println("添加柠檬");\n    }\n\n}\n\nclass Coffee extends Beverage {\n\n    @Override\n    public void brew() {\n        System.out.println("冲泡咖啡豆");\n    }\n\n    @Override\n    public void addCondiments() {\n        System.out.println("添加糖和牛奶");\n    }\n\n}\n\n\n【客户端】\n\npublic static void main(String[] args) {\n\n    System.out.println("============= 准备茶 =============");\n    Beverage tea = new Tea();\n    tea.prepareBeverage();\n\n    System.out.println("============= 准备咖啡 =============");\n    Beverage coffee = new Coffee();\n    coffee.prepareBeverage();\n\n}\n\n\n输出\n\n============= 准备茶 =============\n烧开水\n冲泡茶叶\n倒入杯中\n添加柠檬\n============= 准备咖啡 =============\n烧开水\n冲泡咖啡豆\n倒入杯中\n添加糖和牛奶\n\n\n\n# 案例\n\n使用示例： 模版方法模式在 Java 框架中很常见。 开发者通常使用它来向框架用户提供通过继承实现的、 对标准功能进行扩展的简单方式。\n\n这里是一些核心 Java 程序库中模版方法的示例：\n\n * java.io.InputStream、 java.io.OutputStream、 java.io.Reader 和 java.io.Writer 的所有非抽象方法。\n * java.util.AbstractList、 java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法。\n * javax.servlet.http.HttpServlet， 所有默认发送 HTTP 405 “方法不允许” 错误响应的 do­XXX()方法。 你可随时对其进行重写。\n\n识别方法： 模版方法可以通过行为方法来识别， 该方法已有一个在基类中定义的 “默认” 行为。\n\n\n# 消除 if ... else 和重复代码\n\n假设要开发一个购物车功能，针对不同用户进行不同的处理：\n\n * 普通用户需要收取运费，运费是商品价格的 10%，无商品折扣；\n * VIP 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；\n * 内部用户可以免运费，无商品折扣。\n\n# 问题 1.0 版本\n\n普通用户购物车\n\npublic class NormalUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        //把Map的购物车转换为Item列表\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        //处理运费和商品优惠\n        itemList.stream().forEach(item -> {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(\n                item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal("0.1")));\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        //计算纯商品总价\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算运费总价\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算总优惠\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //应付总价=商品总价+运费总价-总优惠\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\nVIP 用户购物车\n\npublic class VipUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(\n                item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal("0.1")));\n            //购买两件以上相同商品，第三件开始享受一定折扣\n            if (item.getQuantity() > 2) {\n                item.setCouponPrice(item.getPrice()\n                    .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal("100")))\n                    .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n            } else {\n                item.setCouponPrice(BigDecimal.ZERO);\n            }\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\n内部用户购物车\n\npublic class InternalUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            //免运费\n            item.setDeliveryPrice(BigDecimal.ZERO);\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\n客户端\n\n@GetMapping("wrong")\npublic Cart wrong(@RequestParam("userId") int userId) {\n    String userCategory = Db.getUserCategory(userId);\n\n    if (userCategory.equals("Normal")) {\n        NormalUserCart normalUserCart = new NormalUserCart();\n        return normalUserCart.process(userId, items);\n    }\n\n    if (userCategory.equals("Vip")) {\n        VipUserCart vipUserCart = new VipUserCart();\n        return vipUserCart.process(userId, items);\n    }\n\n    if (userCategory.equals("Internal")) {\n        InternalUserCart internalUserCart = new InternalUserCart();\n        return internalUserCart.process(userId, items);\n    }\n\n    return null;\n}\n\n\n> 对比一下代码量可以发现，三种购物车 70% 的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。\n\n# 修正版本\n\n1.0 版本的问题在于：相同的代码应该只在一处出现。\n\n如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？\n\n其实，这个模式就是模板方法模式。\n\n> 下面展示基于 工厂模式+模板方法模式 优化重复代码。\n\n【抽象类】\n\npublic abstract class AbstractCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            processCouponPrice(userId, item);\n            processDeliveryPrice(userId, item);\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n    protected abstract void processCouponPrice(long userId, Item item);\n\n    protected abstract void processDeliveryPrice(long userId, Item item);\n\n}\n\n\n【普通用户购物车】\n\n@Service(value = "NormalUserCart")\npublic class NormalUserCart extends AbstractCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(item.getPrice()\n            .multiply(BigDecimal.valueOf(item.getQuantity()))\n            .multiply(new BigDecimal("0.1")));\n    }\n\n}\n\n\n【VIP 用户购物车】\n\n@Service(value = "VipUserCart")\npublic class VipUserCart extends NormalUserCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        if (item.getQuantity() > 2) {\n            item.setCouponPrice(item.getPrice()\n                .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal("100")))\n                .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n        } else {\n            item.setCouponPrice(BigDecimal.ZERO);\n        }\n    }\n\n}\n\n\n【内部用户购物车】\n\n@Service(value = "InternalUserCart")\npublic class InternalUserCart extends AbstractCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(BigDecimal.ZERO);\n    }\n\n}\n\n\n【客户端】\n\n@GetMapping("right")\npublic Cart right(@RequestParam("userId") int userId) {\n    String userCategory = Db.getUserCategory(userId);\n    AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + "UserCart");\n    return cart.process(userId, items);\n}\n\n\n\n# 与其他模式的关系\n\n * 工厂方法模式是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n * 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之模板方法模式\n\n\n# 意图\n\n模板方法模式 (template method) 是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。，没有关联关系。 因此，在模板方法模式的类结构图中，只有继承关系。\n\n模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。\n\n代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。\n\n在模板方法模式中，首先父类会定义一个算法的框架，即实现算法所必须的所有方法。\n\n * 其中，具有共性的代码放在父类的具体方法中。\n\n * 各个子类特殊性的代码放在子类的具体方法中。但是父类中需要有对应抽象方法声明。\n\n * 钩子方法可以让子类决定是否对算法的不同点进行挂钩。\n\n\n# 适用场景\n\n * 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n * 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 抽象类 （abstract­class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象类型， 也可以提供一些默认实现。\n 2. 具体类 （concrete­class） 可以重写所有步骤， 但不能重写模板方法自身。\n\n\n# 结构代码范式\n\nabstractclass : 抽象类，定义并实现一个模板方法。这个模板方法定义了算法的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类去实现。顶级逻辑也有可能调用一些具体方法。\n\nabstract class abstractclass {\n    public abstract void primitiveoperation1();\n    public abstract void primitiveoperation2();\n\n    public void templatemethod() {\n        primitiveoperation1();\n        primitiveoperation2();\n    }\n}\n\n\nconcreteclass : 实现实现父类所定义的一个或多个抽象方法。\n\nclass concreteclassa extends abstractclass {\n    @override\n    public void primitiveoperation1() {\n        system.out.println("具体a类方法1");\n    }\n\n    @override\n    public void primitiveoperation2() {\n        system.out.println("具体a类方法2");\n    }\n}\n\nclass concreteclassb extends abstractclass {\n    @override\n    public void primitiveoperation1() {\n        system.out.println("具体b类方法1");\n    }\n\n    @override\n    public void primitiveoperation2() {\n        system.out.println("具体b类方法2");\n    }\n}\n\n\n客户端\n\npublic class templatemethodpattern {\n    public static void main(string[] args) {\n        abstractclass obja = new concreteclassa();\n        abstractclass objb = new concreteclassb();\n        obja.templatemethod();\n        objb.templatemethod();\n    }\n}\n\n\n\n# 伪代码\n\n本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。\n\n\n\n一款简单游戏的 ai 类。\n\n游戏中所有的种族都有几乎同类的单位和建筑。 因此你可以在不同的种族上复用相同的 ai 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 ai 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 ai 子类， 还需要重写 ai 基类中所声明的默认方法。\n\n// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算\n// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。\nclass gameai is\n    // 模板方法定义了某个算法的框架。\n    method turn() is\n        collectresources()\n        buildstructures()\n        buildunits()\n        attack()\n\n    // 某些步骤可在基类中直接实现。\n    method collectresources() is\n        foreach (s in this.builtstructures) do\n            s.collect()\n\n    // 某些可定义为抽象类型。\n    abstract method buildstructures()\n    abstract method buildunits()\n\n    // 一个类可包含多个模板方法。\n    method attack() is\n        enemy = closestenemy()\n        if (enemy == null)\n            sendscouts(map.center)\n        else\n            sendwarriors(enemy.position)\n\n    abstract method sendscouts(position)\n    abstract method sendwarriors(position)\n\n// 具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。\nclass orcsai extends gameai is\n    method buildstructures() is\n        if (there are some resources) then\n            // 建造农场，接着是谷仓，然后是要塞。\n\n    method buildunits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // 建造苦工，将其加入侦查编组。\n            else\n                // 建造兽族步兵，将其加入战士编组。\n\n    // ...\n\n    method sendscouts(position) is\n        if (scouts.length > 0) then\n            // 将侦查编组送到指定位置。\n\n    method sendwarriors(position) is\n        if (warriors.length > 5) then\n            // 将战斗编组送到指定位置。\n\n// 子类可以重写部分默认的操作。\nclass monstersai extends gameai is\n    method collectresources() is\n        // 怪物不会采集资源。\n\n    method buildstructures() is\n        // 怪物不会建造建筑。\n\n    method buildunits() is\n        // 怪物不会建造单位。\n\n\n\n# 案例\n\n模板方法模式应用场景十分广泛。\n\n在《head first》的模板方法模式章节里列举了一个十分具有代表性的例子。\n\n现实生活中，茶和咖啡是随处可见的饮料。冲泡一杯茶或冲泡一杯咖啡的过程是怎样的？\n\n我们来整理一下流程。\n\n * 泡茶： 烧开水 ==> 冲泡茶叶 ==> 倒入杯中 ==> 添加柠檬\n * 泡咖啡： 烧开水 ==> 冲泡咖啡 ==> 倒入杯中 ==> 添加糖和牛奶\n\n由以上处理步骤不难发现，准备这两种饮料的处理过程非常相似。我们可以使用模板类方法去限定制作饮料的算法框架。\n\n其中相同的具有共性的步骤（如烧开水、倒入杯中），直接在抽象类中给出具体实现。\n\n而对于有差异性的步骤，则在各自的具体类中给出实现。\n\n【抽象类】\n\nabstract class beverage {\n\n    // 模板方法，决定了算法骨架。相当于templatemethod()方法\n    public void preparebeverage() {\n        boilwater();\n        brew();\n        pourincup();\n        if (customwantscondiments())\n        {\n            addcondiments();\n        }\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void boilwater() {\n        system.out.println("烧开水");\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void pourincup() {\n        system.out.println("倒入杯中");\n    }\n\n    // 钩子方法，决定某些算法步骤是否挂钩在算法中\n    public boolean customwantscondiments() {\n        return true;\n    }\n\n    // 特殊操作，在子类中具体实现\n    public abstract void brew();\n\n    // 特殊操作，在子类中具体实现\n    public abstract void addcondiments();\n\n}\n\n\n【具体类】\n\nclass tea extends beverage {\n\n    @override\n    public void brew() {\n        system.out.println("冲泡茶叶");\n    }\n\n    @override\n    public void addcondiments() {\n        system.out.println("添加柠檬");\n    }\n\n}\n\nclass coffee extends beverage {\n\n    @override\n    public void brew() {\n        system.out.println("冲泡咖啡豆");\n    }\n\n    @override\n    public void addcondiments() {\n        system.out.println("添加糖和牛奶");\n    }\n\n}\n\n\n【客户端】\n\npublic static void main(string[] args) {\n\n    system.out.println("============= 准备茶 =============");\n    beverage tea = new tea();\n    tea.preparebeverage();\n\n    system.out.println("============= 准备咖啡 =============");\n    beverage coffee = new coffee();\n    coffee.preparebeverage();\n\n}\n\n\n输出\n\n============= 准备茶 =============\n烧开水\n冲泡茶叶\n倒入杯中\n添加柠檬\n============= 准备咖啡 =============\n烧开水\n冲泡咖啡豆\n倒入杯中\n添加糖和牛奶\n\n\n\n# 案例\n\n使用示例： 模版方法模式在 java 框架中很常见。 开发者通常使用它来向框架用户提供通过继承实现的、 对标准功能进行扩展的简单方式。\n\n这里是一些核心 java 程序库中模版方法的示例：\n\n * java.io.inputstream、 java.io.outputstream、 java.io.reader 和 java.io.writer 的所有非抽象方法。\n * java.util.abstractlist、 java.util.abstractset 和 java.util.abstractmap 的所有非抽象方法。\n * javax.servlet.http.httpservlet， 所有默认发送 http 405 “方法不允许” 错误响应的 do­xxx()方法。 你可随时对其进行重写。\n\n识别方法： 模版方法可以通过行为方法来识别， 该方法已有一个在基类中定义的 “默认” 行为。\n\n\n# 消除 if ... else 和重复代码\n\n假设要开发一个购物车功能，针对不同用户进行不同的处理：\n\n * 普通用户需要收取运费，运费是商品价格的 10%，无商品折扣；\n * vip 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；\n * 内部用户可以免运费，无商品折扣。\n\n# 问题 1.0 版本\n\n普通用户购物车\n\npublic class normalusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        //把map的购物车转换为item列表\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        //处理运费和商品优惠\n        itemlist.stream().foreach(item -> {\n            //运费为商品总价的10%\n            item.setdeliveryprice(\n                item.getprice().multiply(bigdecimal.valueof(item.getquantity())).multiply(new bigdecimal("0.1")));\n            //无优惠\n            item.setcouponprice(bigdecimal.zero);\n        });\n\n        //计算纯商品总价\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        //计算运费总价\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        //计算总优惠\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        //应付总价=商品总价+运费总价-总优惠\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\nvip 用户购物车\n\npublic class vipusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            //运费为商品总价的10%\n            item.setdeliveryprice(\n                item.getprice().multiply(bigdecimal.valueof(item.getquantity())).multiply(new bigdecimal("0.1")));\n            //购买两件以上相同商品，第三件开始享受一定折扣\n            if (item.getquantity() > 2) {\n                item.setcouponprice(item.getprice()\n                    .multiply(bigdecimal.valueof(100 - db.getusercouponpercent(userid)).divide(new bigdecimal("100")))\n                    .multiply(bigdecimal.valueof(item.getquantity() - 2)));\n            } else {\n                item.setcouponprice(bigdecimal.zero);\n            }\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\n内部用户购物车\n\npublic class internalusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            //免运费\n            item.setdeliveryprice(bigdecimal.zero);\n            //无优惠\n            item.setcouponprice(bigdecimal.zero);\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\n客户端\n\n@getmapping("wrong")\npublic cart wrong(@requestparam("userid") int userid) {\n    string usercategory = db.getusercategory(userid);\n\n    if (usercategory.equals("normal")) {\n        normalusercart normalusercart = new normalusercart();\n        return normalusercart.process(userid, items);\n    }\n\n    if (usercategory.equals("vip")) {\n        vipusercart vipusercart = new vipusercart();\n        return vipusercart.process(userid, items);\n    }\n\n    if (usercategory.equals("internal")) {\n        internalusercart internalusercart = new internalusercart();\n        return internalusercart.process(userid, items);\n    }\n\n    return null;\n}\n\n\n> 对比一下代码量可以发现，三种购物车 70% 的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。\n\n# 修正版本\n\n1.0 版本的问题在于：相同的代码应该只在一处出现。\n\n如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？\n\n其实，这个模式就是模板方法模式。\n\n> 下面展示基于 工厂模式+模板方法模式 优化重复代码。\n\n【抽象类】\n\npublic abstract class abstractcart {\n\n    public cart process(long userid, map<long, integer> items) {\n\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            processcouponprice(userid, item);\n            processdeliveryprice(userid, item);\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n    protected abstract void processcouponprice(long userid, item item);\n\n    protected abstract void processdeliveryprice(long userid, item item);\n\n}\n\n\n【普通用户购物车】\n\n@service(value = "normalusercart")\npublic class normalusercart extends abstractcart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        item.setcouponprice(bigdecimal.zero);\n    }\n\n    @override\n    protected void processdeliveryprice(long userid, item item) {\n        item.setdeliveryprice(item.getprice()\n            .multiply(bigdecimal.valueof(item.getquantity()))\n            .multiply(new bigdecimal("0.1")));\n    }\n\n}\n\n\n【vip 用户购物车】\n\n@service(value = "vipusercart")\npublic class vipusercart extends normalusercart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        if (item.getquantity() > 2) {\n            item.setcouponprice(item.getprice()\n                .multiply(bigdecimal.valueof(100 - db.getusercouponpercent(userid)).divide(new bigdecimal("100")))\n                .multiply(bigdecimal.valueof(item.getquantity() - 2)));\n        } else {\n            item.setcouponprice(bigdecimal.zero);\n        }\n    }\n\n}\n\n\n【内部用户购物车】\n\n@service(value = "internalusercart")\npublic class internalusercart extends abstractcart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        item.setcouponprice(bigdecimal.zero);\n    }\n\n    @override\n    protected void processdeliveryprice(long userid, item item) {\n        item.setdeliveryprice(bigdecimal.zero);\n    }\n\n}\n\n\n【客户端】\n\n@getmapping("right")\npublic cart right(@requestparam("userid") int userid) {\n    string usercategory = db.getusercategory(userid);\n    abstractcart cart = (abstractcart) applicationcontext.getbean(usercategory + "usercart");\n    return cart.process(userid, items);\n}\n\n\n\n# 与其他模式的关系\n\n * 工厂方法模式是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n * 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之命令模式",frontmatter:{title:"设计模式之命令模式",date:"2015-01-19T17:20:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/22353c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/15.命令模式.md",key:"v-e65aab34",path:"/pages/22353c/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:3,title:"命令模式的交互",slug:"命令模式的交互",normalizedTitle:"命令模式的交互",charIndex:126},{level:3,title:"命令模式的要点",slug:"命令模式的要点",normalizedTitle:"命令模式的要点",charIndex:389},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:685},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:793},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:802},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:1344},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2461},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5772},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:6445},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6728}],headersStr:"意图 命令模式的交互 命令模式的要点 适用场景 结构 结构说明 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之命令模式\n\n\n# 意图\n\n命令模式（Command） 是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n\n\n# 命令模式的交互\n\n\n\n * Client 创建一个 ConcreteCommand 对象并指定他的 Receiver 对象。\n * 某个 Invoker 对象存储该 ConcreteCommand 对象。\n * 该 Invoker 通过调用 Command 对象的 Execute 操作来提交一个请求。若该命令是可撤销的，ConcreteCommand 就在执行 Execute 操作之前存储当前状态以用于取消该命令。\n * ConcreteCommand 对象对调用它的 Receiver 的一些操作以执行该请求。\n\n\n# 命令模式的要点\n\n * 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n * 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n * 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n * 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n * 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n\n# 适用场景\n\n * 如果你需要通过操作来参数化对象， 可使用命令模式。\n * 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n * 如果你想要实现操作回滚功能， 可使用命令模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n\n 2. 命令 （Command） 接口通常仅声明一个执行命令的方法。\n\n 3. 具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n    \n    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n\n 4. 接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n\n 5. 客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\n\n\n# 结构代码范式\n\nCommand : 用来声明执行操作的接口。\n\nabstract class Command {\n    protected Receiver receiver;\n    public Command(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public abstract void Execute();\n}\n\n\nConcreteCommand : 将一个接收者对象绑定一个动作，调用接收者相应的操作，以实现 Execute。\n\nclass ConcreteCommand extends Command {\n    public ConcreteCommand(Receiver receiver) {\n        super(receiver);\n    }\n\n    @Override\n    public void Execute() {\n        receiver.Action();\n    }\n}\n\n\nInvoker : 要求该命令执行这个请求。\n\nclass Invoker {\n    private Command command;\n\n    public Invoker(Command command) {\n        this.command = command;\n    }\n\n    public void ExecuteCommand() {\n        command.Execute();\n    }\n}\n\n\nReceiver : 知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。\n\nclass Receiver {\n    public void Action() {\n        System.out.println("执行请求");\n    }\n}\n\n\nClient : 创建一个具体命令对象并设定它的接受者。\n\npublic class CommandPattern {\n    public static void main(String[] args) {\n        Receiver receiver = new Receiver();\n        Command cmd = new ConcreteCommand(receiver);\n        Invoker invoker = new Invoker(cmd);\n        invoker.ExecuteCommand();\n    }\n}\n\n\n\n# 伪代码\n\n在本例中， 命令模式会记录已执行操作的历史记录， 以在需要时撤销操作。\n\n\n\n有些命令会改变编辑器的状态 （例如剪切和粘贴）， 它们可在执行相关操作前对编辑器的状态进行备份。 命令执行后会和当前点备份的编辑器状态一起被放入命令历史 （命令对象栈）。 此后， 如果用户需要进行回滚操作， 程序可从历史记录中取出最近的命令， 读取相应的编辑器状态备份， 然后进行恢复。\n\n客户端代码 （GUI 元素和命令历史等） 没有和具体命令类相耦合， 因为它通过命令接口来使用命令。 这使得你能在无需修改已有代码的情况下在程序中增加新的命令。\n\n// 命令基类会为所有具体命令定义通用接口。\nabstract class Command is\n    protected field app: Application\n    protected field editor: Editor\n    protected field backup: text\n\n    constructor Command(app: Application, editor: Editor) is\n        this.app = app\n        this.editor = editor\n\n    // 备份编辑器状态。\n    method saveBackup() is\n        backup = editor.text\n\n    // 恢复编辑器状态。\n    method undo() is\n        editor.text = backup\n\n    // 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根\n    // 据命令是否更改编辑器的状态返回 true 或 false。\n    abstract method execute()\n\n\n// 这里是具体命令。\nclass CopyCommand extends Command is\n    // 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。\n    method execute() is\n        app.clipboard = editor.getSelection()\n        return false\n\nclass CutCommand extends Command is\n    // 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法\n    // 返回 true，它就会被保存。\n    method execute() is\n        saveBackup()\n        app.clipboard = editor.getSelection()\n        editor.deleteSelection()\n        return true\n\nclass PasteCommand extends Command is\n    method execute() is\n        saveBackup()\n        editor.replaceSelection(app.clipboard)\n        return true\n\n// 撤销操作也是一个命令。\nclass UndoCommand extends Command is\n    method execute() is\n        app.undo()\n        return false\n\n\n// 全局命令历史记录就是一个堆桟。\nclass CommandHistory is\n    private field history: array of Command\n\n    // 后进...\n    method push(c: Command) is\n        // 将命令压入历史记录数组的末尾。\n\n    // ...先出\n    method pop():Command is\n        // 从历史记录中取出最近的命令。\n\n\n// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会\n// 将执行工作委派给编辑器的方法。\nclass Editor is\n    field text: string\n\n    method getSelection() is\n        // 返回选中的文字。\n\n    method deleteSelection() is\n        // 删除选中的文字。\n\n    method replaceSelection(text) is\n        // 在当前位置插入剪贴板中的内容。\n\n// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工\n// 作时，它会创建并执行一个命令对象。\nclass Application is\n    field clipboard: string\n    field editors: array of Editors\n    field activeEditor: Editor\n    field history: CommandHistory\n\n    // 将命令分派给 UI 对象的代码可能会是这样的。\n    method createUI() is\n        // ...\n        copy = function() { executeCommand(\n            new CopyCommand(this, activeEditor)) }\n        copyButton.setCommand(copy)\n        shortcuts.onKeyPress("Ctrl+C", copy)\n\n        cut = function() { executeCommand(\n            new CutCommand(this, activeEditor)) }\n        cutButton.setCommand(cut)\n        shortcuts.onKeyPress("Ctrl+X", cut)\n\n        paste = function() { executeCommand(\n            new PasteCommand(this, activeEditor)) }\n        pasteButton.setCommand(paste)\n        shortcuts.onKeyPress("Ctrl+V", paste)\n\n        undo = function() { executeCommand(\n            new UndoCommand(this, activeEditor)) }\n        undoButton.setCommand(undo)\n        shortcuts.onKeyPress("Ctrl+Z", undo)\n\n    // 执行一个命令并检查它是否需要被添加到历史记录中。\n    method executeCommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并\n    // 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销\n    // 其动作。\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。 还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n * 你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 原型模式可用于保存命令的历史记录。\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n\n\n# 案例\n\n使用示例：命令模式在 Java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 UI 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。\n\n以下是在核心 Java 程序库中的一些示例：\n\n * java.lang.Runnable 的所有实现\n * javax.swing.Action 的所有实现\n\n识别方法： 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之命令模式\n\n\n# 意图\n\n命令模式（command） 是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n\n\n# 命令模式的交互\n\n\n\n * client 创建一个 concretecommand 对象并指定他的 receiver 对象。\n * 某个 invoker 对象存储该 concretecommand 对象。\n * 该 invoker 通过调用 command 对象的 execute 操作来提交一个请求。若该命令是可撤销的，concretecommand 就在执行 execute 操作之前存储当前状态以用于取消该命令。\n * concretecommand 对象对调用它的 receiver 的一些操作以执行该请求。\n\n\n# 命令模式的要点\n\n * 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n * 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n * 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n * 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n * 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n\n# 适用场景\n\n * 如果你需要通过操作来参数化对象， 可使用命令模式。\n * 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n * 如果你想要实现操作回滚功能， 可使用命令模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 发送者 （sender）——亦称 “触发者 （invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n\n 2. 命令 （command） 接口通常仅声明一个执行命令的方法。\n\n 3. 具体命令 （concrete commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n    \n    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n\n 4. 接收者 （receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n\n 5. 客户端 （client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\n\n\n# 结构代码范式\n\ncommand : 用来声明执行操作的接口。\n\nabstract class command {\n    protected receiver receiver;\n    public command(receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public abstract void execute();\n}\n\n\nconcretecommand : 将一个接收者对象绑定一个动作，调用接收者相应的操作，以实现 execute。\n\nclass concretecommand extends command {\n    public concretecommand(receiver receiver) {\n        super(receiver);\n    }\n\n    @override\n    public void execute() {\n        receiver.action();\n    }\n}\n\n\ninvoker : 要求该命令执行这个请求。\n\nclass invoker {\n    private command command;\n\n    public invoker(command command) {\n        this.command = command;\n    }\n\n    public void executecommand() {\n        command.execute();\n    }\n}\n\n\nreceiver : 知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。\n\nclass receiver {\n    public void action() {\n        system.out.println("执行请求");\n    }\n}\n\n\nclient : 创建一个具体命令对象并设定它的接受者。\n\npublic class commandpattern {\n    public static void main(string[] args) {\n        receiver receiver = new receiver();\n        command cmd = new concretecommand(receiver);\n        invoker invoker = new invoker(cmd);\n        invoker.executecommand();\n    }\n}\n\n\n\n# 伪代码\n\n在本例中， 命令模式会记录已执行操作的历史记录， 以在需要时撤销操作。\n\n\n\n有些命令会改变编辑器的状态 （例如剪切和粘贴）， 它们可在执行相关操作前对编辑器的状态进行备份。 命令执行后会和当前点备份的编辑器状态一起被放入命令历史 （命令对象栈）。 此后， 如果用户需要进行回滚操作， 程序可从历史记录中取出最近的命令， 读取相应的编辑器状态备份， 然后进行恢复。\n\n客户端代码 （gui 元素和命令历史等） 没有和具体命令类相耦合， 因为它通过命令接口来使用命令。 这使得你能在无需修改已有代码的情况下在程序中增加新的命令。\n\n// 命令基类会为所有具体命令定义通用接口。\nabstract class command is\n    protected field app: application\n    protected field editor: editor\n    protected field backup: text\n\n    constructor command(app: application, editor: editor) is\n        this.app = app\n        this.editor = editor\n\n    // 备份编辑器状态。\n    method savebackup() is\n        backup = editor.text\n\n    // 恢复编辑器状态。\n    method undo() is\n        editor.text = backup\n\n    // 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根\n    // 据命令是否更改编辑器的状态返回 true 或 false。\n    abstract method execute()\n\n\n// 这里是具体命令。\nclass copycommand extends command is\n    // 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。\n    method execute() is\n        app.clipboard = editor.getselection()\n        return false\n\nclass cutcommand extends command is\n    // 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法\n    // 返回 true，它就会被保存。\n    method execute() is\n        savebackup()\n        app.clipboard = editor.getselection()\n        editor.deleteselection()\n        return true\n\nclass pastecommand extends command is\n    method execute() is\n        savebackup()\n        editor.replaceselection(app.clipboard)\n        return true\n\n// 撤销操作也是一个命令。\nclass undocommand extends command is\n    method execute() is\n        app.undo()\n        return false\n\n\n// 全局命令历史记录就是一个堆桟。\nclass commandhistory is\n    private field history: array of command\n\n    // 后进...\n    method push(c: command) is\n        // 将命令压入历史记录数组的末尾。\n\n    // ...先出\n    method pop():command is\n        // 从历史记录中取出最近的命令。\n\n\n// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会\n// 将执行工作委派给编辑器的方法。\nclass editor is\n    field text: string\n\n    method getselection() is\n        // 返回选中的文字。\n\n    method deleteselection() is\n        // 删除选中的文字。\n\n    method replaceselection(text) is\n        // 在当前位置插入剪贴板中的内容。\n\n// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工\n// 作时，它会创建并执行一个命令对象。\nclass application is\n    field clipboard: string\n    field editors: array of editors\n    field activeeditor: editor\n    field history: commandhistory\n\n    // 将命令分派给 ui 对象的代码可能会是这样的。\n    method createui() is\n        // ...\n        copy = function() { executecommand(\n            new copycommand(this, activeeditor)) }\n        copybutton.setcommand(copy)\n        shortcuts.onkeypress("ctrl+c", copy)\n\n        cut = function() { executecommand(\n            new cutcommand(this, activeeditor)) }\n        cutbutton.setcommand(cut)\n        shortcuts.onkeypress("ctrl+x", cut)\n\n        paste = function() { executecommand(\n            new pastecommand(this, activeeditor)) }\n        pastebutton.setcommand(paste)\n        shortcuts.onkeypress("ctrl+v", paste)\n\n        undo = function() { executecommand(\n            new undocommand(this, activeeditor)) }\n        undobutton.setcommand(undo)\n        shortcuts.onkeypress("ctrl+z", undo)\n\n    // 执行一个命令并检查它是否需要被添加到历史记录中。\n    method executecommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并\n    // 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销\n    // 其动作。\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。 还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n * 你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 原型模式可用于保存命令的历史记录。\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n\n\n# 案例\n\n使用示例：命令模式在 java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 ui 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。\n\n以下是在核心 java 程序库中的一些示例：\n\n * java.lang.runnable 的所有实现\n * javax.swing.action 的所有实现\n\n识别方法： 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之迭代器模式",frontmatter:{title:"设计模式之迭代器模式",date:"2015-01-19T17:20:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/09d5af/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/16.迭代器模式.md",key:"v-637f7ff4",path:"/pages/09d5af/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:95},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:115},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:243},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:783},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2983},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5800},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5995},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6242}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之迭代器模式\n\n\n# 意图\n\n迭代器模式（Iterator） 是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n\n\n# 适用场景\n\n * 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n * 使用该模式可以减少程序中重复的遍历代码。\n * 如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 迭代器 （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。\n 2. 具体迭代器 （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。\n 3. 集合 （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。\n 4. 具体集合 （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。\n 5. 客户端 （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。\n    * 客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。\n\n\n# 结构代码范式\n\nIterator : 定义访问元素的接口。\n\ninterface Iterator {\n    public Object first();\n    public Object next();\n    public boolean isDone();\n    public Object currentItem();\n}\n\n\nConcreteIterator : 实现 Iterator 接口。记录当前访问的元素在集合中的位置信息。\n\nclass ConcreteIterator implements Iterator {\n    private int current = 0;\n    private ConcreteAggregate aggregate;\n\n    public ConcreteIterator(ConcreteAggregate aggregate) {\n        this.aggregate = aggregate;\n    }\n\n    @Override\n    public Object first() {\n        return aggregate.get(0);\n    }\n\n    @Override\n    public Object next() {\n        current++;\n        if (current < aggregate.size()) {\n            return aggregate.get(current);\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isDone() {\n        return (current >= aggregate.size()) ? true : false;\n    }\n\n    @Override\n    public Object currentItem() {\n        return aggregate.get(current);\n    }\n}\n\n\nAggregate : 定义创建 Iterator 对象的接口。\n\ninterface Aggregate {\n    public Iterator CreateIterator();\n}\n\n\nConcreteAggregate : 实现 Iterator 接口，返回一个合适的 ConcreteIterator 实例。\n\nclass ConcreteAggregate implements Aggregate {\n    private List<Object> items = new ArrayList<Object>();\n\n    @Override\n    public Iterator CreateIterator() {\n        return new ConcreteIterator(this);\n    }\n\n    public int size() {\n        return items.size();\n    }\n\n    public Object get(int index) {\n        return items.get(index);\n    }\n\n    public void set(int index, Object element) {\n        items.set(index, element);\n    }\n\n    public void add(Object element) {\n        items.add(element);\n    }\n}\n\n\n客户端\n\npublic class IteratorPattern {\n    public static void main(String[] args) {\n        ConcreteAggregate aggregate = new ConcreteAggregate();\n        aggregate.add("张三");\n        aggregate.add("李四");\n        aggregate.add("王五");\n        aggregate.add("赵六");\n\n        Iterator iter = new ConcreteIterator(aggregate);\n        Object item = iter.first();\n        System.out.println("第一个人是：" + item);\n        System.out.println("所有人的名单是：");\n        while (!iter.isDone()) {\n            System.out.println(iter.currentItem());\n            iter.next();\n        }\n    }\n}\n\n\n输出\n\n第一个人是：张三\n所有人的名单是：\n张三\n李四\n王五\n赵六\n\n\n\n# 伪代码\n\n在本例中， 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。\n\n\n\n“好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 REST 请求等实现细节的情况下获取档案。\n\n客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。\n\n// 集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭\n// 代器，你也可以声明多个方法。\ninterface SocialNetwork is\n    method createFriendsIterator(profileId):ProfileIterator\n    method createCoworkersIterator(profileId):ProfileIterator\n\n\n// 每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为\n// 这些方法的签名将会返回迭代器接口。\nclass WeChat implements SocialNetwork is\n    // ...大量的集合代码应该放在这里...\n\n    // 迭代器创建代码。\n    method createFriendsIterator(profileId) is\n        return new WeChatIterator(this, profileId, "friends")\n    method createCoworkersIterator(profileId) is\n        return new WeChatIterator(this, profileId, "coworkers")\n\n\n// 所有迭代器的通用接口。\ninterface ProfileIterator is\n    method getNext():Profile\n    method hasMore():bool\n\n\n// 具体迭代器类。\nclass WeChatIterator implements ProfileIterator is\n    // 迭代器需要一个指向其遍历集合的引用。\n    private field weChat: WeChat\n    private field profileId, type: string\n\n    // 迭代器对象会独立于其他迭代器来对集合进行遍历。因此它必须保存迭代器\n    // 的状态。\n    private field currentPosition\n    private field cache: array of Profile\n\n    constructor WeChatIterator(weChat, profileId, type) is\n        this.weChat = weChat\n        this.profileId = profileId\n        this.type = type\n\n    private method lazyInit() is\n        if (cache == null)\n            cache = weChat.socialGraphRequest(profileId, type)\n\n    // 每个具体迭代器类都会自行实现通用迭代器接口。\n    method getNext() is\n        if (hasMore())\n            currentPosition++\n            return cache[currentPosition]\n\n    method hasMore() is\n        lazyInit()\n        return currentPosition < cache.length\n\n\n// 这里还有一个有用的绝招：你可将迭代器传递给客户端类，无需让其拥有访问整\n// 个集合的权限。这样一来，你就无需将集合暴露给客户端了。\n//\n// 还有另一个好处：你可在运行时将不同的迭代器传递给客户端，从而改变客户端\n// 与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相\n// 耦合。\nclass SocialSpammer is\n    method send(iterator: ProfileIterator, message: string) is\n        while (iterator.hasMore())\n            profile = iterator.getNext()\n            System.sendEmail(profile.getEmail(), message)\n\n\n// 应用程序（Application）类可对集合和迭代器进行配置，然后将其传递给客户\n// 端代码。\nclass Application is\n    field network: SocialNetwork\n    field spammer: SocialSpammer\n\n    method config() is\n        if working with WeChat\n            this.network = new WeChat()\n        if working with LinkedIn\n            this.network = new LinkedIn()\n        this.spammer = new SocialSpammer()\n\n    method sendSpamToFriends(profile) is\n        iterator = network.createFriendsIterator(profile.getId())\n        spammer.send(iterator, "非常重要的消息")\n\n    method sendSpamToCoworkers(profile) is\n        iterator = network.createCoworkersIterator(profile.getId())\n        spammer.send(iterator, "非常重要的消息")\n\n\n\n# 与其他模式的关系\n\n * 你可以使用迭代器模式来遍历组合模式树。\n * 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 案例\n\n使用示例： 该模式在 Java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。\n\n下面是该模式在核心 Java 程序库中的一些示例：\n\n * java.util.Iterator的所有实现 （还有 java.util.Scanner）。\n * java.util.Enumeration的所有实现\n\n识别方法： 迭代器可以通过导航方法 （例如 next和 previous等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之迭代器模式\n\n\n# 意图\n\n迭代器模式（iterator） 是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n\n\n# 适用场景\n\n * 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n * 使用该模式可以减少程序中重复的遍历代码。\n * 如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 迭代器 （iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。\n 2. 具体迭代器 （concrete iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。\n 3. 集合 （collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。\n 4. 具体集合 （concrete collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。\n 5. 客户端 （client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。\n    * 客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。\n\n\n# 结构代码范式\n\niterator : 定义访问元素的接口。\n\ninterface iterator {\n    public object first();\n    public object next();\n    public boolean isdone();\n    public object currentitem();\n}\n\n\nconcreteiterator : 实现 iterator 接口。记录当前访问的元素在集合中的位置信息。\n\nclass concreteiterator implements iterator {\n    private int current = 0;\n    private concreteaggregate aggregate;\n\n    public concreteiterator(concreteaggregate aggregate) {\n        this.aggregate = aggregate;\n    }\n\n    @override\n    public object first() {\n        return aggregate.get(0);\n    }\n\n    @override\n    public object next() {\n        current++;\n        if (current < aggregate.size()) {\n            return aggregate.get(current);\n        }\n        return null;\n    }\n\n    @override\n    public boolean isdone() {\n        return (current >= aggregate.size()) ? true : false;\n    }\n\n    @override\n    public object currentitem() {\n        return aggregate.get(current);\n    }\n}\n\n\naggregate : 定义创建 iterator 对象的接口。\n\ninterface aggregate {\n    public iterator createiterator();\n}\n\n\nconcreteaggregate : 实现 iterator 接口，返回一个合适的 concreteiterator 实例。\n\nclass concreteaggregate implements aggregate {\n    private list<object> items = new arraylist<object>();\n\n    @override\n    public iterator createiterator() {\n        return new concreteiterator(this);\n    }\n\n    public int size() {\n        return items.size();\n    }\n\n    public object get(int index) {\n        return items.get(index);\n    }\n\n    public void set(int index, object element) {\n        items.set(index, element);\n    }\n\n    public void add(object element) {\n        items.add(element);\n    }\n}\n\n\n客户端\n\npublic class iteratorpattern {\n    public static void main(string[] args) {\n        concreteaggregate aggregate = new concreteaggregate();\n        aggregate.add("张三");\n        aggregate.add("李四");\n        aggregate.add("王五");\n        aggregate.add("赵六");\n\n        iterator iter = new concreteiterator(aggregate);\n        object item = iter.first();\n        system.out.println("第一个人是：" + item);\n        system.out.println("所有人的名单是：");\n        while (!iter.isdone()) {\n            system.out.println(iter.currentitem());\n            iter.next();\n        }\n    }\n}\n\n\n输出\n\n第一个人是：张三\n所有人的名单是：\n张三\n李四\n王五\n赵六\n\n\n\n# 伪代码\n\n在本例中， 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。\n\n\n\n“好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 rest 请求等实现细节的情况下获取档案。\n\n客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。\n\n// 集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭\n// 代器，你也可以声明多个方法。\ninterface socialnetwork is\n    method createfriendsiterator(profileid):profileiterator\n    method createcoworkersiterator(profileid):profileiterator\n\n\n// 每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为\n// 这些方法的签名将会返回迭代器接口。\nclass wechat implements socialnetwork is\n    // ...大量的集合代码应该放在这里...\n\n    // 迭代器创建代码。\n    method createfriendsiterator(profileid) is\n        return new wechatiterator(this, profileid, "friends")\n    method createcoworkersiterator(profileid) is\n        return new wechatiterator(this, profileid, "coworkers")\n\n\n// 所有迭代器的通用接口。\ninterface profileiterator is\n    method getnext():profile\n    method hasmore():bool\n\n\n// 具体迭代器类。\nclass wechatiterator implements profileiterator is\n    // 迭代器需要一个指向其遍历集合的引用。\n    private field wechat: wechat\n    private field profileid, type: string\n\n    // 迭代器对象会独立于其他迭代器来对集合进行遍历。因此它必须保存迭代器\n    // 的状态。\n    private field currentposition\n    private field cache: array of profile\n\n    constructor wechatiterator(wechat, profileid, type) is\n        this.wechat = wechat\n        this.profileid = profileid\n        this.type = type\n\n    private method lazyinit() is\n        if (cache == null)\n            cache = wechat.socialgraphrequest(profileid, type)\n\n    // 每个具体迭代器类都会自行实现通用迭代器接口。\n    method getnext() is\n        if (hasmore())\n            currentposition++\n            return cache[currentposition]\n\n    method hasmore() is\n        lazyinit()\n        return currentposition < cache.length\n\n\n// 这里还有一个有用的绝招：你可将迭代器传递给客户端类，无需让其拥有访问整\n// 个集合的权限。这样一来，你就无需将集合暴露给客户端了。\n//\n// 还有另一个好处：你可在运行时将不同的迭代器传递给客户端，从而改变客户端\n// 与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相\n// 耦合。\nclass socialspammer is\n    method send(iterator: profileiterator, message: string) is\n        while (iterator.hasmore())\n            profile = iterator.getnext()\n            system.sendemail(profile.getemail(), message)\n\n\n// 应用程序（application）类可对集合和迭代器进行配置，然后将其传递给客户\n// 端代码。\nclass application is\n    field network: socialnetwork\n    field spammer: socialspammer\n\n    method config() is\n        if working with wechat\n            this.network = new wechat()\n        if working with linkedin\n            this.network = new linkedin()\n        this.spammer = new socialspammer()\n\n    method sendspamtofriends(profile) is\n        iterator = network.createfriendsiterator(profile.getid())\n        spammer.send(iterator, "非常重要的消息")\n\n    method sendspamtocoworkers(profile) is\n        iterator = network.createcoworkersiterator(profile.getid())\n        spammer.send(iterator, "非常重要的消息")\n\n\n\n# 与其他模式的关系\n\n * 你可以使用迭代器模式来遍历组合模式树。\n * 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 案例\n\n使用示例： 该模式在 java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。\n\n下面是该模式在核心 java 程序库中的一些示例：\n\n * java.util.iterator的所有实现 （还有 java.util.scanner）。\n * java.util.enumeration的所有实现\n\n识别方法： 迭代器可以通过导航方法 （例如 next和 previous等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之观察者模式",frontmatter:{title:"设计模式之观察者模式",date:"2015-01-20T16:09:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/056e1d/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/17.观察者模式.md",key:"v-07d9254f",path:"/pages/056e1d/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:93},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:206},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:215},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:702},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:3324},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5628},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:6276},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6682}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之观察者模式\n\n\n# 意图\n\n观察者模式（Observer）是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n\n# 适用场景\n\n * 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n * 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。\n 2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。\n 3. 订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。\n 4. 具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。\n 5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。\n 6. 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。\n\n\n# 结构代码范式\n\nSubject : 主题类，保存所有订阅此主题的观察者，观察者的 数量是任意的。定义 添加观察者 (Attach) 和 删除观察者 (Detach) 的接口。\n\nabstract class Subject {\n    protected String name;\n    protected String state;\n    protected List<Observer> observers = new ArrayList<Observer>();\n\n    public abstract String getState();\n    public abstract void setState(String state);\n    public abstract void Notify();\n\n    public Subject(String name) {\n        this.name = name;\n    }\n\n    public void Attach(Observer observer) {\n        observers.add(observer);\n    }\n\n    public void Detach(Observer observer) {\n        observers.remove(observer);\n    }\n}\n\n\nObserver : 观察者类，定义更新接口 (Update)，当收到 Subject 的通知时，Observer 需要同步更新信息。\n\nabstract class Observer {\n    protected String name;\n    protected Subject subject;\n    public Observer(String name, Subject subject) {\n        this.name = name;\n        this.subject = subject;\n    }\n    public abstract void Update();\n}\n\n\nConcreteSubject : 具体主题类，存储对于这个主题感兴趣的所有观察者。当内部状态发生变化时，应通知所有登记的观察者(Notify)。\n\nclass ConcreteSubject extends Subject {\n    public ConcreteSubject(String name) {\n        super(name);\n    }\n\n    @Override\n    public String getState() {\n        return state;\n    }\n\n    @Override\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    @Override\n    public void Notify() {\n        System.out.println("======= " + this.name + "主题发布新消息 =======");\n        for (Observer observer : observers) {\n            observer.Update();\n        }\n    }\n}\n\n\nConcreteObserver : 具体观察者类，实现 Observer 的更新接口 (Update)，以便和 Subject 同步状态信息。\n\nclass ConcreteObserver extends Observer {\n    private String state;\n    public ConcreteObserver(String name, Subject subject) {\n        super(name, subject);\n    }\n\n    @Override\n    public void Update() {\n        state = subject.getState();\n        System.out.println(this.name + "收到当前状态：" + state);\n    }\n}\n\n\n客户端\n\npublic class ObserverPattern {\n    public static void main(String[] args) {\n        ConcreteSubject subject = new ConcreteSubject("天气");\n        ConcreteObserver observer1 = new ConcreteObserver("张三", subject);\n        ConcreteObserver observer2 = new ConcreteObserver("李四", subject);\n        ConcreteObserver observer3 = new ConcreteObserver("王五", subject);\n\n        subject.Attach(observer1);\n        subject.Attach(observer2);\n        subject.Attach(observer3);\n        subject.setState("今天下雨");\n        subject.Notify();\n\n        subject.Detach(observer2);\n        subject.setState("明天天晴");\n        subject.Notify();\n    }\n}\n\n\n输出\n\n======= 天气主题发布新消息 =======\n张三收到当前状态：今天下雨\n李四收到当前状态：今天下雨\n王五收到当前状态：今天下雨\n======= 天气主题发布新消息 =======\n张三收到当前状态：明天天晴\n王五收到当前状态：明天天晴\n\n\n\n# 伪代码\n\n在本例中， 观察者模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。\n\n\n\n订阅者列表是动态生成的： 对象可在运行时根据程序需要开始或停止监听通知。\n\n在本实现中， 编辑器类自身并不维护订阅列表。 它将工作委派给专门从事此工作的一个特殊帮手对象。 你还可将该对象升级为中心化的事件分发器， 允许任何对象成为发布者。\n\n只要发布者通过同样的接口与所有订阅者进行交互， 那么在程序中新增订阅者时就无需修改已有发布者类的代码。\n\n// 发布者基类包含订阅管理代码和通知方法。\nclass EventManager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventType, listener) is\n        listeners.add(eventType, listener)\n\n    method unsubscribe(eventType, listener) is\n        listeners.remove(eventType, listener)\n\n    method notify(eventType, data) is\n        foreach (listener in listeners.of(eventType)) do\n            listener.update(data)\n\n// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩\n// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。\n// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。\nclass Editor is\n    public field events: EventManager\n    private field file: File\n\n    constructor Editor() is\n        events = new EventManager()\n\n    // 业务逻辑的方法可将变化通知给订阅者。\n    method openFile(path) is\n        this.file = new File(path)\n        events.notify("open", file.name)\n\n    method saveFile() is\n        file.write()\n        events.notify("save", file.name)\n\n    // ...\n\n\n// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整\n// 个订阅者的层次结构。\ninterface EventListener is\n    method update(filename)\n\n// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。\nclass LoggingListener implements EventListener is\n    private field log: File\n    private field message\n\n    constructor LoggingListener(log_filename, message) is\n        this.log = new File(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace(\'%s\',filename,message))\n\nclass EmailAlertsListener implements EventListener is\n    private field email: string\n\n    constructor EmailAlertsListener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace(\'%s\',filename,message))\n\n\n// 应用程序可在运行时配置发布者和订阅者。\nclass Application is\n    method config() is\n        editor = new Editor()\n\n        logger = new LoggingListener(\n            "/path/to/log.txt",\n            "有人打开了文件：%s");\n        editor.events.subscribe("open", logger)\n\n        emailAlerts = new EmailAlertsListener(\n            "admin@example.com",\n            "有人更改了文件：%s")\n        editor.events.subscribe("save", emailAlerts)\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 案例\n\n使用示例： 观察者模式在 Java 代码中很常见， 特别是在 GUI 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。\n\n这里是核心 Java 程序库中该模式的一些示例：\n\n * java.util.Observer/ java.util.Observable （极少在真实世界中使用）\n * java.util.EventListener的所有实现 （几乎广泛存在于 Swing 组件中）\n * javax.servlet.http.HttpSessionBindingListener\n * javax.servlet.http.HttpSessionAttributeListener\n * javax.faces.event.PhaseListener\n\n识别方法： 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之观察者模式\n\n\n# 意图\n\n观察者模式（observer）是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n\n# 适用场景\n\n * 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n * 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 发布者 （publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。\n 2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。\n 3. 订阅者 （subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。\n 4. 具体订阅者 （concrete subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。\n 5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。\n 6. 客户端 （client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。\n\n\n# 结构代码范式\n\nsubject : 主题类，保存所有订阅此主题的观察者，观察者的 数量是任意的。定义 添加观察者 (attach) 和 删除观察者 (detach) 的接口。\n\nabstract class subject {\n    protected string name;\n    protected string state;\n    protected list<observer> observers = new arraylist<observer>();\n\n    public abstract string getstate();\n    public abstract void setstate(string state);\n    public abstract void notify();\n\n    public subject(string name) {\n        this.name = name;\n    }\n\n    public void attach(observer observer) {\n        observers.add(observer);\n    }\n\n    public void detach(observer observer) {\n        observers.remove(observer);\n    }\n}\n\n\nobserver : 观察者类，定义更新接口 (update)，当收到 subject 的通知时，observer 需要同步更新信息。\n\nabstract class observer {\n    protected string name;\n    protected subject subject;\n    public observer(string name, subject subject) {\n        this.name = name;\n        this.subject = subject;\n    }\n    public abstract void update();\n}\n\n\nconcretesubject : 具体主题类，存储对于这个主题感兴趣的所有观察者。当内部状态发生变化时，应通知所有登记的观察者(notify)。\n\nclass concretesubject extends subject {\n    public concretesubject(string name) {\n        super(name);\n    }\n\n    @override\n    public string getstate() {\n        return state;\n    }\n\n    @override\n    public void setstate(string state) {\n        this.state = state;\n    }\n\n    @override\n    public void notify() {\n        system.out.println("======= " + this.name + "主题发布新消息 =======");\n        for (observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n\n\nconcreteobserver : 具体观察者类，实现 observer 的更新接口 (update)，以便和 subject 同步状态信息。\n\nclass concreteobserver extends observer {\n    private string state;\n    public concreteobserver(string name, subject subject) {\n        super(name, subject);\n    }\n\n    @override\n    public void update() {\n        state = subject.getstate();\n        system.out.println(this.name + "收到当前状态：" + state);\n    }\n}\n\n\n客户端\n\npublic class observerpattern {\n    public static void main(string[] args) {\n        concretesubject subject = new concretesubject("天气");\n        concreteobserver observer1 = new concreteobserver("张三", subject);\n        concreteobserver observer2 = new concreteobserver("李四", subject);\n        concreteobserver observer3 = new concreteobserver("王五", subject);\n\n        subject.attach(observer1);\n        subject.attach(observer2);\n        subject.attach(observer3);\n        subject.setstate("今天下雨");\n        subject.notify();\n\n        subject.detach(observer2);\n        subject.setstate("明天天晴");\n        subject.notify();\n    }\n}\n\n\n输出\n\n======= 天气主题发布新消息 =======\n张三收到当前状态：今天下雨\n李四收到当前状态：今天下雨\n王五收到当前状态：今天下雨\n======= 天气主题发布新消息 =======\n张三收到当前状态：明天天晴\n王五收到当前状态：明天天晴\n\n\n\n# 伪代码\n\n在本例中， 观察者模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。\n\n\n\n订阅者列表是动态生成的： 对象可在运行时根据程序需要开始或停止监听通知。\n\n在本实现中， 编辑器类自身并不维护订阅列表。 它将工作委派给专门从事此工作的一个特殊帮手对象。 你还可将该对象升级为中心化的事件分发器， 允许任何对象成为发布者。\n\n只要发布者通过同样的接口与所有订阅者进行交互， 那么在程序中新增订阅者时就无需修改已有发布者类的代码。\n\n// 发布者基类包含订阅管理代码和通知方法。\nclass eventmanager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventtype, listener) is\n        listeners.add(eventtype, listener)\n\n    method unsubscribe(eventtype, listener) is\n        listeners.remove(eventtype, listener)\n\n    method notify(eventtype, data) is\n        foreach (listener in listeners.of(eventtype)) do\n            listener.update(data)\n\n// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩\n// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。\n// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。\nclass editor is\n    public field events: eventmanager\n    private field file: file\n\n    constructor editor() is\n        events = new eventmanager()\n\n    // 业务逻辑的方法可将变化通知给订阅者。\n    method openfile(path) is\n        this.file = new file(path)\n        events.notify("open", file.name)\n\n    method savefile() is\n        file.write()\n        events.notify("save", file.name)\n\n    // ...\n\n\n// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整\n// 个订阅者的层次结构。\ninterface eventlistener is\n    method update(filename)\n\n// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。\nclass logginglistener implements eventlistener is\n    private field log: file\n    private field message\n\n    constructor logginglistener(log_filename, message) is\n        this.log = new file(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace(\'%s\',filename,message))\n\nclass emailalertslistener implements eventlistener is\n    private field email: string\n\n    constructor emailalertslistener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace(\'%s\',filename,message))\n\n\n// 应用程序可在运行时配置发布者和订阅者。\nclass application is\n    method config() is\n        editor = new editor()\n\n        logger = new logginglistener(\n            "/path/to/log.txt",\n            "有人打开了文件：%s");\n        editor.events.subscribe("open", logger)\n\n        emailalerts = new emailalertslistener(\n            "admin@example.com",\n            "有人更改了文件：%s")\n        editor.events.subscribe("save", emailalerts)\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 案例\n\n使用示例： 观察者模式在 java 代码中很常见， 特别是在 gui 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。\n\n这里是核心 java 程序库中该模式的一些示例：\n\n * java.util.observer/ java.util.observable （极少在真实世界中使用）\n * java.util.eventlistener的所有实现 （几乎广泛存在于 swing 组件中）\n * javax.servlet.http.httpsessionbindinglistener\n * javax.servlet.http.httpsessionattributelistener\n * javax.faces.event.phaselistener\n\n识别方法： 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之解释器模式",frontmatter:{title:"设计模式之解释器模式",date:"2015-01-20T18:44:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/48e5aa/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/18.解释器模式.md",key:"v-cc527b5a",path:"/pages/48e5aa/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:17},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1839},{level:2,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:1846},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1853}],headersStr:"简介 实例 场景 参考资料",content:'# 设计模式之解释器模式\n\n\n# 简介\n\n解释器模式 (Interpreter) 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n解释器模式是一种行为型模式。\n\n\n\nContext : 包含解释器之外的一些全局信息。\n\n\nclass Context {\n    private String input;\n    private String output;\n\n    public void setInput(String input) {\n        this.input = input;\n    }\n\n    public String getInput() {\n        return this.input;\n    }\n\n    public void setOutput(String output) {\n        this.output = output;\n    }\n\n    public String getOutput() {\n        return this.output;\n    }\n}\n\n\nAbstractExpression : 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。\n\nabstract class AbstractExpression {\n    public abstract void Interpret(Context context);\n}\n\n\nTerminalExpression : 实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个 Interprete()方法。\n\n文法中的每一个终结符都有一个具体终结表达式与之对应。\n\nclass TerminalExpression extends AbstractExpression {\n    @Override\n    public void Interpret(Context context) {\n        context.setOutput("终端" + context.getInput());\n        System.out.println(context.getInput() + "经过终端解释器解释为：" + context.getOutput());\n    }\n}\n\n\nNonterminalExpression : 实现与文法中的非终结符相关联的解释操作。对文法中的每一条规则 R1，R2......Rn 都需要一个具体的非终结符表达式类。通过实现抽象表达式的 Interpret 方法实现解释操作。\n\nclass NonterminalExpression extends AbstractExpression {\n    @Override\n    public void Interpret(Context context) {\n        context.setOutput("非终端" + context.getInput());\n        System.out.println(context.getInput() + "经过非终端解释器解释为：" + context.getOutput());\n    }\n}\n\n\n客户端\n\npublic class InterpreterPattern {\n    public static void main(String[] args) {\n        Context context = new Context();\n        context.setInput("ABC");\n\n        AbstractExpression expression1 = new TerminalExpression();\n        expression1.Interpret(context);\n\n        AbstractExpression expression2 = new NonterminalExpression();\n        expression2.Interpret(context);\n    }\n}\n\n\n输出\n\nABC经过终端解释器解释为：终端ABC\nABC经过非终端解释器解释为：非终端ABC\n\n\n\n# 实例\n\n\n# 场景\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》',normalizedContent:'# 设计模式之解释器模式\n\n\n# 简介\n\n解释器模式 (interpreter) 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n解释器模式是一种行为型模式。\n\n\n\ncontext : 包含解释器之外的一些全局信息。\n\n\nclass context {\n    private string input;\n    private string output;\n\n    public void setinput(string input) {\n        this.input = input;\n    }\n\n    public string getinput() {\n        return this.input;\n    }\n\n    public void setoutput(string output) {\n        this.output = output;\n    }\n\n    public string getoutput() {\n        return this.output;\n    }\n}\n\n\nabstractexpression : 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。\n\nabstract class abstractexpression {\n    public abstract void interpret(context context);\n}\n\n\nterminalexpression : 实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个 interprete()方法。\n\n文法中的每一个终结符都有一个具体终结表达式与之对应。\n\nclass terminalexpression extends abstractexpression {\n    @override\n    public void interpret(context context) {\n        context.setoutput("终端" + context.getinput());\n        system.out.println(context.getinput() + "经过终端解释器解释为：" + context.getoutput());\n    }\n}\n\n\nnonterminalexpression : 实现与文法中的非终结符相关联的解释操作。对文法中的每一条规则 r1，r2......rn 都需要一个具体的非终结符表达式类。通过实现抽象表达式的 interpret 方法实现解释操作。\n\nclass nonterminalexpression extends abstractexpression {\n    @override\n    public void interpret(context context) {\n        context.setoutput("非终端" + context.getinput());\n        system.out.println(context.getinput() + "经过非终端解释器解释为：" + context.getoutput());\n    }\n}\n\n\n客户端\n\npublic class interpreterpattern {\n    public static void main(string[] args) {\n        context context = new context();\n        context.setinput("abc");\n\n        abstractexpression expression1 = new terminalexpression();\n        expression1.interpret(context);\n\n        abstractexpression expression2 = new nonterminalexpression();\n        expression2.interpret(context);\n    }\n}\n\n\n输出\n\nabc经过终端解释器解释为：终端abc\nabc经过非终端解释器解释为：非终端abc\n\n\n\n# 实例\n\n\n# 场景\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之中介者模式",frontmatter:{title:"设计模式之中介者模式",date:"2015-01-22T13:34:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/3b1f47/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/19.中介者模式.md",key:"v-04ae6228",path:"/pages/3b1f47/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:108},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:249},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:258},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:719},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:3058},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5120},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5930},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6293}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之中介者模式\n\n\n# 意图\n\n中介者模式（Mediator） 是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n\n\n# 适用场景\n\n * 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n * 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n * 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n 2. 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n 3. 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n 4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n    * 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\n\n\n# 结构代码范式\n\nMediator : 为 Colleague 对象定义一个交流接口。\n\nabstract class Mediator {\n    public abstract void Send(String message, Colleague colleague);\n}\n\n\nConcreteMediator : 实现 Mediator 中的交流接口。 这个类中需要了解并维护所有的 colleague 对象。\n\nclass ConcreteMediator extends Mediator {\n    private ConcreteColleague1 colleague1;\n    private ConcreteColleague2 colleague2;\n\n    public void setColleague1(ConcreteColleague1 colleague1) {\n        this.colleague1 = colleague1;\n    }\n\n    public void setColleague2(ConcreteColleague2 colleague2) {\n        this.colleague2 = colleague2;\n    }\n\n    @Override\n    public void Send(String message, Colleague colleague) {\n        if (colleague == colleague1) {\n            colleague2.Notify(message);\n        } else if (colleague == colleague2){\n            colleague1.Notify(message);\n        } else {\n            System.out.println("Error!");\n        }\n    }\n}\n\n\nColleague 组 : 每个 Colleague 对象应该知道它的 Mediator 对象，但不知道其他同事对象。它只能联系 Mediator 对象。\n\nabstract class Colleague {\n    protected Mediator mediator;\n\n    public Colleague(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void Send(String message) {\n        mediator.Send(message, this);\n    }\n\n    public abstract void Notify(String message);\n}\n\nclass ConcreteColleague1 extends Colleague {\n    public ConcreteColleague1(Mediator mediator) {\n        super(mediator);\n    }\n\n    @Override\n    public void Notify(String message) {\n        System.out.println("同事1得到信息：" + message);\n    }\n}\n\nclass ConcreteColleague2 extends Colleague {\n    public ConcreteColleague2(Mediator mediator) {\n        super(mediator);\n    }\n\n    @Override\n    public void Notify(String message) {\n        System.out.println("同事2得到信息：" + message);\n    }\n}\n\n\n客户端\n\npublic class MediatorPattern {\n    public static void main(String[] args) {\n        ConcreteMediator mediator = new ConcreteMediator();\n        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);\n        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);\n\n        mediator.setColleague1(colleague1);\n        mediator.setColleague2(colleague2);\n\n        colleague1.Send("How are you?");\n        colleague2.Send("Fine, thank you. And you?");\n        colleague1.Send("I\'m fine. Thankes.");\n    }\n}\n\n\n输出\n\n同事2得到信息：How are you?\n同事1得到信息：Fine, thank you. And you?\n同事2得到信息：I\'m fine. Thankes.\n\n\n\n# 伪代码\n\n在本例中， 中介者模式可帮助你减少各种 UI 类 （按钮、 复选框和文本标签） 之间的相互依赖关系。\n\n\n\n用户触发的元素不会直接与其他元素交流， 即使看上去它们应该这样做。 相反， 元素只需让中介者知晓事件即可， 并能在发出通知时同时传递任何上下文信息。\n\n本例中的中介者是整个认证对话框。 对话框知道具体元素应如何进行合作并促进它们的间接交流。 当接收到事件通知后， 对话框会确定负责处理事件的元素并据此重定向请求。\n\n// 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这\n// 些事件做出响应并将执行工作传递给其他组件。\ninterface Mediator is\n    method notify(sender: Component, event: string)\n\n\n// 具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。\nclass AuthenticationDialog implements Mediator is\n    private field title: string\n    private field loginOrRegisterChkBx: Checkbox\n    private field loginUsername, loginPassword: Textbox\n    private field registrationUsername, registrationPassword,\n                  registrationEmail: Textbox\n    private field okBtn, cancelBtn: Button\n\n    constructor AuthenticationDialog() is\n        // 创建所有组件对象并将当前中介者传递给其构造函数以建立连接。\n\n    // 当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，\n    // 也可将请求传递给另一个组件。\n    method notify(sender, event) is\n        if (sender == loginOrRegisterChkBx and event == "check")\n            if (loginOrRegisterChkBx.checked)\n                title = "登录"\n                // 1. 显示登录表单组件。\n                // 2. 隐藏注册表单组件。\n            else\n                title = "注册"\n                // 1. 显示注册表单组件。\n                // 2. 隐藏登录表单组件。\n\n        if (sender == okBtn && event == "click")\n            if (loginOrRegister.checked)\n                // 尝试找到使用登录信息的用户。\n                if (!found)\n                    // 在登录字段上方显示错误信息。\n            else\n                // 1. 使用注册字段中的数据创建用户账号。\n                // 2. 完成用户登录工作。 …\n\n\n// 组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接\n// 起来，你就能在其他情境中使用这些组件了。\nclass Component is\n    field dialog: Mediator\n\n    constructor Component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, "click")\n\n    method keypress() is\n        dialog.notify(this, "keypress")\n\n// 具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。\nclass Button extends Component is\n    // ...\n\nclass Textbox extends Component is\n    // ...\n\nclass Checkbox extends Component is\n    method check() is\n        dialog.notify(this, "check")\n    // ...\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 案例\n\n使用示例： 中介者模式在 Java 代码中最常用于帮助程序 GUI 组件之间的通信。 在 MVC 模式中， 控制器是中介者的同义词。\n\n下面是核心 Java 程序库中该模式的一些示例：\n\n * java.util.Timer （所有 schedule­XXX()方法）\n * java.util.concurrent.Executor#execute()\n * java.util.concurrent.ExecutorService （ invoke­XXX()和 submit­()方法）\n * java.util.concurrent.ScheduledExecutorService （所有 schedule­XXX()方法）\n * java.lang.reflect.Method#invoke()\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之中介者模式\n\n\n# 意图\n\n中介者模式（mediator） 是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n\n\n# 适用场景\n\n * 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n * 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n * 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n\n\n# 结构\n\n\n\n\n# 结构说明\n\n 1. 组件 （component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n 2. 中介者 （mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n 3. 具体中介者 （concrete mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n 4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n    * 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\n\n\n# 结构代码范式\n\nmediator : 为 colleague 对象定义一个交流接口。\n\nabstract class mediator {\n    public abstract void send(string message, colleague colleague);\n}\n\n\nconcretemediator : 实现 mediator 中的交流接口。 这个类中需要了解并维护所有的 colleague 对象。\n\nclass concretemediator extends mediator {\n    private concretecolleague1 colleague1;\n    private concretecolleague2 colleague2;\n\n    public void setcolleague1(concretecolleague1 colleague1) {\n        this.colleague1 = colleague1;\n    }\n\n    public void setcolleague2(concretecolleague2 colleague2) {\n        this.colleague2 = colleague2;\n    }\n\n    @override\n    public void send(string message, colleague colleague) {\n        if (colleague == colleague1) {\n            colleague2.notify(message);\n        } else if (colleague == colleague2){\n            colleague1.notify(message);\n        } else {\n            system.out.println("error!");\n        }\n    }\n}\n\n\ncolleague 组 : 每个 colleague 对象应该知道它的 mediator 对象，但不知道其他同事对象。它只能联系 mediator 对象。\n\nabstract class colleague {\n    protected mediator mediator;\n\n    public colleague(mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void send(string message) {\n        mediator.send(message, this);\n    }\n\n    public abstract void notify(string message);\n}\n\nclass concretecolleague1 extends colleague {\n    public concretecolleague1(mediator mediator) {\n        super(mediator);\n    }\n\n    @override\n    public void notify(string message) {\n        system.out.println("同事1得到信息：" + message);\n    }\n}\n\nclass concretecolleague2 extends colleague {\n    public concretecolleague2(mediator mediator) {\n        super(mediator);\n    }\n\n    @override\n    public void notify(string message) {\n        system.out.println("同事2得到信息：" + message);\n    }\n}\n\n\n客户端\n\npublic class mediatorpattern {\n    public static void main(string[] args) {\n        concretemediator mediator = new concretemediator();\n        concretecolleague1 colleague1 = new concretecolleague1(mediator);\n        concretecolleague2 colleague2 = new concretecolleague2(mediator);\n\n        mediator.setcolleague1(colleague1);\n        mediator.setcolleague2(colleague2);\n\n        colleague1.send("how are you?");\n        colleague2.send("fine, thank you. and you?");\n        colleague1.send("i\'m fine. thankes.");\n    }\n}\n\n\n输出\n\n同事2得到信息：how are you?\n同事1得到信息：fine, thank you. and you?\n同事2得到信息：i\'m fine. thankes.\n\n\n\n# 伪代码\n\n在本例中， 中介者模式可帮助你减少各种 ui 类 （按钮、 复选框和文本标签） 之间的相互依赖关系。\n\n\n\n用户触发的元素不会直接与其他元素交流， 即使看上去它们应该这样做。 相反， 元素只需让中介者知晓事件即可， 并能在发出通知时同时传递任何上下文信息。\n\n本例中的中介者是整个认证对话框。 对话框知道具体元素应如何进行合作并促进它们的间接交流。 当接收到事件通知后， 对话框会确定负责处理事件的元素并据此重定向请求。\n\n// 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这\n// 些事件做出响应并将执行工作传递给其他组件。\ninterface mediator is\n    method notify(sender: component, event: string)\n\n\n// 具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。\nclass authenticationdialog implements mediator is\n    private field title: string\n    private field loginorregisterchkbx: checkbox\n    private field loginusername, loginpassword: textbox\n    private field registrationusername, registrationpassword,\n                  registrationemail: textbox\n    private field okbtn, cancelbtn: button\n\n    constructor authenticationdialog() is\n        // 创建所有组件对象并将当前中介者传递给其构造函数以建立连接。\n\n    // 当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，\n    // 也可将请求传递给另一个组件。\n    method notify(sender, event) is\n        if (sender == loginorregisterchkbx and event == "check")\n            if (loginorregisterchkbx.checked)\n                title = "登录"\n                // 1. 显示登录表单组件。\n                // 2. 隐藏注册表单组件。\n            else\n                title = "注册"\n                // 1. 显示注册表单组件。\n                // 2. 隐藏登录表单组件。\n\n        if (sender == okbtn && event == "click")\n            if (loginorregister.checked)\n                // 尝试找到使用登录信息的用户。\n                if (!found)\n                    // 在登录字段上方显示错误信息。\n            else\n                // 1. 使用注册字段中的数据创建用户账号。\n                // 2. 完成用户登录工作。 …\n\n\n// 组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接\n// 起来，你就能在其他情境中使用这些组件了。\nclass component is\n    field dialog: mediator\n\n    constructor component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, "click")\n\n    method keypress() is\n        dialog.notify(this, "keypress")\n\n// 具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。\nclass button extends component is\n    // ...\n\nclass textbox extends component is\n    // ...\n\nclass checkbox extends component is\n    method check() is\n        dialog.notify(this, "check")\n    // ...\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 案例\n\n使用示例： 中介者模式在 java 代码中最常用于帮助程序 gui 组件之间的通信。 在 mvc 模式中， 控制器是中介者的同义词。\n\n下面是核心 java 程序库中该模式的一些示例：\n\n * java.util.timer （所有 schedule­xxx()方法）\n * java.util.concurrent.executor#execute()\n * java.util.concurrent.executorservice （ invoke­xxx()和 submit­()方法）\n * java.util.concurrent.scheduledexecutorservice （所有 schedule­xxx()方法）\n * java.lang.reflect.method#invoke()\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之职责链模式",frontmatter:{title:"设计模式之职责链模式",date:"2015-01-22T14:34:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/b25735/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/20.职责链模式.md",key:"v-1a6137e8",path:"/pages/b25735/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:199},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:325},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:332},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:800},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2541},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:4732},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5305},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5575}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之职责链模式\n\n\n# 意图\n\n职责链模式（Chain Of Responsibility） 是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 适用场景\n\n * 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n * 当必须按顺序执行多个处理者时， 可以使用该模式。\n * 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 处理者 （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。\n\n 2. 基础处理者 （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。\n    \n    通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。\n\n 3. 具体处理者 （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。\n    \n    处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。\n\n 4. 客户端 （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。\n\n\n# 结构代码范式\n\nHandler : 定义一个处理请求的接口。（可选的）实现设置后继者的方法。\n\nabstract class Handler {\n    protected Handler successor;\n    public void SetSuccesssor(Handler successor) {\n        this.successor = successor;\n    }\n\n    public abstract void HandlerRequest(int request);\n}\n\n\nConcreteHandler : 处理它所负责的请求，可以访问它的后继者，如果可处理该请求，就处理之，否则就将请求转发给它的后继者。\n\nclass ConcreteHandler1 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 0 && request < 10) {\n            System.out.println("ConcreteHandler1 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 10 && request < 20) {\n            System.out.println("ConcreteHandler2 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\nclass ConcreteHandler3 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 20 && request < 30) {\n            System.out.println("ConcreteHandler3 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\n\nClient : 需要设置一个职责链的各环节对象串联起来。\n\npublic class ChainOfResponsibilityPattern {\n    public static void main(String[] args) {\n        Handler h1 = new ConcreteHandler1();\n        Handler h2 = new ConcreteHandler2();\n        Handler h3 = new ConcreteHandler3();\n        h1.SetSuccesssor(h2);\n        h2.SetSuccesssor(h3);\n\n        int[] requests = {2, 29, 9, 15, 4, 19};\n        for (int i : requests) {\n            h1.HandlerRequest(i);\n        }\n    }\n}\n\n\n\n# 伪代码\n\n在本例中， 责任链模式负责为活动的 GUI 元素显示上下文帮助信息。\n\n\n\n应用程序的 GUI 　通常为对象树结构。 例如， 负责渲染程序主窗口的 对话框类就是对象树的根节点。 对话框包含 面板 ， 而面板可能包含其他面板， 或是 按钮和 文本框等下层元素。\n\n只要给一个简单的组件指定帮助文本， 它就可显示简短的上下文提示。 但更复杂的组件可自定义上下文帮助文本的显示方式， 例如显示手册摘录内容或在浏览器中打开一个网页。\n\n\n\n当用户将鼠标指针移动到某个元素并按下 F1键时， 程序检测到指针下的组件并对其发送帮助请求。 该请求不断向上传递到该元素所有的容器， 直至某个元素能够显示帮助信息。\n\n// 处理者接口声明了一个创建处理者链的方法。还声明了一个执行请求的方法。\ninterface ComponentWithContextualHelp is\n    method showHelp()\n\n\n// 简单组件的基础类。\nabstract class Component implements ComponentWithContextualHelp is\n    field tooltipText: string\n\n    // 组件容器在处理者链中作为“下一个”链接。\n    protected field container: Container\n\n    // 如果组件设定了帮助文字，那它将会显示提示信息。如果组件没有帮助文字\n    // 且其容器存在，那它会将调用传递给容器。\n    method showHelp() is\n        if (tooltipText != null)\n            // 显示提示信息。\n        else\n            container.showHelp()\n\n\n// 容器可以将简单组件和其他容器作为其子项目。链关系将在这里建立。该类将从\n// 其父类处继承 showHelp（显示帮助）的行为。\nabstract class Container extends Component is\n    protected field children: array of Component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n\n// 原始组件应该能够使用帮助操作的默认实现...\nclass Button extends Component is\n    // ...\n\n// 但复杂组件可能会对默认实现进行重写。如果无法以新的方式来提供帮助文字，\n// 那组件总是还能调用基础实现的（参见 Component 类）。\nclass Panel extends Container is\n    field modalHelpText: string\n\n    method showHelp() is\n        if (modalHelpText != null)\n            // 显示包含帮助文字的模态窗口。\n        else\n            super.showHelp()\n\n// ...同上...\nclass Dialog extends Container is\n    field wikiPageURL: string\n\n    method showHelp() is\n        if (wikiPageURL != null)\n            // 打开百科帮助页面。\n        else\n            super.showHelp()\n\n\n// 客户端代码。\nclass Application is\n    // 每个程序都能以不同方式对链进行配置。\n    method createUI() is\n        dialog = new Dialog("预算报告")\n        dialog.wikiPageURL = "http://..."\n        panel = new Panel(0, 0, 400, 800)\n        panel.modalHelpText = "本面板用于..."\n        ok = new Button(250, 760, 50, 20, "确认")\n        ok.tooltipText = "这是一个确认按钮..."\n        cancel = new Button(320, 760, 50, 20, "取消")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // 想象这里会发生什么。\n    method onF1KeyPress() is\n        component = this.getComponentAtMouseCoords()\n        component.showHelp()\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   \n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n\n * 责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   \n   还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n\n * 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   \n   责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n\n\n# 案例\n\n使用示例： 责任链模式在 Java 程序中并不常见， 因为它仅在代码与对象链打交道时才能发挥作用。\n\n该模式最流行的使用案例之一是在 GUI 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。\n\n下面是该模式在核心 Java 程序库中的一些示例：\n\n * javax.servlet.Filter#doFilter()\n * java.util.logging.Logger#log()\n\n识别方法： 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之职责链模式\n\n\n# 意图\n\n职责链模式（chain of responsibility） 是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 适用场景\n\n * 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n * 当必须按顺序执行多个处理者时， 可以使用该模式。\n * 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 处理者 （handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。\n\n 2. 基础处理者 （base handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。\n    \n    通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。\n\n 3. 具体处理者 （concrete handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。\n    \n    处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。\n\n 4. 客户端 （client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。\n\n\n# 结构代码范式\n\nhandler : 定义一个处理请求的接口。（可选的）实现设置后继者的方法。\n\nabstract class handler {\n    protected handler successor;\n    public void setsuccesssor(handler successor) {\n        this.successor = successor;\n    }\n\n    public abstract void handlerrequest(int request);\n}\n\n\nconcretehandler : 处理它所负责的请求，可以访问它的后继者，如果可处理该请求，就处理之，否则就将请求转发给它的后继者。\n\nclass concretehandler1 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 0 && request < 10) {\n            system.out.println("concretehandler1 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\nclass concretehandler2 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 10 && request < 20) {\n            system.out.println("concretehandler2 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\nclass concretehandler3 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 20 && request < 30) {\n            system.out.println("concretehandler3 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\n\nclient : 需要设置一个职责链的各环节对象串联起来。\n\npublic class chainofresponsibilitypattern {\n    public static void main(string[] args) {\n        handler h1 = new concretehandler1();\n        handler h2 = new concretehandler2();\n        handler h3 = new concretehandler3();\n        h1.setsuccesssor(h2);\n        h2.setsuccesssor(h3);\n\n        int[] requests = {2, 29, 9, 15, 4, 19};\n        for (int i : requests) {\n            h1.handlerrequest(i);\n        }\n    }\n}\n\n\n\n# 伪代码\n\n在本例中， 责任链模式负责为活动的 gui 元素显示上下文帮助信息。\n\n\n\n应用程序的 gui 　通常为对象树结构。 例如， 负责渲染程序主窗口的 对话框类就是对象树的根节点。 对话框包含 面板 ， 而面板可能包含其他面板， 或是 按钮和 文本框等下层元素。\n\n只要给一个简单的组件指定帮助文本， 它就可显示简短的上下文提示。 但更复杂的组件可自定义上下文帮助文本的显示方式， 例如显示手册摘录内容或在浏览器中打开一个网页。\n\n\n\n当用户将鼠标指针移动到某个元素并按下 f1键时， 程序检测到指针下的组件并对其发送帮助请求。 该请求不断向上传递到该元素所有的容器， 直至某个元素能够显示帮助信息。\n\n// 处理者接口声明了一个创建处理者链的方法。还声明了一个执行请求的方法。\ninterface componentwithcontextualhelp is\n    method showhelp()\n\n\n// 简单组件的基础类。\nabstract class component implements componentwithcontextualhelp is\n    field tooltiptext: string\n\n    // 组件容器在处理者链中作为“下一个”链接。\n    protected field container: container\n\n    // 如果组件设定了帮助文字，那它将会显示提示信息。如果组件没有帮助文字\n    // 且其容器存在，那它会将调用传递给容器。\n    method showhelp() is\n        if (tooltiptext != null)\n            // 显示提示信息。\n        else\n            container.showhelp()\n\n\n// 容器可以将简单组件和其他容器作为其子项目。链关系将在这里建立。该类将从\n// 其父类处继承 showhelp（显示帮助）的行为。\nabstract class container extends component is\n    protected field children: array of component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n\n// 原始组件应该能够使用帮助操作的默认实现...\nclass button extends component is\n    // ...\n\n// 但复杂组件可能会对默认实现进行重写。如果无法以新的方式来提供帮助文字，\n// 那组件总是还能调用基础实现的（参见 component 类）。\nclass panel extends container is\n    field modalhelptext: string\n\n    method showhelp() is\n        if (modalhelptext != null)\n            // 显示包含帮助文字的模态窗口。\n        else\n            super.showhelp()\n\n// ...同上...\nclass dialog extends container is\n    field wikipageurl: string\n\n    method showhelp() is\n        if (wikipageurl != null)\n            // 打开百科帮助页面。\n        else\n            super.showhelp()\n\n\n// 客户端代码。\nclass application is\n    // 每个程序都能以不同方式对链进行配置。\n    method createui() is\n        dialog = new dialog("预算报告")\n        dialog.wikipageurl = "http://..."\n        panel = new panel(0, 0, 400, 800)\n        panel.modalhelptext = "本面板用于..."\n        ok = new button(250, 760, 50, 20, "确认")\n        ok.tooltiptext = "这是一个确认按钮..."\n        cancel = new button(320, 760, 50, 20, "取消")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // 想象这里会发生什么。\n    method onf1keypress() is\n        component = this.getcomponentatmousecoords()\n        component.showhelp()\n\n\n\n# 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   \n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n\n * 责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   \n   还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n\n * 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   \n   责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n\n\n# 案例\n\n使用示例： 责任链模式在 java 程序中并不常见， 因为它仅在代码与对象链打交道时才能发挥作用。\n\n该模式最流行的使用案例之一是在 gui 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。\n\n下面是该模式在核心 java 程序库中的一些示例：\n\n * javax.servlet.filter#dofilter()\n * java.util.logging.logger#log()\n\n识别方法： 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之备忘录模式",frontmatter:{title:"设计模式之备忘录模式",date:"2015-01-22T15:26:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/5ae0d5/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/21.备忘录模式.md",key:"v-ca584e06",path:"/pages/5ae0d5/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:81},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:173},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:180},{level:4,title:"基于嵌套类的实现",slug:"基于嵌套类的实现",normalizedTitle:"基于嵌套类的实现",charIndex:188},{level:4,title:"基于中间接口的实现",slug:"基于中间接口的实现",normalizedTitle:"基于中间接口的实现",charIndex:614},{level:4,title:"封装更加严格的实现",slug:"封装更加严格的实现",normalizedTitle:"封装更加严格的实现",charIndex:834},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:1131},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:2677},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:4338},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4557},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4780}],headersStr:"意图 适用场景 结构 结构说明 基于嵌套类的实现 基于中间接口的实现 封装更加严格的实现 结构代码范式 伪代码 与其他模式的关系 案例 参考资料",content:'# 设计模式之备忘录模式\n\n\n# 意图\n\n备忘录模式（Memento） 是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n\n\n# 适用场景\n\n * 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n * 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n# 基于嵌套类的实现\n\n\n\n 1. 原发器 （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n\n 2. 备忘录 （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n\n 3. 负责人 （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。\n    \n    负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n\n 4. 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n\n# 基于中间接口的实现\n\n另外一种实现方法适用于不支持嵌套类的编程语言 （没错， 我说的就是 PHP）。\n\n\n\n 1. 在没有嵌套类的情况下， 你可以规定负责人仅可通过明确声明的中间接口与备忘录互动， 该接口仅声明与备忘录元数据相关的方法， 限制其对备忘录成员变量的直接访问权限。\n 2. 另一方面， 原发器可以直接与备忘录对象进行交互， 访问备忘录类中声明的成员变量和方法。 这种方式的缺点在于你需要将备忘录的所有成员变量声明为公有。\n\n# 封装更加严格的实现\n\n如果你不想让其他类有任何机会通过备忘录来访问原发器的状态， 那么还有另一种可用的实现方式。\n\n\n\n 1. 这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。\n 2. 负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。\n 3. 每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。\n\n\n# 结构代码范式\n\nMemento : 负责存储 Originator 对象的内部状态，并可以防止 Originator 以外的其他对象访问 Memento。\n\nMemento 有两个接口，Caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。 Originator 可以看到一个宽接口，允许它访问返回到先前状态所需的所有数据。\n\nclass Memento {\n    private String state;\n    public Memento(String state) {\n        this.state = state;\n    }\n\n    public String GetState() {\n        return state;\n    }\n}\n\n\nOriginator : 负责创建一个备忘录 Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。\n\nOriginator 可根据需要决定 Memento 存储 Originator 的哪些内部状态。\n\nclass Originator {\n    private String state;\n\n    public void SetState(String state) {\n        this.state = state;\n    }\n    public String GetState() {\n        return state;\n    }\n\n    public Memento CreateMemento() {\n        return (new Memento(state));\n    }\n\n    public void SetMemento(Memento memento) {\n        state = memento.GetState();\n    }\n\n    public void Show() {\n        System.out.println("State = " + state);\n    }\n}\n\n\nCaretaker : 负责保存好备忘录 Memento，不能对备忘录的内容进行操作或检查。\n\nclass Caretaker {\n    private Memento memento;\n\n    public void SetMemento(Memento memento) {\n        this.memento = memento;\n    }\n    public Memento GetMemento() {\n        return memento;\n    }\n}\n\n\n客户端\n\npublic class MementoPattern {\n    public static void main(String[] args) {\n        Originator o = new Originator();\n        o.SetState("ON");\n        o.Show();\n\n        Caretaker c = new Caretaker();\n        c.SetMemento(o.CreateMemento());\n\n        o.SetState("OFF");\n        o.Show();\n\n        o.SetMemento(c.GetMemento());\n        o.Show();\n    }\n}\n\n\n输出\n\nState = ON\nState = OFF\nState = ON\n\n\n\n# 伪代码\n\n本例结合使用了命令模式与备忘录模式， 可保存复杂文字编辑器的状态快照， 并能在需要时从快照中恢复之前的状态。\n\n\n\n命令 （command） 对象将作为负责人， 它们会在执行与命令相关的操作前获取编辑器的备忘录。 当用户试图撤销最近的命令时， 编辑器可以使用保存在命令中的备忘录来将自身回滚到之前的状态。\n\n备忘录类没有声明任何公有的成员变量、 获取器 （getter） 和设置器， 因此没有对象可以修改其内容。 备忘录与创建自己的编辑器相连接， 这使得备忘录能够通过编辑器对象的设置器传递数据， 恢复与其相连接的编辑器的状态。 由于备忘录与特定的编辑器对象相连接， 程序可以使用中心化的撤销栈实现对多个独立编辑器窗口的支持。\n\n// 原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存\n// 自身状态的方法，以及从备忘录中恢复状态的方法。\nclass Editor is\n    private field text, curX, curY, selectionWidth\n\n    method setText(text) is\n        this.text = text\n\n    method setCursor(x, y) is\n        this.curX = curX\n        this.curY = curY\n\n    method setSelectionWidth(width) is\n        this.selectionWidth = width\n\n    // 在备忘录中保存当前的状态。\n    method createSnapshot():Snapshot is\n        // 备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘\n        // 录的构造函数。\n        return new Snapshot(this, text, curX, curY, selectionWidth)\n\n// 备忘录类保存有编辑器的过往状态。\nclass Snapshot is\n    private field editor: Editor\n    private field text, curX, curY, selectionWidth\n\n    constructor Snapshot(editor, text, curX, curY, selectionWidth) is\n        this.editor = editor\n        this.text = text\n        this.curX = curX\n        this.curY = curY\n        this.selectionWidth = selectionWidth\n\n    // 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。\n    method restore() is\n        editor.setText(text)\n        editor.setCursor(curX, curY)\n        editor.setSelectionWidth(selectionWidth)\n\n// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个\n// 备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。\nclass Command is\n    private field backup: Snapshot\n\n    method makeBackup() is\n        backup = editor.createSnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n\n\n\n# 与其他模式的关系\n\n * 你可以同时使用命令模式和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n\n\n# 案例\n\n使用示例： 备忘录的基本原则可通过序列化来实现， 这在 Java 语言中很常见。 尽管备忘录不是生成对象状态快照的唯一或最有效方法， 但它能在保护原始对象的结构不暴露给其他对象的情况下保存对象状态的备份。\n\n下面是核心 Java 程序库中该模式的一些示例：\n\n * 所有 java.io.Serializable 的实现都可以模拟备忘录。\n * 所有 javax.faces.component.StateHolder 的实现。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之备忘录模式\n\n\n# 意图\n\n备忘录模式（memento） 是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n\n\n# 适用场景\n\n * 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n * 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n# 基于嵌套类的实现\n\n\n\n 1. 原发器 （originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n\n 2. 备忘录 （memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n\n 3. 负责人 （caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。\n    \n    负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n\n 4. 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n\n# 基于中间接口的实现\n\n另外一种实现方法适用于不支持嵌套类的编程语言 （没错， 我说的就是 php）。\n\n\n\n 1. 在没有嵌套类的情况下， 你可以规定负责人仅可通过明确声明的中间接口与备忘录互动， 该接口仅声明与备忘录元数据相关的方法， 限制其对备忘录成员变量的直接访问权限。\n 2. 另一方面， 原发器可以直接与备忘录对象进行交互， 访问备忘录类中声明的成员变量和方法。 这种方式的缺点在于你需要将备忘录的所有成员变量声明为公有。\n\n# 封装更加严格的实现\n\n如果你不想让其他类有任何机会通过备忘录来访问原发器的状态， 那么还有另一种可用的实现方式。\n\n\n\n 1. 这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。\n 2. 负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。\n 3. 每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。\n\n\n# 结构代码范式\n\nmemento : 负责存储 originator 对象的内部状态，并可以防止 originator 以外的其他对象访问 memento。\n\nmemento 有两个接口，caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。 originator 可以看到一个宽接口，允许它访问返回到先前状态所需的所有数据。\n\nclass memento {\n    private string state;\n    public memento(string state) {\n        this.state = state;\n    }\n\n    public string getstate() {\n        return state;\n    }\n}\n\n\noriginator : 负责创建一个备忘录 memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。\n\noriginator 可根据需要决定 memento 存储 originator 的哪些内部状态。\n\nclass originator {\n    private string state;\n\n    public void setstate(string state) {\n        this.state = state;\n    }\n    public string getstate() {\n        return state;\n    }\n\n    public memento creatememento() {\n        return (new memento(state));\n    }\n\n    public void setmemento(memento memento) {\n        state = memento.getstate();\n    }\n\n    public void show() {\n        system.out.println("state = " + state);\n    }\n}\n\n\ncaretaker : 负责保存好备忘录 memento，不能对备忘录的内容进行操作或检查。\n\nclass caretaker {\n    private memento memento;\n\n    public void setmemento(memento memento) {\n        this.memento = memento;\n    }\n    public memento getmemento() {\n        return memento;\n    }\n}\n\n\n客户端\n\npublic class mementopattern {\n    public static void main(string[] args) {\n        originator o = new originator();\n        o.setstate("on");\n        o.show();\n\n        caretaker c = new caretaker();\n        c.setmemento(o.creatememento());\n\n        o.setstate("off");\n        o.show();\n\n        o.setmemento(c.getmemento());\n        o.show();\n    }\n}\n\n\n输出\n\nstate = on\nstate = off\nstate = on\n\n\n\n# 伪代码\n\n本例结合使用了命令模式与备忘录模式， 可保存复杂文字编辑器的状态快照， 并能在需要时从快照中恢复之前的状态。\n\n\n\n命令 （command） 对象将作为负责人， 它们会在执行与命令相关的操作前获取编辑器的备忘录。 当用户试图撤销最近的命令时， 编辑器可以使用保存在命令中的备忘录来将自身回滚到之前的状态。\n\n备忘录类没有声明任何公有的成员变量、 获取器 （getter） 和设置器， 因此没有对象可以修改其内容。 备忘录与创建自己的编辑器相连接， 这使得备忘录能够通过编辑器对象的设置器传递数据， 恢复与其相连接的编辑器的状态。 由于备忘录与特定的编辑器对象相连接， 程序可以使用中心化的撤销栈实现对多个独立编辑器窗口的支持。\n\n// 原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存\n// 自身状态的方法，以及从备忘录中恢复状态的方法。\nclass editor is\n    private field text, curx, cury, selectionwidth\n\n    method settext(text) is\n        this.text = text\n\n    method setcursor(x, y) is\n        this.curx = curx\n        this.cury = cury\n\n    method setselectionwidth(width) is\n        this.selectionwidth = width\n\n    // 在备忘录中保存当前的状态。\n    method createsnapshot():snapshot is\n        // 备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘\n        // 录的构造函数。\n        return new snapshot(this, text, curx, cury, selectionwidth)\n\n// 备忘录类保存有编辑器的过往状态。\nclass snapshot is\n    private field editor: editor\n    private field text, curx, cury, selectionwidth\n\n    constructor snapshot(editor, text, curx, cury, selectionwidth) is\n        this.editor = editor\n        this.text = text\n        this.curx = curx\n        this.cury = cury\n        this.selectionwidth = selectionwidth\n\n    // 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。\n    method restore() is\n        editor.settext(text)\n        editor.setcursor(curx, cury)\n        editor.setselectionwidth(selectionwidth)\n\n// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个\n// 备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。\nclass command is\n    private field backup: snapshot\n\n    method makebackup() is\n        backup = editor.createsnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n\n\n\n# 与其他模式的关系\n\n * 你可以同时使用命令模式和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n\n\n# 案例\n\n使用示例： 备忘录的基本原则可通过序列化来实现， 这在 java 语言中很常见。 尽管备忘录不是生成对象状态快照的唯一或最有效方法， 但它能在保护原始对象的结构不暴露给其他对象的情况下保存对象状态的备份。\n\n下面是核心 java 程序库中该模式的一些示例：\n\n * 所有 java.io.serializable 的实现都可以模拟备忘录。\n * 所有 javax.faces.component.stateholder 的实现。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之策略模式",frontmatter:{title:"设计模式之策略模式",date:"2015-01-22T16:14:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/dc8ecd/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/22.策略模式.md",key:"v-f0251290",path:"/pages/dc8ecd/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:95},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:279},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:286},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:584},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1922},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:3393},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:3805},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4447}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之策略模式\n\n\n# 意图\n\n策略模式（Strategy） 是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n\n# 适用场景\n\n * 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n * 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n * 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n * 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。\n 2. 策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。\n 3. 具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。\n 4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。\n 5. 客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。\n\n\n# 结构代码范式\n\nStrategy : 定义所有算法的公共接口(AlgorithmInterface)。Context 使用这个接口去调用 ConcreteStrategy 定义的具体算法。\n\nabstract class Strategy {\n    public abstract void AlgorithmInterface();\n}\n\n\nConcreteStrategy : 实现 Strategy 中的算法接口(AlgorithmInterface)。\n\nclass ConcreteStrategyA extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法A");\n    }\n}\n\nclass ConcreteStrategyB extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法B");\n    }\n}\n\nclass ConcreteStrategyC extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法C");\n    }\n}\n\n\nContext : 用一个 ConcreteStrategy 来配置。维护一个对 Strategy 对象的引用。\n\nclass Context {\n    Strategy strategy;\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void ContextInterface() {\n        strategy.AlgorithmInterface();\n    }\n}\n\n\n客户端\n\npublic class StrategyPattern {\n    public static void main(String[] args) {\n        Context context1 = new Context(new ConcreteStrategyA());\n        context1.ContextInterface();\n\n        Context context2 = new Context(new ConcreteStrategyB());\n        context2.ContextInterface();\n\n        Context context3 = new Context(new ConcreteStrategyC());\n        context3.ContextInterface();\n    }\n}\n\n\n输出\n\n算法A\n算法B\n算法C\n\n\n\n# 伪代码\n\n在本例中， 上下文使用了多个策略来执行不同的计算操作。\n\n// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来\n// 调用有具体策略定义的算法。\ninterface Strategy is\n    method execute(a, b)\n\n// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文\n// 中的互换性。\nclass ConcreteStrategyAdd implements Strategy is\n    method execute(a, b) is\n        return a + b\n\nclass ConcreteStrategySubtract implements Strategy is\n    method execute(a, b) is\n        return a - b\n\nclass ConcreteStrategyMultiply implements Strategy is\n    method execute(a, b) is\n        return a * b\n\n// 上下文定义了客户端关注的接口。\nclass Context is\n    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下\n    // 文必须通过策略接口来与所有策略进行交互。\n    private strategy: Strategy\n\n    // 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行\n    // 时切换策略。\n    method setStrategy(Strategy strategy) is\n        this.strategy = strategy\n\n    // 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。\n    method executeStrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n\n// 客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差\n// 异，才能做出正确的选择。\nclass ExampleApplication is\n    method main() is\n\n        创建上下文对象。\n\n        读取第一个数。\n        读取最后一个数。\n        从用户输入中读取期望进行的行为。\n\n        if (action == addition) then\n            context.setStrategy(new ConcreteStrategyAdd())\n\n        if (action == subtraction) then\n            context.setStrategy(new ConcreteStrategySubtract())\n\n        if (action == multiplication) then\n            context.setStrategy(new ConcreteStrategyMultiply())\n\n        result = context.executeStrategy(First number, Second number)\n\n        打印结果。\n\n\n\n# 案例\n\n使用示例： 策略模式在 Java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。\n\nJava 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。\n\n这里有一些核心 Java 程序库中策略模式的示例：\n\n * 对 java.util.Comparator#compare() 的调用来自 Collections#sort().\n * javax.servlet.http.HttpServlet： service­()方法， 还有所有接受 Http­Servlet­Request和 Http­Servlet­Response对象作为参数的 do­XXX()方法。\n * javax.servlet.Filter#doFilter()\n\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。\n * 模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之策略模式\n\n\n# 意图\n\n策略模式（strategy） 是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n\n# 适用场景\n\n * 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n * 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n * 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n * 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 上下文 （context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。\n 2. 策略 （strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。\n 3. 具体策略 （concrete strategies） 实现了上下文所用算法的各种不同变体。\n 4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。\n 5. 客户端 （client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。\n\n\n# 结构代码范式\n\nstrategy : 定义所有算法的公共接口(algorithminterface)。context 使用这个接口去调用 concretestrategy 定义的具体算法。\n\nabstract class strategy {\n    public abstract void algorithminterface();\n}\n\n\nconcretestrategy : 实现 strategy 中的算法接口(algorithminterface)。\n\nclass concretestrategya extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法a");\n    }\n}\n\nclass concretestrategyb extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法b");\n    }\n}\n\nclass concretestrategyc extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法c");\n    }\n}\n\n\ncontext : 用一个 concretestrategy 来配置。维护一个对 strategy 对象的引用。\n\nclass context {\n    strategy strategy;\n    public context(strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void contextinterface() {\n        strategy.algorithminterface();\n    }\n}\n\n\n客户端\n\npublic class strategypattern {\n    public static void main(string[] args) {\n        context context1 = new context(new concretestrategya());\n        context1.contextinterface();\n\n        context context2 = new context(new concretestrategyb());\n        context2.contextinterface();\n\n        context context3 = new context(new concretestrategyc());\n        context3.contextinterface();\n    }\n}\n\n\n输出\n\n算法a\n算法b\n算法c\n\n\n\n# 伪代码\n\n在本例中， 上下文使用了多个策略来执行不同的计算操作。\n\n// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来\n// 调用有具体策略定义的算法。\ninterface strategy is\n    method execute(a, b)\n\n// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文\n// 中的互换性。\nclass concretestrategyadd implements strategy is\n    method execute(a, b) is\n        return a + b\n\nclass concretestrategysubtract implements strategy is\n    method execute(a, b) is\n        return a - b\n\nclass concretestrategymultiply implements strategy is\n    method execute(a, b) is\n        return a * b\n\n// 上下文定义了客户端关注的接口。\nclass context is\n    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下\n    // 文必须通过策略接口来与所有策略进行交互。\n    private strategy: strategy\n\n    // 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行\n    // 时切换策略。\n    method setstrategy(strategy strategy) is\n        this.strategy = strategy\n\n    // 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。\n    method executestrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n\n// 客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差\n// 异，才能做出正确的选择。\nclass exampleapplication is\n    method main() is\n\n        创建上下文对象。\n\n        读取第一个数。\n        读取最后一个数。\n        从用户输入中读取期望进行的行为。\n\n        if (action == addition) then\n            context.setstrategy(new concretestrategyadd())\n\n        if (action == subtraction) then\n            context.setstrategy(new concretestrategysubtract())\n\n        if (action == multiplication) then\n            context.setstrategy(new concretestrategymultiply())\n\n        result = context.executestrategy(first number, second number)\n\n        打印结果。\n\n\n\n# 案例\n\n使用示例： 策略模式在 java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。\n\njava 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。\n\n这里有一些核心 java 程序库中策略模式的示例：\n\n * 对 java.util.comparator#compare() 的调用来自 collections#sort().\n * javax.servlet.http.httpservlet： service­()方法， 还有所有接受 http­servlet­request和 http­servlet­response对象作为参数的 do­xxx()方法。\n * javax.servlet.filter#dofilter()\n\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。\n * 模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之访问者模式",frontmatter:{title:"设计模式之访问者模式",date:"2015-01-22T18:25:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/671352/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/23.访问者模式.md",key:"v-0f7af49e",path:"/pages/671352/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:17},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:70},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:91},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:209},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:630},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:3208},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4977},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:5340},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5483}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之访问者模式\n\n\n# 意图\n\n访问者模式（Visitor） 是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n\n# 适用场景\n\n * 如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n * 可使用访问者模式来清理辅助行为的业务逻辑。\n * 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 访问者 （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。\n 2. 具体访问者 （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。\n 3. 元素 （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。\n 4. 具体元素 （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。\n 5. 客户端 （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。\n\n\n# 结构代码范式\n\nVisitor : 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。\n\nabstract class Visitor {\n    public abstract void VisitConcreteElementA(ConcreteElementA elementA);\n    public abstract void VisitConcreteElementB(ConcreteElementB elementB);\n}\n\n\nConcreteVisitor : 实现每个由 Visitor 声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类。\n\nclass ConcreteVisitor1 extends Visitor {\n    @Override\n    public void VisitConcreteElementA(ConcreteElementA elementA) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementA.getClass().getName());\n    }\n\n    @Override\n    public void VisitConcreteElementB(ConcreteElementB elementB) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementB.getClass().getName());\n    }\n}\n\nclass ConcreteVisitor2 extends Visitor {\n    @Override\n    public void VisitConcreteElementA(ConcreteElementA elementA) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementA.getClass().getName());\n    }\n\n    @Override\n    public void VisitConcreteElementB(ConcreteElementB elementB) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementB.getClass().getName());\n    }\n}\n\n\nElement : 定义一个 Accpet 操作，它以一个访问者为参数。\n\nabstract class Element {\n    public abstract void Accept(Visitor visitor);\n}\n\n\nConcreteElement : 实现 Element 声明的 Accept 操作。\n\nclass ConcreteElementA extends Element {\n    @Override\n    public void Accept(Visitor visitor) {\n        visitor.VisitConcreteElementA(this);\n    }\n}\n\nclass ConcreteElementB extends Element {\n    @Override\n    public void Accept(Visitor visitor) {\n        visitor.VisitConcreteElementB(this);\n    }\n}\n\n\nObjectStructure : 可以枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。\n\nclass ObjectStructure {\n    private List<Element> elements = new ArrayList<Element>();\n\n    public void Attach(Element element) {\n        elements.add(element);\n    }\n\n    public void Detach(Element element) {\n        elements.remove(element);\n    }\n\n    public void Accept(Visitor visitor) {\n        for (Element elem : elements) {\n            elem.Accept(visitor);\n        }\n    }\n}\n\n\n客户端\n\npublic class VisitorPattern {\n    public static void main(String[] args) {\n        ObjectStructure o = new ObjectStructure();\n        o.Attach(new ConcreteElementA());\n        o.Attach(new ConcreteElementB());\n\n        ConcreteVisitor1 v1 = new ConcreteVisitor1();\n        ConcreteVisitor2 v2 = new ConcreteVisitor2();\n\n        o.Accept(v1);\n        o.Accept(v2);\n    }\n}\n\n\n输出\n\nConcreteVisitor1 访问 ConcreteElementA\nConcreteVisitor1 访问 ConcreteElementB\nConcreteVisitor2 访问 ConcreteElementA\nConcreteVisitor2 访问 ConcreteElementB\n\n\n\n# 伪代码\n\n在本例中， 访问者模式为几何图像层次结构添加了对于 XML 文件导出功能的支持。\n\n\n\n// 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参\n// 数。\ninterface Shape is\n    method move(x, y)\n    method draw()\n    method accept(v: Visitor)\n\n// 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的\n// 访问者方法。\nclass Dot implements Shape is\n    // ...\n\n    // 注意我们正在调用的`visitDot（访问点）`方法与当前类的名称相匹配。\n    // 这样我们能让访问者知晓与其交互的元素类。\n    method accept(v: Visitor) is\n        v.visitDot(this)\n\nclass Circle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCircle(this)\n\nclass Rectangle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitRectangle(this)\n\nclass CompoundShape implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCompoundShape(this)\n\n\n// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准\n// 确辨别出与其交互的元素所属的类。\ninterface Visitor is\n    method visitDot(d: Dot)\n    method visitCircle(c: Circle)\n    method visitRectangle(r: Rectangle)\n    method visitCompoundShape(cs: CompoundShape)\n\n// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。\n//\n// 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情\n// 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问\n// 者方法。这可能会非常有帮助。\nclass XMLExportVisitor implements Visitor is\n    method visitDot(d: Dot) is\n        // 导出点（dot）的 ID 和中心坐标。\n\n    method visitCircle(c: Circle) is\n        // 导出圆（circle）的 ID 、中心坐标和半径。\n\n    method visitRectangle(r: Rectangle) is\n        // 导出长方形（rectangle）的 ID 、左上角坐标、宽和长。\n\n    method visitCompoundShape(cs: CompoundShape) is\n        // 导出图形（shape）的 ID 和其子项目的 ID 列表。\n\n\n// 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操\n// 作会将调用定位到访问者对象的相应操作上。\nclass Application is\n    field allShapes: array of Shapes\n\n    method export() is\n        exportVisitor = new XMLExportVisitor()\n\n        foreach (shape in allShapes) do\n            shape.accept(exportVisitor)\n\n\n\n# 案例\n\n使用示例： 访问者不是常用的设计模式， 因为它不仅复杂， 应用范围也比较狭窄。\n\n这里是 Java 程序库代码中该模式的一些示例：\n\n * javax.lang.model.element.AnnotationValue 和 Annotation­Value­Visitor\n * javax.lang.model.element.Element 和 Element­Visitor\n * javax.lang.model.type.TypeMirror 和 Type­Visitor\n * java.nio.file.FileVisitor 和 Simple­File­Visitor\n * javax.faces.component.visit.VisitContext 和 Visit­Callback\n\n\n# 与其他模式的关系\n\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n * 你可以使用访问者对整个组合模式树执行操作。\n * 可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之访问者模式\n\n\n# 意图\n\n访问者模式（visitor） 是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n\n# 适用场景\n\n * 如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n * 可使用访问者模式来清理辅助行为的业务逻辑。\n * 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 访问者 （visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。\n 2. 具体访问者 （concrete visitor） 会为不同的具体元素类实现相同行为的几个不同版本。\n 3. 元素 （element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。\n 4. 具体元素 （concrete element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。\n 5. 客户端 （client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。\n\n\n# 结构代码范式\n\nvisitor : 为该对象结构中 concreteelement 的每一个类声明一个 visit 操作。\n\nabstract class visitor {\n    public abstract void visitconcreteelementa(concreteelementa elementa);\n    public abstract void visitconcreteelementb(concreteelementb elementb);\n}\n\n\nconcretevisitor : 实现每个由 visitor 声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类。\n\nclass concretevisitor1 extends visitor {\n    @override\n    public void visitconcreteelementa(concreteelementa elementa) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementa.getclass().getname());\n    }\n\n    @override\n    public void visitconcreteelementb(concreteelementb elementb) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementb.getclass().getname());\n    }\n}\n\nclass concretevisitor2 extends visitor {\n    @override\n    public void visitconcreteelementa(concreteelementa elementa) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementa.getclass().getname());\n    }\n\n    @override\n    public void visitconcreteelementb(concreteelementb elementb) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementb.getclass().getname());\n    }\n}\n\n\nelement : 定义一个 accpet 操作，它以一个访问者为参数。\n\nabstract class element {\n    public abstract void accept(visitor visitor);\n}\n\n\nconcreteelement : 实现 element 声明的 accept 操作。\n\nclass concreteelementa extends element {\n    @override\n    public void accept(visitor visitor) {\n        visitor.visitconcreteelementa(this);\n    }\n}\n\nclass concreteelementb extends element {\n    @override\n    public void accept(visitor visitor) {\n        visitor.visitconcreteelementb(this);\n    }\n}\n\n\nobjectstructure : 可以枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。\n\nclass objectstructure {\n    private list<element> elements = new arraylist<element>();\n\n    public void attach(element element) {\n        elements.add(element);\n    }\n\n    public void detach(element element) {\n        elements.remove(element);\n    }\n\n    public void accept(visitor visitor) {\n        for (element elem : elements) {\n            elem.accept(visitor);\n        }\n    }\n}\n\n\n客户端\n\npublic class visitorpattern {\n    public static void main(string[] args) {\n        objectstructure o = new objectstructure();\n        o.attach(new concreteelementa());\n        o.attach(new concreteelementb());\n\n        concretevisitor1 v1 = new concretevisitor1();\n        concretevisitor2 v2 = new concretevisitor2();\n\n        o.accept(v1);\n        o.accept(v2);\n    }\n}\n\n\n输出\n\nconcretevisitor1 访问 concreteelementa\nconcretevisitor1 访问 concreteelementb\nconcretevisitor2 访问 concreteelementa\nconcretevisitor2 访问 concreteelementb\n\n\n\n# 伪代码\n\n在本例中， 访问者模式为几何图像层次结构添加了对于 xml 文件导出功能的支持。\n\n\n\n// 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参\n// 数。\ninterface shape is\n    method move(x, y)\n    method draw()\n    method accept(v: visitor)\n\n// 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的\n// 访问者方法。\nclass dot implements shape is\n    // ...\n\n    // 注意我们正在调用的`visitdot（访问点）`方法与当前类的名称相匹配。\n    // 这样我们能让访问者知晓与其交互的元素类。\n    method accept(v: visitor) is\n        v.visitdot(this)\n\nclass circle implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitcircle(this)\n\nclass rectangle implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitrectangle(this)\n\nclass compoundshape implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitcompoundshape(this)\n\n\n// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准\n// 确辨别出与其交互的元素所属的类。\ninterface visitor is\n    method visitdot(d: dot)\n    method visitcircle(c: circle)\n    method visitrectangle(r: rectangle)\n    method visitcompoundshape(cs: compoundshape)\n\n// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。\n//\n// 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情\n// 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问\n// 者方法。这可能会非常有帮助。\nclass xmlexportvisitor implements visitor is\n    method visitdot(d: dot) is\n        // 导出点（dot）的 id 和中心坐标。\n\n    method visitcircle(c: circle) is\n        // 导出圆（circle）的 id 、中心坐标和半径。\n\n    method visitrectangle(r: rectangle) is\n        // 导出长方形（rectangle）的 id 、左上角坐标、宽和长。\n\n    method visitcompoundshape(cs: compoundshape) is\n        // 导出图形（shape）的 id 和其子项目的 id 列表。\n\n\n// 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操\n// 作会将调用定位到访问者对象的相应操作上。\nclass application is\n    field allshapes: array of shapes\n\n    method export() is\n        exportvisitor = new xmlexportvisitor()\n\n        foreach (shape in allshapes) do\n            shape.accept(exportvisitor)\n\n\n\n# 案例\n\n使用示例： 访问者不是常用的设计模式， 因为它不仅复杂， 应用范围也比较狭窄。\n\n这里是 java 程序库代码中该模式的一些示例：\n\n * javax.lang.model.element.annotationvalue 和 annotation­value­visitor\n * javax.lang.model.element.element 和 element­visitor\n * javax.lang.model.type.typemirror 和 type­visitor\n * java.nio.file.filevisitor 和 simple­file­visitor\n * javax.faces.component.visit.visitcontext 和 visit­callback\n\n\n# 与其他模式的关系\n\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n * 你可以使用访问者对整个组合模式树执行操作。\n * 可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式之状态模式",frontmatter:{title:"设计模式之状态模式",date:"2015-01-23T10:29:00.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/d77095/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/24.状态模式.md",key:"v-1457855d",path:"/pages/d77095/",headers:[{level:2,title:"意图",slug:"意图",normalizedTitle:"意图",charIndex:16},{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:90},{level:2,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:254},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:261},{level:3,title:"结构代码范式",slug:"结构代码范式",normalizedTitle:"结构代码范式",charIndex:642},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:1777},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:4743},{level:2,title:"与其他模式的关系",slug:"与其他模式的关系",normalizedTitle:"与其他模式的关系",charIndex:4961},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5247}],headersStr:"意图 适用场景 结构 结构说明 结构代码范式 伪代码 案例 与其他模式的关系 参考资料",content:'# 设计模式之状态模式\n\n\n# 意图\n\n状态模式（State） 是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n\n\n# 适用场景\n\n * 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n * 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n * 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。\n 2. 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。\n 3. 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。\n    * 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。\n 4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。\n\n\n# 结构代码范式\n\nState : 定义一个接口以封装与 Context 的一个特定状态相关的行为。\n\nabstract class State {\n    public abstract void Handle(Context context);\n}\n\n\nConcreteState : 每一个子类实现一个与 Context 的一个状态相关的行为。\n\nclass ConcreteStateA extends State {\n    @Override\n    public void Handle(Context context) {\n        context.SetState(new ConcreteStateB());\n    }\n}\n\nclass ConcreteStateB extends State {\n    @Override\n    public void Handle(Context context) {\n        context.SetState(new ConcreteStateA());\n    }\n}\n\n\nContext : 维护一个 ConcreteState 子类的实例，这个实例定义当前的状态。\n\nclass Context {\n    private State state;\n    public Context(State state) {\n        this.state = state;\n    }\n\n    public void SetState(State state) {\n        this.state = state;\n        System.out.println("当前状态：" + state.getClass().getName());\n    }\n    public State GetState() {\n        return state;\n    }\n\n    public void Request() {\n        state.Handle(this);\n    }\n}\n\n\n\n客户端\n\npublic class StatePattern {\n    public static void main(String[] args) {\n        Context c = new Context(new ConcreteStateA());\n        c.Request();\n        c.Request();\n    }\n}\n\n\n输出\n\n当前状态：ConcreteStateB\n当前状态：ConcreteStateA\n\n\n\n# 伪代码\n\n在本例中， 状态模式将根据当前回放状态， 让媒体播放器中的相同控件完成不同的行为。\n\n\n\n播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象， 以此改变播放器对于用户互动所作出的反应。\n\n// 音频播放器（Audio­Player）类即为上下文。它还会维护指向状态类实例的引用，\n// 该状态类则用于表示音频播放器当前的状态。\nclass AudioPlayer is\n    field state: State\n    field UI, volume, playlist, currentSong\n\n    constructor AudioPlayer() is\n        this.state = new ReadyState(this)\n\n        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不\n        // 同的方式处理输入，其结果自然将依赖于当前所处的状态。\n        UI = new UserInterface()\n        UI.lockButton.onClick(this.clickLock)\n        UI.playButton.onClick(this.clickPlay)\n        UI.nextButton.onClick(this.clickNext)\n        UI.prevButton.onClick(this.clickPrevious)\n\n    // 其他对象必须能切换音频播放器当前所处的状态。\n    method changeState(state: State) is\n        this.state = state\n\n    // UI 方法会将执行工作委派给当前状态。\n    method clickLock() is\n        state.clickLock()\n    method clickPlay() is\n        state.clickPlay()\n    method clickNext() is\n        state.clickNext()\n    method clickPrevious() is\n        state.clickPrevious()\n\n    // 状态可调用上下文的一些服务方法。\n    method startPlayback() is\n        // ...\n    method stopPlayback() is\n        // ...\n    method nextSong() is\n        // ...\n    method previousSong() is\n        // ...\n    method fastForward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n\n// 所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相\n// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。\nabstract class State is\n    protected field player: AudioPlayer\n\n    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的\n    // 上下文数据。\n    constructor State(player) is\n        this.player = player\n\n    abstract method clickLock()\n    abstract method clickPlay()\n    abstract method clickNext()\n    abstract method clickPrevious()\n\n\n// 具体状态会实现与上下文状态相关的多种行为。\nclass LockedState extends State is\n\n    // 当你解锁一个锁定的播放器时，它可能处于两种状态之一。\n    method clickLock() is\n        if (player.playing)\n            player.changeState(new PlayingState(player))\n        else\n            player.changeState(new ReadyState(player))\n\n    method clickPlay() is\n        // 已锁定，什么也不做。\n\n    method clickNext() is\n        // 已锁定，什么也不做。\n\n    method clickPrevious() is\n        // 已锁定，什么也不做。\n\n\n// 它们还可在上下文中触发状态转换。\nclass ReadyState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.startPlayback()\n        player.changeState(new PlayingState(player))\n\n    method clickNext() is\n        player.nextSong()\n\n    method clickPrevious() is\n        player.previousSong()\n\n\nclass PlayingState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.stopPlayback()\n        player.changeState(new ReadyState(player))\n\n    method clickNext() is\n        if (event.doubleclick)\n            player.nextSong()\n        else\n            player.fastForward(5)\n\n    method clickPrevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n\n\n\n# 案例\n\n使用示例： 在 Java 语言中， 状态模式通常被用于将基于 switch语句的大型状态机转换为对象。\n\n这里是核心 Java 程序库中一些状态模式的示例：\n\n * javax.faces.lifecycle.LifeCycle#execute() （由 Faces­Servlet控制： 行为依赖于当前 JSF 生命周期的阶段 （状态））\n\n识别方法： 状态模式可通过受外部控制且能根据对象状态改变行为的方法来识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之状态模式\n\n\n# 意图\n\n状态模式（state） 是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n\n\n# 适用场景\n\n * 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n * 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n * 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n\n\n# 结构\n\n\n# 结构说明\n\n\n\n 1. 上下文 （context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。\n 2. 状态 （state） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。\n 3. 具体状态 （concrete states） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。\n    * 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。\n 4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。\n\n\n# 结构代码范式\n\nstate : 定义一个接口以封装与 context 的一个特定状态相关的行为。\n\nabstract class state {\n    public abstract void handle(context context);\n}\n\n\nconcretestate : 每一个子类实现一个与 context 的一个状态相关的行为。\n\nclass concretestatea extends state {\n    @override\n    public void handle(context context) {\n        context.setstate(new concretestateb());\n    }\n}\n\nclass concretestateb extends state {\n    @override\n    public void handle(context context) {\n        context.setstate(new concretestatea());\n    }\n}\n\n\ncontext : 维护一个 concretestate 子类的实例，这个实例定义当前的状态。\n\nclass context {\n    private state state;\n    public context(state state) {\n        this.state = state;\n    }\n\n    public void setstate(state state) {\n        this.state = state;\n        system.out.println("当前状态：" + state.getclass().getname());\n    }\n    public state getstate() {\n        return state;\n    }\n\n    public void request() {\n        state.handle(this);\n    }\n}\n\n\n\n客户端\n\npublic class statepattern {\n    public static void main(string[] args) {\n        context c = new context(new concretestatea());\n        c.request();\n        c.request();\n    }\n}\n\n\n输出\n\n当前状态：concretestateb\n当前状态：concretestatea\n\n\n\n# 伪代码\n\n在本例中， 状态模式将根据当前回放状态， 让媒体播放器中的相同控件完成不同的行为。\n\n\n\n播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象， 以此改变播放器对于用户互动所作出的反应。\n\n// 音频播放器（audio­player）类即为上下文。它还会维护指向状态类实例的引用，\n// 该状态类则用于表示音频播放器当前的状态。\nclass audioplayer is\n    field state: state\n    field ui, volume, playlist, currentsong\n\n    constructor audioplayer() is\n        this.state = new readystate(this)\n\n        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不\n        // 同的方式处理输入，其结果自然将依赖于当前所处的状态。\n        ui = new userinterface()\n        ui.lockbutton.onclick(this.clicklock)\n        ui.playbutton.onclick(this.clickplay)\n        ui.nextbutton.onclick(this.clicknext)\n        ui.prevbutton.onclick(this.clickprevious)\n\n    // 其他对象必须能切换音频播放器当前所处的状态。\n    method changestate(state: state) is\n        this.state = state\n\n    // ui 方法会将执行工作委派给当前状态。\n    method clicklock() is\n        state.clicklock()\n    method clickplay() is\n        state.clickplay()\n    method clicknext() is\n        state.clicknext()\n    method clickprevious() is\n        state.clickprevious()\n\n    // 状态可调用上下文的一些服务方法。\n    method startplayback() is\n        // ...\n    method stopplayback() is\n        // ...\n    method nextsong() is\n        // ...\n    method previoussong() is\n        // ...\n    method fastforward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n\n// 所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相\n// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。\nabstract class state is\n    protected field player: audioplayer\n\n    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的\n    // 上下文数据。\n    constructor state(player) is\n        this.player = player\n\n    abstract method clicklock()\n    abstract method clickplay()\n    abstract method clicknext()\n    abstract method clickprevious()\n\n\n// 具体状态会实现与上下文状态相关的多种行为。\nclass lockedstate extends state is\n\n    // 当你解锁一个锁定的播放器时，它可能处于两种状态之一。\n    method clicklock() is\n        if (player.playing)\n            player.changestate(new playingstate(player))\n        else\n            player.changestate(new readystate(player))\n\n    method clickplay() is\n        // 已锁定，什么也不做。\n\n    method clicknext() is\n        // 已锁定，什么也不做。\n\n    method clickprevious() is\n        // 已锁定，什么也不做。\n\n\n// 它们还可在上下文中触发状态转换。\nclass readystate extends state is\n    method clicklock() is\n        player.changestate(new lockedstate(player))\n\n    method clickplay() is\n        player.startplayback()\n        player.changestate(new playingstate(player))\n\n    method clicknext() is\n        player.nextsong()\n\n    method clickprevious() is\n        player.previoussong()\n\n\nclass playingstate extends state is\n    method clicklock() is\n        player.changestate(new lockedstate(player))\n\n    method clickplay() is\n        player.stopplayback()\n        player.changestate(new readystate(player))\n\n    method clicknext() is\n        if (event.doubleclick)\n            player.nextsong()\n        else\n            player.fastforward(5)\n\n    method clickprevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n\n\n\n# 案例\n\n使用示例： 在 java 语言中， 状态模式通常被用于将基于 switch语句的大型状态机转换为对象。\n\n这里是核心 java 程序库中一些状态模式的示例：\n\n * javax.faces.lifecycle.lifecycle#execute() （由 faces­servlet控制： 行为依赖于当前 jsf 生命周期的阶段 （状态））\n\n识别方法： 状态模式可通过受外部控制且能根据对象状态改变行为的方法来识别。\n\n\n# 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"面向对象原则",frontmatter:{title:"面向对象原则",date:"2021-05-19T09:49:05.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/9703b1/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99.html",relativePath:"03.设计/02.设计模式/25.面向对象原则.md",key:"v-3f96c8d8",path:"/pages/9703b1/",headers:[{level:2,title:"单一职责原则",slug:"单一职责原则",normalizedTitle:"单一职责原则",charIndex:17},{level:2,title:"开放-封闭原则",slug:"开放-封闭原则",normalizedTitle:"开放-封闭原则",charIndex:107},{level:2,title:"里氏替换原则",slug:"里氏替换原则",normalizedTitle:"里氏替换原则",charIndex:199},{level:2,title:"依赖倒置原则",slug:"依赖倒置原则",normalizedTitle:"依赖倒置原则",charIndex:259},{level:2,title:"接口隔离原则",slug:"接口隔离原则",normalizedTitle:"接口隔离原则",charIndex:414},{level:2,title:"迪米特原则",slug:"迪米特原则",normalizedTitle:"迪米特原则",charIndex:547},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:706}],headersStr:"单一职责原则 开放-封闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特原则 参考资料",content:"# 面向对象设计六大原则\n\n\n# 单一职责原则\n\n单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。\n\n简单点说，一个类，最好只负责一件事。\n\n\n# 开放-封闭原则\n\n开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。\n\n对于扩展是开放的；对于更改是封闭的。\n\n\n# 里氏替换原则\n\n里氏替换原则（Liskov Substitution Principle），子类可以替换父类。\n\n\n# 依赖倒置原则\n\n依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n关键点：\n\n * 高层模块不应该依赖低层模块，两者都应该依赖其抽象\n * 抽象不应该依赖细节\n * 细节应该依赖抽象\n\n\n# 接口隔离原则\n\n接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n * 客户端不应依赖它不需要的接口\n * 类间的依赖关系应该建立在最小的接口上\n\n\n# 迪米特原则\n\n迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。\n\n\n# 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》",normalizedContent:"# 面向对象设计六大原则\n\n\n# 单一职责原则\n\n单一职责原则（single responsibility principle），应该有且仅有一个原因引起类的变更。\n\n简单点说，一个类，最好只负责一件事。\n\n\n# 开放-封闭原则\n\n开放-封闭原则（open close principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。\n\n对于扩展是开放的；对于更改是封闭的。\n\n\n# 里氏替换原则\n\n里氏替换原则（liskov substitution principle），子类可以替换父类。\n\n\n# 依赖倒置原则\n\n依赖倒置原则（dependency inversion principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n关键点：\n\n * 高层模块不应该依赖低层模块，两者都应该依赖其抽象\n * 抽象不应该依赖细节\n * 细节应该依赖抽象\n\n\n# 接口隔离原则\n\n接口隔离原则（interface segregation principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n * 客户端不应依赖它不需要的接口\n * 类间的依赖关系应该建立在最小的接口上\n\n\n# 迪米特原则\n\n迪米特原则（least knowledge principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。\n\n\n# 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计模式",frontmatter:{title:"设计模式",date:"2020-08-10T10:59:18.000Z",categories:["设计","设计模式"],tags:["设计","设计模式"],permalink:"/pages/81b0f2/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",relativePath:"03.设计/02.设计模式/README.md",key:"v-0893d5c3",path:"/pages/81b0f2/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:37},{level:3,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:57},{level:3,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:249},{level:3,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:431},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:705},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:759}],headersStr:"📖 内容 创建型模式 结构型模式 行为型模式 📚 资料 🚪 传送",content:"# 设计模式\n\n> 设计模式是软件设计中常见问题的典型解决方案。\n\n\n# 📖 内容\n\n**面向对象原则\n\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n * 单例模式 (Singleton)\n\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 组合模式 (Composite)\n * 装饰模式 (Decorator)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)**\n\n\n# 📚 资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 设计模式\n\n> 设计模式是软件设计中常见问题的典型解决方案。\n\n\n# 📖 内容\n\n**面向对象原则\n\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n * 单例模式 (singleton)\n\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 组合模式 (composite)\n * 装饰模式 (decorator)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)**\n\n\n# 📚 资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码的坏味道和重构",frontmatter:{title:"代码的坏味道和重构",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],permalink:"/pages/d86872/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/01.%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84.html",relativePath:"03.设计/03.重构/01.代码的坏味道和重构.md",key:"v-79c78335",path:"/pages/d86872/",headers:[{level:2,title:"症与药",slug:"症与药",normalizedTitle:"症与药",charIndex:105},{level:3,title:"对代码的坏味道的思考",slug:"对代码的坏味道的思考",normalizedTitle:"对代码的坏味道的思考",charIndex:113},{level:3,title:"重构的原则",slug:"重构的原则",normalizedTitle:"重构的原则",charIndex:727},{level:4,title:"何谓重构(What)",slug:"何谓重构-what",normalizedTitle:"何谓重构(what)",charIndex:779},{level:4,title:"为何重构(Why)",slug:"为何重构-why",normalizedTitle:"为何重构(why)",charIndex:978},{level:4,title:"何时重构(When)",slug:"何时重构-when",normalizedTitle:"何时重构(when)",charIndex:1086},{level:4,title:"如何重构(How)",slug:"如何重构-how",normalizedTitle:"如何重构(how)",charIndex:2217},{level:2,title:"代码的坏味道",slug:"代码的坏味道",normalizedTitle:"代码的坏味道",charIndex:114},{level:3,title:"代码坏味道之代码臃肿",slug:"代码坏味道之代码臃肿",normalizedTitle:"代码坏味道之代码臃肿",charIndex:2783},{level:3,title:"代码坏味道之滥用面向对象",slug:"代码坏味道之滥用面向对象",normalizedTitle:"代码坏味道之滥用面向对象",charIndex:2953},{level:3,title:"代码坏味道之变革的障碍",slug:"代码坏味道之变革的障碍",normalizedTitle:"代码坏味道之变革的障碍",charIndex:3079},{level:3,title:"代码坏味道之非必要的",slug:"代码坏味道之非必要的",normalizedTitle:"代码坏味道之非必要的",charIndex:3204},{level:3,title:"代码坏味道之耦合",slug:"代码坏味道之耦合",normalizedTitle:"代码坏味道之耦合",charIndex:3326},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:3420},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3514}],headersStr:"症与药 对代码的坏味道的思考 重构的原则 何谓重构(What) 为何重构(Why) 何时重构(When) 如何重构(How) 代码的坏味道 代码坏味道之代码臃肿 代码坏味道之滥用面向对象 代码坏味道之变革的障碍 代码坏味道之非必要的 代码坏味道之耦合 扩展阅读 参考资料",content:"第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。\n\n\n# 症与药\n\n\n# 对代码的坏味道的思考\n\n“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。\n\n病，就是不健康。\n\n人有病，可以通过打针、吃药、做手术来进行治疗。\n\n如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。\n\n个人认为，在重构这件事上，也可以应用治病的道理：\n\n * 防患于未然。 —— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：防患于未然。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。\n\n * 小病不医，易得大病。 —— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。\n\n * 对症下药。 —— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，瞎改还不如不改。\n\n * 忌猛药 —— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。\n\n\n# 重构的原则\n\n前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。\n\n# 何谓重构(What)\n\n重构（Refactoring） 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。\n\n个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。\n\n重构的目的是为了提高代码的质量和性能。\n\n注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。\n\n# 为何重构(Why)\n\n翻翻书，上网搜一下，谈到重构的理由大体相同：\n\n * 重构改进软件设计\n * 重构使软件更容易理解\n * 重构帮助找到 bug\n * 重构提高编程速度\n\n总之就是，重构可以提高代码质量。\n\n# 何时重构(When)\n\n关于何时重构，我先引用一下 重构并非难在如何做，而是难在何时开始做 一文的观点。\n\n> 对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，从来就不是一个可接受的选项，“边开飞机边换引擎”才是这种公司想要的。\n\n我们不妨来衡量一下重构的成本和收益。\n\n * 重构的成本\n   \n   重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。\n   \n   还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。\n   \n   但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。\n\n * 重构的收益\n   \n   重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。\n\n * 重构的合适时机\n   \n   从以上来看，重构实在是个吃力不讨好的事情。\n   \n   于是，很多人屈服于万恶的 KPI 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。\n   \n   但是，重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。\n   \n   《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。\n   \n   我认为，其思想就是指：重构应该是在开发过程中实时的、渐进的演化过程。\n\n * 重构的不恰当时机\n   \n   但是，这里我也要强调一下：不是所有软件开发过程都一定要重构。\n   \n   较能凸显重构价值的场景是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。\n   \n   与之相反，有一些场景的重构价值就很小：\n   \n   * 代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。\n   * 代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。\n   * 重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。\n\n# 如何重构(How)\n\n重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：\n\n * 系统架构、集群架构、框架、服务、数据库：这个层面的重构属于战略级重构。现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。\n * 组件、模块、接口：这个层面的重构属于战术级重构。组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。\n * 类、接口、函数、字段等：这个层面的重构属于战法级重构。《重构》一书提到了 代码的坏味道 以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。\n\n前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。\n\n此处为分割线。下面是代码的坏味道系列。。。\n\n\n# 代码的坏味道\n\n《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。\n\n\n\n\n# 代码坏味道之代码臃肿\n\n> 代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n * 过长函数\n * 过大的类\n * 基本类型偏执\n * 过长参数列\n * 数据泥团\n\n\n# 代码坏味道之滥用面向对象\n\n> 滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n * switch 声明\n * 临时字段\n * 被拒绝的馈赠\n * 异曲同工的类\n\n\n# 代码坏味道之变革的障碍\n\n> 变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n * 发散式变化\n * 霰弹式修改\n * 平行继承体系\n\n\n# 代码坏味道之非必要的\n\n> 非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n * 过多的注释\n * 重复代码\n * 冗余类\n * 纯稚的数据类\n * 夸夸其谈未来性\n\n\n# 代码坏味道之耦合\n\n> 耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。\n\n * 依恋情结\n * 狎昵关系\n * 过度耦合的消息链\n * 中间人\n * 不完美的库类\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",normalizedContent:"第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。\n\n\n# 症与药\n\n\n# 对代码的坏味道的思考\n\n“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。\n\n病，就是不健康。\n\n人有病，可以通过打针、吃药、做手术来进行治疗。\n\n如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。\n\n个人认为，在重构这件事上，也可以应用治病的道理：\n\n * 防患于未然。 —— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：防患于未然。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。\n\n * 小病不医，易得大病。 —— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。\n\n * 对症下药。 —— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，瞎改还不如不改。\n\n * 忌猛药 —— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。\n\n\n# 重构的原则\n\n前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。\n\n# 何谓重构(what)\n\n重构（refactoring） 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。\n\n个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。\n\n重构的目的是为了提高代码的质量和性能。\n\n注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。\n\n# 为何重构(why)\n\n翻翻书，上网搜一下，谈到重构的理由大体相同：\n\n * 重构改进软件设计\n * 重构使软件更容易理解\n * 重构帮助找到 bug\n * 重构提高编程速度\n\n总之就是，重构可以提高代码质量。\n\n# 何时重构(when)\n\n关于何时重构，我先引用一下 重构并非难在如何做，而是难在何时开始做 一文的观点。\n\n> 对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，从来就不是一个可接受的选项，“边开飞机边换引擎”才是这种公司想要的。\n\n我们不妨来衡量一下重构的成本和收益。\n\n * 重构的成本\n   \n   重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。\n   \n   还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。\n   \n   但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。\n\n * 重构的收益\n   \n   重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。\n\n * 重构的合适时机\n   \n   从以上来看，重构实在是个吃力不讨好的事情。\n   \n   于是，很多人屈服于万恶的 kpi 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。\n   \n   但是，重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。\n   \n   《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。\n   \n   我认为，其思想就是指：重构应该是在开发过程中实时的、渐进的演化过程。\n\n * 重构的不恰当时机\n   \n   但是，这里我也要强调一下：不是所有软件开发过程都一定要重构。\n   \n   较能凸显重构价值的场景是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。\n   \n   与之相反，有一些场景的重构价值就很小：\n   \n   * 代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。\n   * 代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。\n   * 重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。\n\n# 如何重构(how)\n\n重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：\n\n * 系统架构、集群架构、框架、服务、数据库：这个层面的重构属于战略级重构。现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。\n * 组件、模块、接口：这个层面的重构属于战术级重构。组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。\n * 类、接口、函数、字段等：这个层面的重构属于战法级重构。《重构》一书提到了 代码的坏味道 以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。\n\n前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。\n\n此处为分割线。下面是代码的坏味道系列。。。\n\n\n# 代码的坏味道\n\n《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。\n\n\n\n\n# 代码坏味道之代码臃肿\n\n> 代码臃肿(bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n * 过长函数\n * 过大的类\n * 基本类型偏执\n * 过长参数列\n * 数据泥团\n\n\n# 代码坏味道之滥用面向对象\n\n> 滥用面向对象(object-orientation abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n * switch 声明\n * 临时字段\n * 被拒绝的馈赠\n * 异曲同工的类\n\n\n# 代码坏味道之变革的障碍\n\n> 变革的障碍(change preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n * 发散式变化\n * 霰弹式修改\n * 平行继承体系\n\n\n# 代码坏味道之非必要的\n\n> 非必要的(dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n * 过多的注释\n * 重复代码\n * 冗余类\n * 纯稚的数据类\n * 夸夸其谈未来性\n\n\n# 代码坏味道之耦合\n\n> 耦合(couplers)这组坏味道意味着：不同类之间过度耦合。\n\n * 依恋情结\n * 狎昵关系\n * 过度耦合的消息链\n * 中间人\n * 不完美的库类\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码坏味道之代码臃肿",frontmatter:{title:"代码坏味道之代码臃肿",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],permalink:"/pages/49d5ae/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/02.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.html",relativePath:"03.设计/03.重构/02.代码坏味道之代码臃肿.md",key:"v-c5ef3042",path:"/pages/49d5ae/",headers:[{level:2,title:"基本类型偏执",slug:"基本类型偏执",normalizedTitle:"基本类型偏执",charIndex:176},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:345},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:493},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:1119},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:1243},{level:4,title:"以类取代类型码(Replace Type Code with Class)",slug:"以类取代类型码-replace-type-code-with-class",normalizedTitle:"以类取代类型码(replace type code with class)",charIndex:715},{level:4,title:"引入参数对象(Introduce Parameter Object)",slug:"引入参数对象-introduce-parameter-object",normalizedTitle:"引入参数对象(introduce parameter object)",charIndex:784},{level:4,title:"保持对象完整(Preserve Whole Object)",slug:"保持对象完整-preserve-whole-object",normalizedTitle:"保持对象完整(preserve whole object)",charIndex:821},{level:4,title:"以子类取代类型码(Replace Type Code with Subclass)",slug:"以子类取代类型码-replace-type-code-with-subclass",normalizedTitle:"以子类取代类型码(replace type code with subclass)",charIndex:951},{level:4,title:"以状态/策略模式取代类型码(Replace Type Code with State/Strategy)",slug:"以状态-策略模式取代类型码-replace-type-code-with-state-strategy",normalizedTitle:"以状态/策略模式取代类型码(replace type code with state/strategy)",charIndex:995},{level:4,title:"以对象取代数组(Replace Array with Object)",slug:"以对象取代数组-replace-array-with-object",normalizedTitle:"以对象取代数组(replace array with object)",charIndex:1078},{level:2,title:"数据泥团",slug:"数据泥团",normalizedTitle:"数据泥团",charIndex:2151},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:345},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:493},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:1119},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:2685},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:1243},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:2401},{level:4,title:"引入参数对象(Introduce Parameter Object)",slug:"引入参数对象-introduce-parameter-object-2",normalizedTitle:"引入参数对象(introduce parameter object)",charIndex:784},{level:4,title:"保持对象完整(Preserve Whole Object)",slug:"保持对象完整-preserve-whole-object-2",normalizedTitle:"保持对象完整(preserve whole object)",charIndex:821},{level:2,title:"过大的类",slug:"过大的类",normalizedTitle:"过大的类",charIndex:3192},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:345},{level:3,title:"解决方法",slug:"解决方法-3",normalizedTitle:"解决方法",charIndex:493},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:1119},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:1243},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class-2",normalizedTitle:"提炼类(extract class)",charIndex:2401},{level:4,title:"提炼子类(Extract Subclass)",slug:"提炼子类-extract-subclass",normalizedTitle:"提炼子类(extract subclass)",charIndex:3479},{level:4,title:"提炼接口(Extract Interface)",slug:"提炼接口-extract-interface",normalizedTitle:"提炼接口(extract interface)",charIndex:3530},{level:4,title:"复制被监视数据(Duplicate Observed Data)",slug:"复制被监视数据-duplicate-observed-data",normalizedTitle:"复制被监视数据(duplicate observed data)",charIndex:3623},{level:2,title:"过长函数",slug:"过长函数",normalizedTitle:"过长函数",charIndex:3282},{level:3,title:"问题的原因",slug:"问题的原因",normalizedTitle:"问题的原因",charIndex:4227},{level:3,title:"解决函数",slug:"解决函数",normalizedTitle:"解决函数",charIndex:4432},{level:3,title:"收益",slug:"收益-4",normalizedTitle:"收益",charIndex:1119},{level:3,title:"性能",slug:"性能",normalizedTitle:"性能",charIndex:5085},{level:3,title:"重构方法说明",slug:"重构方法说明-4",normalizedTitle:"重构方法说明",charIndex:1243},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method",normalizedTitle:"提炼函数(extract method)",charIndex:4641},{level:4,title:"以查询取代临时变量(Replace Temp with Query)",slug:"以查询取代临时变量-replace-temp-with-query",normalizedTitle:"以查询取代临时变量(replace temp with query)",charIndex:4687},{level:4,title:"引入参数对象(Introduce Parameter Object)",slug:"引入参数对象-introduce-parameter-object-3",normalizedTitle:"引入参数对象(introduce parameter object)",charIndex:784},{level:4,title:"保持对象完整(Preserve Whole Object)",slug:"保持对象完整-preserve-whole-object-3",normalizedTitle:"保持对象完整(preserve whole object)",charIndex:821},{level:4,title:"以函数对象取代函数(Replace Method with Method Object)",slug:"以函数对象取代函数-replace-method-with-method-object",normalizedTitle:"以函数对象取代函数(replace method with method object)",charIndex:4810},{level:4,title:"分解条件表达式(Decompose Conditional)",slug:"分解条件表达式-decompose-conditional",normalizedTitle:"分解条件表达式(decompose conditional)",charIndex:4908},{level:2,title:"过长参数列",slug:"过长参数列",normalizedTitle:"过长参数列",charIndex:7586},{level:3,title:"问题原因",slug:"问题原因-4",normalizedTitle:"问题原因",charIndex:345},{level:3,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:7905},{level:3,title:"收益",slug:"收益-5",normalizedTitle:"收益",charIndex:1119},{level:3,title:"何时忽略",slug:"何时忽略-2",normalizedTitle:"何时忽略",charIndex:2685},{level:3,title:"重构方法说明",slug:"重构方法说明-5",normalizedTitle:"重构方法说明",charIndex:1243},{level:4,title:"以函数取代参数(Replace Parameter with Methods)",slug:"以函数取代参数-replace-parameter-with-methods",normalizedTitle:"以函数取代参数(replace parameter with methods)",charIndex:7948},{level:4,title:"保持对象完整(Preserve Whole Object)",slug:"保持对象完整-preserve-whole-object-4",normalizedTitle:"保持对象完整(preserve whole object)",charIndex:821},{level:4,title:"引入参数对象(Introduce Parameter Object)",slug:"引入参数对象-introduce-parameter-object-4",normalizedTitle:"引入参数对象(introduce parameter object)",charIndex:784},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:9113},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9207}],headersStr:"基本类型偏执 问题原因 解决方法 收益 重构方法说明 以类取代类型码(Replace Type Code with Class) 引入参数对象(Introduce Parameter Object) 保持对象完整(Preserve Whole Object) 以子类取代类型码(Replace Type Code with Subclass) 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 以对象取代数组(Replace Array with Object) 数据泥团 问题原因 解决方法 收益 何时忽略 重构方法说明 提炼类(Extract Class) 引入参数对象(Introduce Parameter Object) 保持对象完整(Preserve Whole Object) 过大的类 问题原因 解决方法 收益 重构方法说明 提炼类(Extract Class) 提炼子类(Extract Subclass) 提炼接口(Extract Interface) 复制被监视数据(Duplicate Observed Data) 过长函数 问题的原因 解决函数 收益 性能 重构方法说明 提炼函数(Extract Method) 以查询取代临时变量(Replace Temp with Query) 引入参数对象(Introduce Parameter Object) 保持对象完整(Preserve Whole Object) 以函数对象取代函数(Replace Method with Method Object) 分解条件表达式(Decompose Conditional) 过长参数列 问题原因 解决方案 收益 何时忽略 重构方法说明 以函数取代参数(Replace Parameter with Methods) 保持对象完整(Preserve Whole Object) 引入参数对象(Introduce Parameter Object) 扩展阅读 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/bloaters\n> \n> 代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n\n# 基本类型偏执\n\n> 基本类型偏执(Primitive Obsession)\n> \n>  * 使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。\n>  * 使用常量编码信息（例如一个用于引用管理员权限的常量USER_ADMIN_ROLE = 1 ）。\n>  * 使用字符串常量作为字段名在数组中使用。\n\n\n\n\n# 问题原因\n\n类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。\n\n基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。\n\n还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。\n\n\n# 解决方法\n\n\n\n大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。\n\n基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。\n\n * 如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(Replace Type Code with Class) 。\n * 如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。\n * 如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(Replace Type Code with Class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 加以处理。\n * 如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(Replace Array with Object) 。\n\n\n# 收益\n\n * 多亏了使用对象替代基本数据类型，使得代码变得更加灵活。\n * 代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。\n * 更容易发现重复代码。\n\n\n\n\n# 重构方法说明\n\n# 以类取代类型码(Replace Type Code with Class)\n\n问题\n\n类之中有一个数值类型码，但它并不影响类的行为。\n\n\n\n解决\n\n以一个新的类替换该数值类型码。\n\n\n\n# 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 以子类取代类型码(Replace Type Code with Subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 以对象取代数组(Replace Array with Object)\n\n问题\n\n你有一个数组，其中的元素各自代表不同的东西。\n\nString[] row = new String[3];\nrow[0] = "Liverpool";\nrow[1] = "15";\n\n\n解决\n\n以对象替换数组。对于数组中的每个元素，以一个字段来表示。\n\nPerformance row = new Performance();\nrow.setName("Liverpool");\nrow.setWins("15");\n\n\n\n# 数据泥团\n\n> 数据泥团(Data Clumps)\n> \n> 有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。\n\n\n\n\n# 问题原因\n\n通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。\n\n有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。\n\n\n# 解决方法\n\n * 首先找出这些数据以字段形式出现的地方，运用 提炼类(Extract Class) 将它们提炼到一个独立对象中。\n * 如果数据泥团在函数的参数列中出现，运用 引入参数对象(Introduce Parameter Object) 将它们组织成一个类。\n * 如果数据泥团的部分数据出现在其他函数中，考虑运用 保持对象完整(Preserve Whole Object) 将整个数据对象传入到函数中。\n * 检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。\n\n\n# 收益\n\n * 提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。\n * 减少代码量。\n\n\n\n\n# 何时忽略\n\n * 有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。\n\n\n# 重构方法说明\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n\n# 过大的类\n\n> 过大的类(Large Class)\n> \n> 一个类含有过多字段、函数、代码行。\n\n\n\n\n# 问题原因\n\n类通常一开始很小，但是随着程序的增长而逐渐膨胀。\n\n类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。\n\n\n# 解决方法\n\n设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。\n\n\n\n * 如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 提炼类(Extract Class)。\n * 如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 提炼子类(Extract Subclass)。\n * 如果有必要为客户端提供一组操作和行为，可以使用 提炼接口(Extract Interface)。\n * 如果你的过大类是个 GUI 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 复制被监视数据(Duplicate Observed Data) 可以告诉你怎么做。\n\n\n# 收益\n\n * 重构过大的类可以使程序员不必记住一个类中大量的属性。\n * 在大多数情况下，分割过大的类可以避免代码和功能的重复。\n\n\n\n\n# 重构方法说明\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 提炼子类(Extract Subclass)\n\n问题\n\n一个类中有些特性仅用于特定场景。\n\n\n\n解决\n\n创建一个子类，并将用于特殊场景的特性置入其中。\n\n\n\n# 提炼接口(Extract Interface)\n\n问题\n\n多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。\n\n\n\n解决\n\n移动相同的部分函数到接口中。\n\n\n\n# 复制被监视数据(Duplicate Observed Data)\n\n问题\n\n如果存储在类中的数据是负责 GUI 的。\n\n\n\n解决\n\n一个比较好的方法是将负责 GUI 的数据放入一个独立的类，以确保 GUI 数据与域类之间的连接和同步。\n\n\n\n\n# 过长函数\n\n> 过长函数(Long Method)\n> \n> 一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。 函数中的代码行数原则上不要超过 100 行。\n\n\n\n\n# 问题的原因\n\n通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。\n\n\n# 解决函数\n\n一个很好的技巧是：寻找注释。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。\n\n\n\n * 为了给一个函数瘦身，可以使用 提炼函数(Extract Method)。\n * 如果局部变量和参数干扰提炼函数，可以使用 以查询取代临时变量(Replace Temp with Query)，引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。\n * 如果前面两条没有帮助，可以通过 以函数对象取代函数(Replace Method with Method Object) 尝试移动整个函数到一个独立的对象中。\n * 条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 分解条件表达式(Decompose Conditional) 。至于循环，应该使用 提炼函数(Extract Method) 将循环和其内的代码提炼到独立函数中。\n\n\n# 收益\n\n * 在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。\n * 此外，过长函数中往往含有难以发现的重复代码。\n\n\n\n\n# 性能\n\n是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。 此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。\n\n\n# 重构方法说明\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 以查询取代临时变量(Replace Temp with Query)\n\n问题\n\n将表达式的结果放在局部变量中，然后在代码中使用。\n\ndouble calculateTotal() {\n  double basePrice = quantity * itemPrice;\n  if (basePrice > 1000) {\n    return basePrice * 0.95;\n  }\n  else {\n    return basePrice * 0.98;\n  }\n}\n\n\n解决\n\n将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。\n\ndouble calculateTotal() {\n  if (basePrice() > 1000) {\n    return basePrice() * 0.95;\n  }\n  else {\n    return basePrice() * 0.98;\n  }\n}\ndouble basePrice() {\n  return quantity * itemPrice;\n}\n\n\n# 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 以函数对象取代函数(Replace Method with Method Object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。\n\nclass Order {\n  //...\n  public double price() {\n    double primaryBasePrice;\n    double secondaryBasePrice;\n    double tertiaryBasePrice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass Order {\n  //...\n  public double price() {\n    return new PriceCalculator(this).compute();\n  }\n}\n\nclass PriceCalculator {\n  private double primaryBasePrice;\n  private double secondaryBasePrice;\n  private double tertiaryBasePrice;\n\n  public PriceCalculator(Order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 分解条件表达式(Decompose Conditional)\n\n问题\n\n你有复杂的条件表达式。\n\nif (date.before(SUMMER_START) || date.after(SUMMER_END)) {\n  charge = quantity * winterRate + winterServiceCharge;\n}\nelse {\n  charge = quantity * summerRate;\n}\n\n\n解决\n\n根据条件分支将整个条件表达式分解成几个函数。\n\nif (notSummer(date)) {\n  charge = winterCharge(quantity);\n}\nelse {\n  charge = summerCharge(quantity);\n}\n\n\n\n# 过长参数列\n\n> 过长参数列(Long Parameter List)\n> \n> 一个函数有超过 3、4 个入参。\n\n\n\n\n# 问题原因\n\n过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。\n\n过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。\n\n太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。\n\n\n# 解决方案\n\n\n\n * 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 以函数取代参数(Replace Parameter with Methods) 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。\n * 你还可以运用 保持对象完整(Preserve Whole Object) 将来自同一对象的一堆数据收集起来，并以该对象替换它们。\n * 如果某些数据缺乏合理的对象归属，可使用 引入参数对象(Introduce Parameter Object) 为它们制造出一个“参数对象”。\n\n\n# 收益\n\n * 更易读，更简短的代码。\n * 重构可能会暴露出之前未注意到的重复代码。\n\n\n# 何时忽略\n\n * 这里有一个重要的例外：有时候你明显不想造成"被调用对象"与"较大对象"间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。\n\n\n# 重构方法说明\n\n# 以函数取代参数(Replace Parameter with Methods)\n\n问题\n\n对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。\n\nint basePrice = quantity * itemPrice;\ndouble seasonDiscount = this.getSeasonalDiscount();\ndouble fees = this.getFees();\ndouble finalPrice = discountedPrice(basePrice, seasonDiscount, fees);\n\n\n解决\n\n让参数接受者去除该项参数，并直接调用前一个函数。\n\nint basePrice = quantity * itemPrice;\ndouble finalPrice = discountedPrice(basePrice);\n\n\n# 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/bloaters\n> \n> 代码臃肿(bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n\n# 基本类型偏执\n\n> 基本类型偏执(primitive obsession)\n> \n>  * 使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。\n>  * 使用常量编码信息（例如一个用于引用管理员权限的常量user_admin_role = 1 ）。\n>  * 使用字符串常量作为字段名在数组中使用。\n\n\n\n\n# 问题原因\n\n类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。\n\n基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。\n\n还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。\n\n\n# 解决方法\n\n\n\n大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。\n\n基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。\n\n * 如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(replace type code with class) 。\n * 如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(introduce parameter object) 或 保持对象完整(preserve whole object) 。\n * 如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(replace type code with class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(replace type code with subclass) 或 以状态/策略模式取代类型码(replace type code with state/strategy) 加以处理。\n * 如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(replace array with object) 。\n\n\n# 收益\n\n * 多亏了使用对象替代基本数据类型，使得代码变得更加灵活。\n * 代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。\n * 更容易发现重复代码。\n\n\n\n\n# 重构方法说明\n\n# 以类取代类型码(replace type code with class)\n\n问题\n\n类之中有一个数值类型码，但它并不影响类的行为。\n\n\n\n解决\n\n以一个新的类替换该数值类型码。\n\n\n\n# 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 以子类取代类型码(replace type code with subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 以状态/策略模式取代类型码(replace type code with state/strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 以对象取代数组(replace array with object)\n\n问题\n\n你有一个数组，其中的元素各自代表不同的东西。\n\nstring[] row = new string[3];\nrow[0] = "liverpool";\nrow[1] = "15";\n\n\n解决\n\n以对象替换数组。对于数组中的每个元素，以一个字段来表示。\n\nperformance row = new performance();\nrow.setname("liverpool");\nrow.setwins("15");\n\n\n\n# 数据泥团\n\n> 数据泥团(data clumps)\n> \n> 有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。\n\n\n\n\n# 问题原因\n\n通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。\n\n有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。\n\n\n# 解决方法\n\n * 首先找出这些数据以字段形式出现的地方，运用 提炼类(extract class) 将它们提炼到一个独立对象中。\n * 如果数据泥团在函数的参数列中出现，运用 引入参数对象(introduce parameter object) 将它们组织成一个类。\n * 如果数据泥团的部分数据出现在其他函数中，考虑运用 保持对象完整(preserve whole object) 将整个数据对象传入到函数中。\n * 检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。\n\n\n# 收益\n\n * 提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。\n * 减少代码量。\n\n\n\n\n# 何时忽略\n\n * 有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。\n\n\n# 重构方法说明\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n\n# 过大的类\n\n> 过大的类(large class)\n> \n> 一个类含有过多字段、函数、代码行。\n\n\n\n\n# 问题原因\n\n类通常一开始很小，但是随着程序的增长而逐渐膨胀。\n\n类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。\n\n\n# 解决方法\n\n设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。\n\n\n\n * 如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 提炼类(extract class)。\n * 如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 提炼子类(extract subclass)。\n * 如果有必要为客户端提供一组操作和行为，可以使用 提炼接口(extract interface)。\n * 如果你的过大类是个 gui 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 复制被监视数据(duplicate observed data) 可以告诉你怎么做。\n\n\n# 收益\n\n * 重构过大的类可以使程序员不必记住一个类中大量的属性。\n * 在大多数情况下，分割过大的类可以避免代码和功能的重复。\n\n\n\n\n# 重构方法说明\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 提炼子类(extract subclass)\n\n问题\n\n一个类中有些特性仅用于特定场景。\n\n\n\n解决\n\n创建一个子类，并将用于特殊场景的特性置入其中。\n\n\n\n# 提炼接口(extract interface)\n\n问题\n\n多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。\n\n\n\n解决\n\n移动相同的部分函数到接口中。\n\n\n\n# 复制被监视数据(duplicate observed data)\n\n问题\n\n如果存储在类中的数据是负责 gui 的。\n\n\n\n解决\n\n一个比较好的方法是将负责 gui 的数据放入一个独立的类，以确保 gui 数据与域类之间的连接和同步。\n\n\n\n\n# 过长函数\n\n> 过长函数(long method)\n> \n> 一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。 函数中的代码行数原则上不要超过 100 行。\n\n\n\n\n# 问题的原因\n\n通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。\n\n\n# 解决函数\n\n一个很好的技巧是：寻找注释。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。\n\n\n\n * 为了给一个函数瘦身，可以使用 提炼函数(extract method)。\n * 如果局部变量和参数干扰提炼函数，可以使用 以查询取代临时变量(replace temp with query)，引入参数对象(introduce parameter object) 或 保持对象完整(preserve whole object) 。\n * 如果前面两条没有帮助，可以通过 以函数对象取代函数(replace method with method object) 尝试移动整个函数到一个独立的对象中。\n * 条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 分解条件表达式(decompose conditional) 。至于循环，应该使用 提炼函数(extract method) 将循环和其内的代码提炼到独立函数中。\n\n\n# 收益\n\n * 在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。\n * 此外，过长函数中往往含有难以发现的重复代码。\n\n\n\n\n# 性能\n\n是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。 此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。\n\n\n# 重构方法说明\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 以查询取代临时变量(replace temp with query)\n\n问题\n\n将表达式的结果放在局部变量中，然后在代码中使用。\n\ndouble calculatetotal() {\n  double baseprice = quantity * itemprice;\n  if (baseprice > 1000) {\n    return baseprice * 0.95;\n  }\n  else {\n    return baseprice * 0.98;\n  }\n}\n\n\n解决\n\n将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。\n\ndouble calculatetotal() {\n  if (baseprice() > 1000) {\n    return baseprice() * 0.95;\n  }\n  else {\n    return baseprice() * 0.98;\n  }\n}\ndouble baseprice() {\n  return quantity * itemprice;\n}\n\n\n# 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 以函数对象取代函数(replace method with method object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(extract method) 。\n\nclass order {\n  //...\n  public double price() {\n    double primarybaseprice;\n    double secondarybaseprice;\n    double tertiarybaseprice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass order {\n  //...\n  public double price() {\n    return new pricecalculator(this).compute();\n  }\n}\n\nclass pricecalculator {\n  private double primarybaseprice;\n  private double secondarybaseprice;\n  private double tertiarybaseprice;\n\n  public pricecalculator(order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 分解条件表达式(decompose conditional)\n\n问题\n\n你有复杂的条件表达式。\n\nif (date.before(summer_start) || date.after(summer_end)) {\n  charge = quantity * winterrate + winterservicecharge;\n}\nelse {\n  charge = quantity * summerrate;\n}\n\n\n解决\n\n根据条件分支将整个条件表达式分解成几个函数。\n\nif (notsummer(date)) {\n  charge = wintercharge(quantity);\n}\nelse {\n  charge = summercharge(quantity);\n}\n\n\n\n# 过长参数列\n\n> 过长参数列(long parameter list)\n> \n> 一个函数有超过 3、4 个入参。\n\n\n\n\n# 问题原因\n\n过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。\n\n过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。\n\n太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。\n\n\n# 解决方案\n\n\n\n * 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 以函数取代参数(replace parameter with methods) 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。\n * 你还可以运用 保持对象完整(preserve whole object) 将来自同一对象的一堆数据收集起来，并以该对象替换它们。\n * 如果某些数据缺乏合理的对象归属，可使用 引入参数对象(introduce parameter object) 为它们制造出一个“参数对象”。\n\n\n# 收益\n\n * 更易读，更简短的代码。\n * 重构可能会暴露出之前未注意到的重复代码。\n\n\n# 何时忽略\n\n * 这里有一个重要的例外：有时候你明显不想造成"被调用对象"与"较大对象"间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。\n\n\n# 重构方法说明\n\n# 以函数取代参数(replace parameter with methods)\n\n问题\n\n对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。\n\nint baseprice = quantity * itemprice;\ndouble seasondiscount = this.getseasonaldiscount();\ndouble fees = this.getfees();\ndouble finalprice = discountedprice(baseprice, seasondiscount, fees);\n\n\n解决\n\n让参数接受者去除该项参数，并直接调用前一个函数。\n\nint baseprice = quantity * itemprice;\ndouble finalprice = discountedprice(baseprice);\n\n\n# 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码坏味道之滥用面向对象",frontmatter:{title:"代码坏味道之滥用面向对象",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构"],permalink:"/pages/65ee05/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/03.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"03.设计/03.重构/03.代码坏味道之滥用面向对象.md",key:"v-ce0e8fd4",path:"/pages/65ee05/",headers:[{level:2,title:"Switch 声明",slug:"switch-声明",normalizedTitle:"switch 声明",charIndex:134},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:215},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:422},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:947},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:969},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:1102},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method",normalizedTitle:"提炼函数(extract method)",charIndex:489},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method",normalizedTitle:"搬移函数(move method)",charIndex:535},{level:4,title:"以子类取代类型码(Replace Type Code with Subclass)",slug:"以子类取代类型码-replace-type-code-with-subclass",normalizedTitle:"以子类取代类型码(replace type code with subclass)",charIndex:604},{level:4,title:"以状态/策略模式取代类型码(Replace Type Code with State/Strategy)",slug:"以状态-策略模式取代类型码-replace-type-code-with-state-strategy",normalizedTitle:"以状态/策略模式取代类型码(replace type code with state/strategy)",charIndex:648},{level:4,title:"以多态取代条件表达式(Replace Conditional with Polymorphism)",slug:"以多态取代条件表达式-replace-conditional-with-polymorphism",normalizedTitle:"以多态取代条件表达式(replace conditional with polymorphism)",charIndex:725},{level:4,title:"以明确函数取代参数(Replace Parameter with Explicit Methods)",slug:"以明确函数取代参数-replace-parameter-with-explicit-methods",normalizedTitle:"以明确函数取代参数(replace parameter with explicit methods)",charIndex:829},{level:4,title:"引入 Null 对象(Introduce Null Object)",slug:"引入-null-对象-introduce-null-object",normalizedTitle:"引入 null 对象(introduce null object)",charIndex:907},{level:2,title:"临时字段",slug:"临时字段",normalizedTitle:"临时字段",charIndex:3731},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:215},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:422},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:947},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:1102},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:4039},{level:4,title:"以函数对象取代函数(Replace Method with Method Object)",slug:"以函数对象取代函数-replace-method-with-method-object",normalizedTitle:"以函数对象取代函数(replace method with method object)",charIndex:4093},{level:4,title:"引入 Null 对象(Introduce Null Object)",slug:"引入-null-对象-introduce-null-object-2",normalizedTitle:"引入 null 对象(introduce null object)",charIndex:907},{level:2,title:"异曲同工的类",slug:"异曲同工的类",normalizedTitle:"异曲同工的类",charIndex:5601},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:215},{level:3,title:"解决方法",slug:"解决方法-3",normalizedTitle:"解决方法",charIndex:422},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:947},{level:3,title:"何时忽略",slug:"何时忽略-2",normalizedTitle:"何时忽略",charIndex:969},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:1102},{level:4,title:"函数改名(Rename Method)",slug:"函数改名-rename-method",normalizedTitle:"函数改名(rename method)",charIndex:5781},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-2",normalizedTitle:"搬移函数(move method)",charIndex:535},{level:4,title:"添加参数(Add Parameter)",slug:"添加参数-add-parameter",normalizedTitle:"添加参数(add parameter)",charIndex:5840},{level:4,title:"令函数携带参数(Parameterize Method)",slug:"令函数携带参数-parameterize-method",normalizedTitle:"令函数携带参数(parameterize method)",charIndex:5862},{level:4,title:"提炼超类(Extract Superclass)",slug:"提炼超类-extract-superclass",normalizedTitle:"提炼超类(extract superclass)",charIndex:5930},{level:2,title:"被拒绝的馈赠",slug:"被拒绝的馈赠",normalizedTitle:"被拒绝的馈赠",charIndex:6796},{level:3,title:"问题原因",slug:"问题原因-4",normalizedTitle:"问题原因",charIndex:215},{level:3,title:"解决方法",slug:"解决方法-4",normalizedTitle:"解决方法",charIndex:422},{level:3,title:"收益",slug:"收益-4",normalizedTitle:"收益",charIndex:947},{level:3,title:"重构方法说明",slug:"重构方法说明-4",normalizedTitle:"重构方法说明",charIndex:1102},{level:4,title:"以委托取代继承(Replace Inheritance with Delegation)",slug:"以委托取代继承-replace-inheritance-with-delegation",normalizedTitle:"以委托取代继承(replace inheritance with delegation)",charIndex:6963},{level:4,title:"提炼超类(Extract Superclass)",slug:"提炼超类-extract-superclass-2",normalizedTitle:"提炼超类(extract superclass)",charIndex:5930},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:7392},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7486}],headersStr:"Switch 声明 问题原因 解决方法 收益 何时忽略 重构方法说明 提炼函数(Extract Method) 搬移函数(Move Method) 以子类取代类型码(Replace Type Code with Subclass) 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 以多态取代条件表达式(Replace Conditional with Polymorphism) 以明确函数取代参数(Replace Parameter with Explicit Methods) 引入 Null 对象(Introduce Null Object) 临时字段 问题原因 解决方法 收益 重构方法说明 提炼类(Extract Class) 以函数对象取代函数(Replace Method with Method Object) 引入 Null 对象(Introduce Null Object) 异曲同工的类 问题原因 解决方法 收益 何时忽略 重构方法说明 函数改名(Rename Method) 搬移函数(Move Method) 添加参数(Add Parameter) 令函数携带参数(Parameterize Method) 提炼超类(Extract Superclass) 被拒绝的馈赠 问题原因 解决方法 收益 重构方法说明 以委托取代继承(Replace Inheritance with Delegation) 提炼超类(Extract Superclass) 扩展阅读 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/oo-abusers\n> \n> 滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n\n# Switch 声明\n\n> Switch 声明(Switch Statements)\n> \n> 你有一个复杂的 switch 语句或 if 序列语句。\n\n\n\n\n# 问题原因\n\n面向对象程序的一个最明显特征就是：少用 switch 和 case 语句。从本质上说，switch 语句的问题在于重复（if 序列也同样如此）。你常会发现 switch 语句散布于不同地点。如果要为它添加一个新的 case 子句，就必须找到所有 switch 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。\n\n大多数时候，一看到 switch 语句，就应该考虑以多态来替换它。\n\n\n# 解决方法\n\n * 问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 提炼函数(Extract Method) 将 switch 语句提炼到一个独立函数中，再以 搬移函数(Move Method) 将它搬移到需要多态性的那个类里。\n * 如果你的 switch 是基于类型码来识别分支，这时可以运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 。\n * 一旦完成这样的继承结构后，就可以运用 以多态取代条件表达式(Replace Conditional with Polymorphism) 了。\n * 如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 以明确函数取代参数(Replace Parameter with Explicit Methods) 。\n * 如果你的选择条件之一是 null，可以运用 引入 Null 对象(Introduce Null Object) 。\n\n\n# 收益\n\n * 提升代码组织性。\n\n\n\n\n# 何时忽略\n\n * 如果一个 switch 操作只是执行简单的行为，就没有重构的必要了。\n * switch 常被工厂设计模式族（工厂方法模式(Factory Method)和抽象工厂模式(Abstract Factory)）所使用，这种情况下也没必要重构。\n\n\n# 重构方法说明\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 以子类取代类型码(Replace Type Code with Subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 以多态取代条件表达式(Replace Conditional with Polymorphism)\n\n问题\n\n你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。\n\nclass Bird {\n  //...\n  double getSpeed() {\n    switch (type) {\n      case EUROPEAN:\n        return getBaseSpeed();\n      case AFRICAN:\n        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;\n      case NORWEGIAN_BLUE:\n        return (isNailed) ? 0 : getBaseSpeed(voltage);\n    }\n    throw new RuntimeException("Should be unreachable");\n  }\n}\n\n\n解决\n\n将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。\n\nabstract class Bird {\n  //...\n  abstract double getSpeed();\n}\n\nclass European extends Bird {\n  double getSpeed() {\n    return getBaseSpeed();\n  }\n}\nclass African extends Bird {\n  double getSpeed() {\n    return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;\n  }\n}\nclass NorwegianBlue extends Bird {\n  double getSpeed() {\n    return (isNailed) ? 0 : getBaseSpeed(voltage);\n  }\n}\n\n// Somewhere in client code\nspeed = bird.getSpeed();\n\n\n# 以明确函数取代参数(Replace Parameter with Explicit Methods)\n\n问题\n\n你有一个函数，其中完全取决于参数值而采取不同的行为。\n\nvoid setValue(String name, int value) {\n  if (name.equals("height")) {\n    height = value;\n    return;\n  }\n  if (name.equals("width")) {\n    width = value;\n    return;\n  }\n  Assert.shouldNeverReachHere();\n}\n\n\n解决\n\n针对该参数的每一个可能值，建立一个独立函数。\n\nvoid setHeight(int arg) {\n  height = arg;\n}\nvoid setWidth(int arg) {\n  width = arg;\n}\n\n\n# 引入 Null 对象(Introduce Null Object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = BillingPlan.basic();\n}\nelse {\n  plan = customer.getPlan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass NullCustomer extends Customer {\n  Plan getPlan() {\n    return new NullPlan();\n  }\n  // Some other NULL functionality.\n}\n\n// Replace null values with Null-object.\ncustomer = (order.customer != null) ? order.customer : new NullCustomer();\n\n// Use Null-object as if it\'s normal subclass.\nplan = customer.getPlan();\n\n\n\n# 临时字段\n\n> 临时字段(Temporary Field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。\n\n\n\n\n# 问题原因\n\n有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。 通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。 这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。\n\n\n# 解决方法\n\n * 可以通过 提炼类(Extract Class) 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 以函数对象取代函数(Replace Method with Method Object) 来实现同样的目的。\n * 引入 Null 对象(Introduce Null Object) 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。\n\n\n\n\n# 收益\n\n * 更好的代码清晰度和组织性。\n\n\n\n\n# 重构方法说明\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 以函数对象取代函数(Replace Method with Method Object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。\n\nclass Order {\n  //...\n  public double price() {\n    double primaryBasePrice;\n    double secondaryBasePrice;\n    double tertiaryBasePrice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass Order {\n  //...\n  public double price() {\n    return new PriceCalculator(this).compute();\n  }\n}\n\nclass PriceCalculator {\n  private double primaryBasePrice;\n  private double secondaryBasePrice;\n  private double tertiaryBasePrice;\n\n  public PriceCalculator(Order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 引入 Null 对象(Introduce Null Object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = BillingPlan.basic();\n}\nelse {\n  plan = customer.getPlan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass NullCustomer extends Customer {\n  Plan getPlan() {\n    return new NullPlan();\n  }\n  // Some other NULL functionality.\n}\n\n// Replace null values with Null-object.\ncustomer = (order.customer != null) ? order.customer : new NullCustomer();\n\n// Use Null-object as if it\'s normal subclass.\nplan = customer.getPlan();\n\n\n\n# 异曲同工的类\n\n> 异曲同工的类(Alternative Classes with Different Interfaces)\n> \n> 两个类中有着不同的函数，却在做着同一件事。\n\n\n\n\n# 问题原因\n\n这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。\n\n\n# 解决方法\n\n * 如果两个函数做同一件事，却有着不同的签名，请运用 函数改名(Rename Method) 根据它们的用途重新命名。\n * 运用 搬移函数(Move Method) 、 添加参数(Add Parameter) 和 令函数携带参数(Parameterize Method) 来使得方法的名称和实现一致。\n * 如果两个类仅有部分功能是重复的，尝试运用 提炼超类(Extract Superclass) 。这种情况下，已存在的类就成了超类。\n * 当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。\n\n\n# 收益\n\n * 消除了不必要的重复代码，为代码瘦身了。\n * 代码更易读（不再需要猜测为什么要有两个功能相同的类）。\n\n\n\n\n# 何时忽略\n\n * 有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。\n\n\n# 重构方法说明\n\n# 函数改名(Rename Method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass Person {\n  public String getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass Person {\n  public String getSecondName();\n}\n\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 添加参数(Add Parameter)\n\n问题 某个函数需要从调用端得到更多信息。\n\nclass Customer {\n  public Contact getContact();\n}\n\n\n解决 为此函数添加一个对象函数，让改对象带进函数所需信息。\n\nclass Customer {\n  public Contact getContact(Date date);\n}\n\n\n# 令函数携带参数(Parameterize Method)\n\n问题\n\n若干函数做了类似的工作，但在函数本体中却包含了不同的值。\n\n解决\n\n建立单一函数，以参数表达哪些不同的值。\n\n\n\n# 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 被拒绝的馈赠\n\n> 被拒绝的馈赠(Refused Bequest)\n> \n> 子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。\n\n\n\n\n# 问题原因\n\n有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。\n\n\n# 解决方法\n\n * 如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 以委托取代继承(Replace Inheritance with Delegation) 消除继承。\n * 如果继承是适当的，则去除子类中不需要的字段和方法。运用 提炼超类(Extract Superclass) 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。\n\n\n\n\n# 收益\n\n * 提高代码的清晰度和组织性。\n\n\n\n\n# 重构方法说明\n\n# 以委托取代继承(Replace Inheritance with Delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n 1. 在子类中新建一个字段用以保存超类；\n 2. 调整子类函数，令它改而委托超类；\n 3. 然后去掉两者之间的继承关系。\n\n\n\n# 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/oo-abusers\n> \n> 滥用面向对象(object-orientation abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n\n# switch 声明\n\n> switch 声明(switch statements)\n> \n> 你有一个复杂的 switch 语句或 if 序列语句。\n\n\n\n\n# 问题原因\n\n面向对象程序的一个最明显特征就是：少用 switch 和 case 语句。从本质上说，switch 语句的问题在于重复（if 序列也同样如此）。你常会发现 switch 语句散布于不同地点。如果要为它添加一个新的 case 子句，就必须找到所有 switch 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。\n\n大多数时候，一看到 switch 语句，就应该考虑以多态来替换它。\n\n\n# 解决方法\n\n * 问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 提炼函数(extract method) 将 switch 语句提炼到一个独立函数中，再以 搬移函数(move method) 将它搬移到需要多态性的那个类里。\n * 如果你的 switch 是基于类型码来识别分支，这时可以运用 以子类取代类型码(replace type code with subclass) 或 以状态/策略模式取代类型码(replace type code with state/strategy) 。\n * 一旦完成这样的继承结构后，就可以运用 以多态取代条件表达式(replace conditional with polymorphism) 了。\n * 如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 以明确函数取代参数(replace parameter with explicit methods) 。\n * 如果你的选择条件之一是 null，可以运用 引入 null 对象(introduce null object) 。\n\n\n# 收益\n\n * 提升代码组织性。\n\n\n\n\n# 何时忽略\n\n * 如果一个 switch 操作只是执行简单的行为，就没有重构的必要了。\n * switch 常被工厂设计模式族（工厂方法模式(factory method)和抽象工厂模式(abstract factory)）所使用，这种情况下也没必要重构。\n\n\n# 重构方法说明\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 以子类取代类型码(replace type code with subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 以状态/策略模式取代类型码(replace type code with state/strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 以多态取代条件表达式(replace conditional with polymorphism)\n\n问题\n\n你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。\n\nclass bird {\n  //...\n  double getspeed() {\n    switch (type) {\n      case european:\n        return getbasespeed();\n      case african:\n        return getbasespeed() - getloadfactor() * numberofcoconuts;\n      case norwegian_blue:\n        return (isnailed) ? 0 : getbasespeed(voltage);\n    }\n    throw new runtimeexception("should be unreachable");\n  }\n}\n\n\n解决\n\n将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。\n\nabstract class bird {\n  //...\n  abstract double getspeed();\n}\n\nclass european extends bird {\n  double getspeed() {\n    return getbasespeed();\n  }\n}\nclass african extends bird {\n  double getspeed() {\n    return getbasespeed() - getloadfactor() * numberofcoconuts;\n  }\n}\nclass norwegianblue extends bird {\n  double getspeed() {\n    return (isnailed) ? 0 : getbasespeed(voltage);\n  }\n}\n\n// somewhere in client code\nspeed = bird.getspeed();\n\n\n# 以明确函数取代参数(replace parameter with explicit methods)\n\n问题\n\n你有一个函数，其中完全取决于参数值而采取不同的行为。\n\nvoid setvalue(string name, int value) {\n  if (name.equals("height")) {\n    height = value;\n    return;\n  }\n  if (name.equals("width")) {\n    width = value;\n    return;\n  }\n  assert.shouldneverreachhere();\n}\n\n\n解决\n\n针对该参数的每一个可能值，建立一个独立函数。\n\nvoid setheight(int arg) {\n  height = arg;\n}\nvoid setwidth(int arg) {\n  width = arg;\n}\n\n\n# 引入 null 对象(introduce null object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = billingplan.basic();\n}\nelse {\n  plan = customer.getplan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass nullcustomer extends customer {\n  plan getplan() {\n    return new nullplan();\n  }\n  // some other null functionality.\n}\n\n// replace null values with null-object.\ncustomer = (order.customer != null) ? order.customer : new nullcustomer();\n\n// use null-object as if it\'s normal subclass.\nplan = customer.getplan();\n\n\n\n# 临时字段\n\n> 临时字段(temporary field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。\n\n\n\n\n# 问题原因\n\n有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。 通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。 这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。\n\n\n# 解决方法\n\n * 可以通过 提炼类(extract class) 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 以函数对象取代函数(replace method with method object) 来实现同样的目的。\n * 引入 null 对象(introduce null object) 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。\n\n\n\n\n# 收益\n\n * 更好的代码清晰度和组织性。\n\n\n\n\n# 重构方法说明\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 以函数对象取代函数(replace method with method object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(extract method) 。\n\nclass order {\n  //...\n  public double price() {\n    double primarybaseprice;\n    double secondarybaseprice;\n    double tertiarybaseprice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass order {\n  //...\n  public double price() {\n    return new pricecalculator(this).compute();\n  }\n}\n\nclass pricecalculator {\n  private double primarybaseprice;\n  private double secondarybaseprice;\n  private double tertiarybaseprice;\n\n  public pricecalculator(order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 引入 null 对象(introduce null object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = billingplan.basic();\n}\nelse {\n  plan = customer.getplan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass nullcustomer extends customer {\n  plan getplan() {\n    return new nullplan();\n  }\n  // some other null functionality.\n}\n\n// replace null values with null-object.\ncustomer = (order.customer != null) ? order.customer : new nullcustomer();\n\n// use null-object as if it\'s normal subclass.\nplan = customer.getplan();\n\n\n\n# 异曲同工的类\n\n> 异曲同工的类(alternative classes with different interfaces)\n> \n> 两个类中有着不同的函数，却在做着同一件事。\n\n\n\n\n# 问题原因\n\n这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。\n\n\n# 解决方法\n\n * 如果两个函数做同一件事，却有着不同的签名，请运用 函数改名(rename method) 根据它们的用途重新命名。\n * 运用 搬移函数(move method) 、 添加参数(add parameter) 和 令函数携带参数(parameterize method) 来使得方法的名称和实现一致。\n * 如果两个类仅有部分功能是重复的，尝试运用 提炼超类(extract superclass) 。这种情况下，已存在的类就成了超类。\n * 当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。\n\n\n# 收益\n\n * 消除了不必要的重复代码，为代码瘦身了。\n * 代码更易读（不再需要猜测为什么要有两个功能相同的类）。\n\n\n\n\n# 何时忽略\n\n * 有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。\n\n\n# 重构方法说明\n\n# 函数改名(rename method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass person {\n  public string getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass person {\n  public string getsecondname();\n}\n\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 添加参数(add parameter)\n\n问题 某个函数需要从调用端得到更多信息。\n\nclass customer {\n  public contact getcontact();\n}\n\n\n解决 为此函数添加一个对象函数，让改对象带进函数所需信息。\n\nclass customer {\n  public contact getcontact(date date);\n}\n\n\n# 令函数携带参数(parameterize method)\n\n问题\n\n若干函数做了类似的工作，但在函数本体中却包含了不同的值。\n\n解决\n\n建立单一函数，以参数表达哪些不同的值。\n\n\n\n# 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 被拒绝的馈赠\n\n> 被拒绝的馈赠(refused bequest)\n> \n> 子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。\n\n\n\n\n# 问题原因\n\n有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。\n\n\n# 解决方法\n\n * 如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 以委托取代继承(replace inheritance with delegation) 消除继承。\n * 如果继承是适当的，则去除子类中不需要的字段和方法。运用 提炼超类(extract superclass) 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。\n\n\n\n\n# 收益\n\n * 提高代码的清晰度和组织性。\n\n\n\n\n# 重构方法说明\n\n# 以委托取代继承(replace inheritance with delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n 1. 在子类中新建一个字段用以保存超类；\n 2. 调整子类函数，令它改而委托超类；\n 3. 然后去掉两者之间的继承关系。\n\n\n\n# 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码坏味道之变革的障碍",frontmatter:{title:"代码坏味道之变革的障碍",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],permalink:"/pages/56ca63/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/04.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.html",relativePath:"03.设计/03.重构/04.代码坏味道之变革的障碍.md",key:"v-38d3c9ce",path:"/pages/56ca63/",headers:[{level:2,title:"发散式变化",slug:"发散式变化",normalizedTitle:"发散式变化",charIndex:154},{level:3,title:"特征",slug:"特征",normalizedTitle:"特征",charIndex:307},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:391},{level:3,title:"解决办法",slug:"解决办法",normalizedTitle:"解决办法",charIndex:435},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:478},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:508},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:447},{level:2,title:"平行继承体系",slug:"平行继承体系",normalizedTitle:"平行继承体系",charIndex:593},{level:3,title:"特征",slug:"特征-2",normalizedTitle:"特征",charIndex:307},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:391},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:804},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:478},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:936},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:508},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method",normalizedTitle:"搬移函数(move method)",charIndex:851},{level:4,title:"搬移字段(Move Field)",slug:"搬移字段-move-field",normalizedTitle:"搬移字段(move field)",charIndex:871},{level:2,title:"霰弹式修改",slug:"霰弹式修改",normalizedTitle:"霰弹式修改",charIndex:191},{level:3,title:"特征",slug:"特征-3",normalizedTitle:"特征",charIndex:307},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:391},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:804},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:478},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:508},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-2",normalizedTitle:"搬移函数(move method)",charIndex:851},{level:4,title:"搬移字段(Move Field)",slug:"搬移字段-move-field-2",normalizedTitle:"搬移字段(move field)",charIndex:871},{level:4,title:"将类内联化(Inline Class)",slug:"将类内联化-inline-class",normalizedTitle:"将类内联化(inline class)",charIndex:1573},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:1966},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2060}],headersStr:"发散式变化 特征 问题原因 解决办法 收益 重构方法说明 提炼类(Extract Class) 平行继承体系 特征 问题原因 解决方法 收益 何时忽略 重构方法说明 搬移函数(Move Method) 搬移字段(Move Field) 霰弹式修改 特征 问题原因 解决方法 收益 重构方法说明 搬移函数(Move Method) 搬移字段(Move Field) 将类内联化(Inline Class) 扩展阅读 参考资料",content:"> 翻译自：https://sourcemaking.com/refactoring/smells/change-preventers\n> \n> 变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n\n# 发散式变化\n\n> 发散式变化(Divergent Change) 类似于 霰弹式修改(Shotgun Surgery) ，但实际上完全不同。发散式变化(Divergent Change) 是指一个类受多种变化的影响。霰弹式修改(Shotgun Surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 特征\n\n你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。\n\n\n\n\n# 问题原因\n\n通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。\n\n\n# 解决办法\n\n * 运用 提炼类(Extract Class) 拆分类的行为。\n\n\n# 收益\n\n * 提高代码组织结构\n * 减少重复代码\n\n\n# 重构方法说明\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n\n# 平行继承体系\n\n> 平行继承体系(Parallel Inheritance Hierarchies) 其实是 霰弹式修改(Shotgun Surgery) 的特殊情况。\n\n\n# 特征\n\n每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。\n\n\n\n\n# 问题原因\n\n起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。\n\n\n# 解决方法\n\n * 一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 搬移函数(Move Method) 和 搬移字段(Move Field)，就可以消除引用端的继承体系。\n\n\n# 收益\n\n * 更好的代码组织\n * 减少重复代码\n\n\n# 何时忽略\n\n * 有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n\n# 霰弹式修改\n\n> 霰弹式修改(Shotgun Surgery) 类似于 发散式变化(Divergent Change) ，但实际上完全不同。发散式变化(Divergent Change) 是指一个类受多种变化的影响。霰弹式修改(Shotgun Surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 特征\n\n任何修改都需要在许多不同类上做小幅度修改。\n\n\n\n\n# 问题原因\n\n一个单一的职责被拆分成大量的类。\n\n\n# 解决方法\n\n * 运用搬移函数(Move Method) 和 搬移字段(Move Field) 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。\n * 通常，可以运用 将类内联化(Inline Class) 将一些列相关行为放进同一个类。\n\n\n\n\n# 收益\n\n * 更好的代码组织\n * 减少重复代码\n * 更易维护\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",normalizedContent:"> 翻译自：https://sourcemaking.com/refactoring/smells/change-preventers\n> \n> 变革的障碍(change preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n\n# 发散式变化\n\n> 发散式变化(divergent change) 类似于 霰弹式修改(shotgun surgery) ，但实际上完全不同。发散式变化(divergent change) 是指一个类受多种变化的影响。霰弹式修改(shotgun surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 特征\n\n你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。\n\n\n\n\n# 问题原因\n\n通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。\n\n\n# 解决办法\n\n * 运用 提炼类(extract class) 拆分类的行为。\n\n\n# 收益\n\n * 提高代码组织结构\n * 减少重复代码\n\n\n# 重构方法说明\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n\n# 平行继承体系\n\n> 平行继承体系(parallel inheritance hierarchies) 其实是 霰弹式修改(shotgun surgery) 的特殊情况。\n\n\n# 特征\n\n每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。\n\n\n\n\n# 问题原因\n\n起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。\n\n\n# 解决方法\n\n * 一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 搬移函数(move method) 和 搬移字段(move field)，就可以消除引用端的继承体系。\n\n\n# 收益\n\n * 更好的代码组织\n * 减少重复代码\n\n\n# 何时忽略\n\n * 有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n\n# 霰弹式修改\n\n> 霰弹式修改(shotgun surgery) 类似于 发散式变化(divergent change) ，但实际上完全不同。发散式变化(divergent change) 是指一个类受多种变化的影响。霰弹式修改(shotgun surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 特征\n\n任何修改都需要在许多不同类上做小幅度修改。\n\n\n\n\n# 问题原因\n\n一个单一的职责被拆分成大量的类。\n\n\n# 解决方法\n\n * 运用搬移函数(move method) 和 搬移字段(move field) 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。\n * 通常，可以运用 将类内联化(inline class) 将一些列相关行为放进同一个类。\n\n\n\n\n# 收益\n\n * 更好的代码组织\n * 减少重复代码\n * 更易维护\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码坏味道之非必要的",frontmatter:{title:"代码坏味道之非必要的",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],permalink:"/pages/47acb5/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/05.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.html",relativePath:"03.设计/03.重构/05.代码坏味道之非必要的.md",key:"v-5d9b4816",path:"/pages/47acb5/",headers:[{level:2,title:"冗余类",slug:"冗余类",normalizedTitle:"冗余类",charIndex:130},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:200},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:283},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:379},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:404},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:465},{level:4,title:"将类内联化(Inline Class)",slug:"将类内联化-inline-class",normalizedTitle:"将类内联化(inline class)",charIndex:303},{level:4,title:"折叠继承体系(Collapse Hierarchy)",slug:"折叠继承体系-collapse-hierarchy",normalizedTitle:"折叠继承体系(collapse hierarchy)",charIndex:346},{level:2,title:"夸夸其谈未来性",slug:"夸夸其谈未来性",normalizedTitle:"夸夸其谈未来性",charIndex:618},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:200},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:283},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:379},{level:3,title:"何时忽略",slug:"何时忽略-2",normalizedTitle:"何时忽略",charIndex:404},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:465},{level:4,title:"折叠继承体系(Collapse Hierarchy)",slug:"折叠继承体系-collapse-hierarchy-2",normalizedTitle:"折叠继承体系(collapse hierarchy)",charIndex:346},{level:4,title:"将类内联化(Inline Class)",slug:"将类内联化-inline-class-2",normalizedTitle:"将类内联化(inline class)",charIndex:303},{level:4,title:"内联函数(Inline Method)",slug:"内联函数-inline-method",normalizedTitle:"内联函数(inline method)",charIndex:857},{level:4,title:"移除参数(Remove Parameter)",slug:"移除参数-remove-parameter",normalizedTitle:"移除参数(remove parameter)",charIndex:898},{level:2,title:"纯稚的数据类",slug:"纯稚的数据类",normalizedTitle:"纯稚的数据类",charIndex:1680},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:200},{level:3,title:"解决方法",slug:"解决方法-3",normalizedTitle:"解决方法",charIndex:283},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:379},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:465},{level:4,title:"封装字段(Encapsulated Field)",slug:"封装字段-encapsulated-field",normalizedTitle:"封装字段(encapsulated field)",charIndex:1918},{level:4,title:"封装集合(Encapsulated Collection)",slug:"封装集合-encapsulated-collection",normalizedTitle:"封装集合(encapsulated collection)",charIndex:2001},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method",normalizedTitle:"搬移函数(move method)",charIndex:2078},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method",normalizedTitle:"提炼函数(extract method)",charIndex:2143},{level:4,title:"移除设置函数(Remove Setting Method)",slug:"移除设置函数-remove-setting-method",normalizedTitle:"移除设置函数(remove setting method)",charIndex:2240},{level:4,title:"隐藏函数(Hide Method)",slug:"隐藏函数-hide-method",normalizedTitle:"隐藏函数(hide method)",charIndex:2272},{level:2,title:"过多的注释",slug:"过多的注释",normalizedTitle:"过多的注释",charIndex:3478},{level:3,title:"问题原因",slug:"问题原因-4",normalizedTitle:"问题原因",charIndex:200},{level:3,title:"解决方法",slug:"解决方法-4",normalizedTitle:"解决方法",charIndex:283},{level:3,title:"收益",slug:"收益-4",normalizedTitle:"收益",charIndex:379},{level:3,title:"何时忽略",slug:"何时忽略-3",normalizedTitle:"何时忽略",charIndex:404},{level:3,title:"重构方法说明",slug:"重构方法说明-4",normalizedTitle:"重构方法说明",charIndex:465},{level:4,title:"提炼变量(Extract Variable)",slug:"提炼变量-extract-variable",normalizedTitle:"提炼变量(extract variable)",charIndex:3734},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method-2",normalizedTitle:"提炼函数(extract method)",charIndex:2143},{level:4,title:"函数改名(Rename Method)",slug:"函数改名-rename-method",normalizedTitle:"函数改名(rename method)",charIndex:3856},{level:4,title:"引入断言(Introduce Assertion)",slug:"引入断言-introduce-assertion",normalizedTitle:"引入断言(introduce assertion)",charIndex:3915},{level:2,title:"重复代码",slug:"重复代码",normalizedTitle:"重复代码",charIndex:5785},{level:3,title:"问题原因",slug:"问题原因-5",normalizedTitle:"问题原因",charIndex:200},{level:3,title:"解决方法",slug:"解决方法-5",normalizedTitle:"解决方法",charIndex:283},{level:3,title:"收益",slug:"收益-5",normalizedTitle:"收益",charIndex:379},{level:3,title:"重构方法说明",slug:"重构方法说明-5",normalizedTitle:"重构方法说明",charIndex:465},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method-3",normalizedTitle:"提炼函数(extract method)",charIndex:2143},{level:4,title:"函数上移(Pull Up Method)",slug:"函数上移-pull-up-method",normalizedTitle:"函数上移(pull up method)",charIndex:6239},{level:4,title:"构造函数本体上移(Pull Up Constructor Body)",slug:"构造函数本体上移-pull-up-constructor-body",normalizedTitle:"构造函数本体上移(pull up constructor body)",charIndex:6290},{level:4,title:"塑造模板函数(Form Template Method)",slug:"塑造模板函数-form-template-method",normalizedTitle:"塑造模板函数(form template method)",charIndex:6353},{level:4,title:"替换算法(Substitute Algorithm)",slug:"替换算法-substitute-algorithm",normalizedTitle:"替换算法(substitute algorithm)",charIndex:6454},{level:4,title:"提炼超类(Extract Superclass)",slug:"提炼超类-extract-superclass",normalizedTitle:"提炼超类(extract superclass)",charIndex:6526},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:6601},{level:4,title:"合并条件表达式(Consolidate Conditional Expression)",slug:"合并条件表达式-consolidate-conditional-expression",normalizedTitle:"合并条件表达式(consolidate conditional expression)",charIndex:6685},{level:4,title:"合并重复的条件片段(Consolidate Duplicate Conditional Fragments)",slug:"合并重复的条件片段-consolidate-duplicate-conditional-fragments",normalizedTitle:"合并重复的条件片段(consolidate duplicate conditional fragments)",charIndex:6821},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:9568},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9662}],headersStr:"冗余类 问题原因 解决方法 收益 何时忽略 重构方法说明 将类内联化(Inline Class) 折叠继承体系(Collapse Hierarchy) 夸夸其谈未来性 问题原因 解决方法 收益 何时忽略 重构方法说明 折叠继承体系(Collapse Hierarchy) 将类内联化(Inline Class) 内联函数(Inline Method) 移除参数(Remove Parameter) 纯稚的数据类 问题原因 解决方法 收益 重构方法说明 封装字段(Encapsulated Field) 封装集合(Encapsulated Collection) 搬移函数(Move Method) 提炼函数(Extract Method) 移除设置函数(Remove Setting Method) 隐藏函数(Hide Method) 过多的注释 问题原因 解决方法 收益 何时忽略 重构方法说明 提炼变量(Extract Variable) 提炼函数(Extract Method) 函数改名(Rename Method) 引入断言(Introduce Assertion) 重复代码 问题原因 解决方法 收益 重构方法说明 提炼函数(Extract Method) 函数上移(Pull Up Method) 构造函数本体上移(Pull Up Constructor Body) 塑造模板函数(Form Template Method) 替换算法(Substitute Algorithm) 提炼超类(Extract Superclass) 提炼类(Extract Class) 合并条件表达式(Consolidate Conditional Expression) 合并重复的条件片段(Consolidate Duplicate Conditional Fragments) 扩展阅读 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/dispensables\n> \n> 非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n\n# 冗余类\n\n> 冗余类(Lazy Class)\n> \n> 理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。\n\n\n\n\n# 问题原因\n\n也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。 又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。\n\n\n# 解决方法\n\n * 没什么用的类可以运用 将类内联化(Inline Class) 来干掉。\n\n\n\n * 如果子类用处不大，试试 折叠继承体系(Collapse Hierarchy) 。\n\n\n# 收益\n\n * 减少代码量\n * 易于维护\n\n\n# 何时忽略\n\n * 有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。\n\n\n# 重构方法说明\n\n# 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 折叠继承体系(Collapse Hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n\n# 夸夸其谈未来性\n\n> 夸夸其谈未来性(Speculative Generality)\n> \n> 存在未被使用的类、函数、字段或参数。\n\n\n\n\n# 问题原因\n\n有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。\n\n\n# 解决方法\n\n * 如果你的某个抽象类其实没有太大作用，请运用 折叠继承体系(Collapse Hierarch) 。\n\n\n\n * 不必要的委托可运用 将类内联化(Inline Class) 消除。\n * 无用的函数可运用 内联函数(Inline Method) 消除。\n * 函数中有无用的参数应该运用 移除参数(Remove Parameter) 消除。\n * 无用字段可以直接删除。\n\n\n# 收益\n\n * 减少代码量。\n * 更易维护。\n\n\n# 何时忽略\n\n * 如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。\n * 删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。\n\n\n# 重构方法说明\n\n# 折叠继承体系(Collapse Hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n# 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 内联函数(Inline Method)\n\n问题\n\n一个函数的本体比函数名更清楚易懂。\n\nclass PizzaDelivery {\n  //...\n  int getRating() {\n    return moreThanFiveLateDeliveries() ? 2 : 1;\n  }\n  boolean moreThanFiveLateDeliveries() {\n    return numberOfLateDeliveries > 5;\n  }\n}\n\n\n解决\n\n在函数调用点插入函数本体，然后移除该函数。\n\nclass PizzaDelivery {\n  //...\n  int getRating() {\n    return numberOfLateDeliveries > 5 ? 2 : 1;\n  }\n}\n\n\n# 移除参数(Remove Parameter)\n\n问题\n\n函数本体不再需要某个参数。\n\n\n\n解决\n\n将该参数去除。\n\n\n\n\n# 纯稚的数据类\n\n> 纯稚的数据类(Data Class) 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。\n\n\n\n\n# 问题原因\n\n当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。\n\n\n# 解决方法\n\n * 如果一个类有公共字段，你应该运用 封装字段(Encapsulated Field) 来隐藏字段的直接访问方式。\n * 如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 封装集合(Encapsulated Collection) 把它们封装起来。\n * 找出这些 getter/setter 函数被其他类运用的地点。尝试以 搬移函数(Move Method) 把那些调用行为搬移到 纯稚的数据类(Data Class) 来。如果无法搬移这个函数，就运用 提炼函数(Extract Method) 产生一个可搬移的函数。\n\n\n\n * 在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 移除设置函数(Remove Setting Method) 和 隐藏函数(Hide Method) 。\n\n\n# 收益\n\n * 提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。\n * 帮助你发现客户端代码的重复处。\n\n\n# 重构方法说明\n\n# 封装字段(Encapsulated Field)\n\n问题\n\n你的类中存在 public 字段。\n\nclass Person {\n  public String name;\n}\n\n\n解决\n\n将它声明为 private，并提供相应的访问函数。\n\nclass Person {\n  private String name;\n\n  public String getName() {\n    return name;\n  }\n  public void setName(String arg) {\n    name = arg;\n  }\n}\n\n\n# 封装集合(Encapsulated Collection)\n\n问题\n\n有个函数返回一个集合。\n\n\n\n解决\n\n让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。\n\n\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 移除设置函数(Remove Setting Method)\n\n问题\n\n类中的某个字段应该在对象创建时被设值，然后就不再改变。\n\n\n\n解决\n\n去掉该字段的所有设值函数。\n\n\n\n# 隐藏函数(Hide Method)\n\n问题\n\n有一个函数，从来没有被其他任何类用到。\n\n\n\n解决\n\n将这个函数修改为 private。\n\n\n\n\n# 过多的注释\n\n> 过多的注释(Comments)\n> \n> 注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。\n\n\n\n\n# 问题原因\n\n注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。\n\n> 最好的注释是为函数或类起一个恰当的名字。\n\n如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。\n\n\n# 解决方法\n\n * 如果一个注释是为了解释一个复杂的表达式，可以运用 提炼变量(Extract Variable) 将表达式切分为易理解的子表达式。\n * 如果你需要通过注释来解释一段代码做了什么，请试试 提炼函数(Extract Method) 。\n * 如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 函数改名(Rename Method) 来为函数起一个可以自解释的名字。\n * 如果需要对系统某状态进行断言，请运用 引入断言(Introduce Assertion) 。\n\n\n# 收益\n\n * 代码变得更直观和明显。\n\n\n# 何时忽略\n\n注释有时候很有用：\n\n * 当解释为什么某事物要以特殊方式实现时。\n * 当解释某种复杂算法时。\n * 当你实在不知可以做些什么时。\n\n\n# 重构方法说明\n\n# 提炼变量(Extract Variable)\n\n问题\n\n你有个难以理解的表达式。\n\nvoid renderBanner() {\n  if ((platform.toUpperCase().indexOf("MAC") > -1) &&\n       (browser.toUpperCase().indexOf("IE") > -1) &&\n        wasInitialized() && resize > 0 )\n  {\n    // do something\n  }\n}\n\n\n解决\n\n将表达式的结果或它的子表达式的结果用不言自明的变量来替代。\n\nvoid renderBanner() {\n  final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;\n  final boolean isIE = browser.toUpperCase().indexOf("IE") > -1;\n  final boolean wasResized = resize > 0;\n\n  if (isMacOs && isIE && wasInitialized() && wasResized) {\n    // do something\n  }\n}\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 函数改名(Rename Method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass Person {\n  public String getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass Person {\n  public String getSecondName();\n}\n\n\n# 引入断言(Introduce Assertion)\n\n问题\n\n某一段代码需要对程序状态做出某种假设。\n\ndouble getExpenseLimit() {\n  // should have either expense limit or a primary project\n  return (expenseLimit != NULL_EXPENSE) ?\n    expenseLimit:\n    primaryProject.getMemberExpenseLimit();\n}\n\n\n解决\n\n以断言明确表现这种假设。\n\ndouble getExpenseLimit() {\n  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != null);\n\n  return (expenseLimit != NULL_EXPENSE) ?\n    expenseLimit:\n    primaryProject.getMemberExpenseLimit();\n}\n\n\n注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。\n\n\n# 重复代码\n\n> 重复代码(Duplicate Code)\n> \n> 重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。\n\n\n\n\n# 问题原因\n\n重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。\n\n还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。\n\n有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。\n\n\n# 解决方法\n\n * 同一个类的两个函数含有相同的表达式，这时可以采用 提炼函数(Extract Method) 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。\n\n\n\n * 如果两个互为兄弟的子类含有重复代码：\n   * 首先对两个类都运用 提炼函数(Extract Method) ，然后对被提炼出来的函数运用 函数上移(Pull Up Method) ，将它推入超类。\n   * 如果重复代码在构造函数中，运用 构造函数本体上移(Pull Up Constructor Body) 。\n   * 如果重复代码只是相似但不是完全相同，运用 塑造模板函数(Form Template Method) 获得一个 模板方法模式(Template Method) 。\n   * 如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 替换算法(Substitute Algorithm) 将其他函数的算法替换掉。\n * 如果两个毫不相关的类中有重复代码：\n   * 请尝试运用 提炼超类(Extract Superclass) ，以便为维护所有先前功能的这些类创建一个超类。\n   * 如果创建超类十分困难，可以在一个类中运用 提炼类(Extract Class) ，并在另一个类中使用这个新的组件。\n * 如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 合并条件表达式(Consolidate Conditional Expression) 将这些操作合并为单个条件，并运用 提炼函数(Extract Method) 将该条件放入一个名字容易理解的独立函数中。\n * 如果条件表达式的所有分支都有部分相同的代码片段：可以运用 合并重复的条件片段(Consolidate Duplicate Conditional Fragments) 将它们都存在的代码片段置于条件表达式外部。\n\n\n# 收益\n\n * 合并重复代码会简化代码的结构，并减少代码量。\n * 代码更简化、更易维护。\n\n\n# 重构方法说明\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 函数上移(Pull Up Method)\n\n问题\n\n有些函数，在各个子类中产生完全相同的结果。\n\n\n\n解决\n\n将该函数移至超类。\n\n\n\n# 构造函数本体上移(Pull Up Constructor Body)\n\n问题\n\n你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。\n\nclass Manager extends Employee {\n  public Manager(String name, String id, int grade) {\n    this.name = name;\n    this.id = id;\n    this.grade = grade;\n  }\n  //...\n}\n\n\n解决\n\n在超类中新建一个构造函数，并在子类构造函数中调用它。\n\nclass Manager extends Employee {\n  public Manager(String name, String id, int grade) {\n    super(name, id);\n    this.grade = grade;\n  }\n  //...\n}\n\n\n# 塑造模板函数(Form Template Method)\n\n问题\n\n你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。\n\n\n\n解决\n\n将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。\n\n\n\n注：这里只提到具体做法，建议了解一下模板方法设计模式。\n\n# 替换算法(Substitute Algorithm)\n\n问题\n\n你想要把某个算法替换为另一个更清晰的算法。\n\nString foundPerson(String[] people){\n  for (int i = 0; i < people.length; i++) {\n    if (people[i].equals("Don")){\n      return "Don";\n    }\n    if (people[i].equals("John")){\n      return "John";\n    }\n    if (people[i].equals("Kent")){\n      return "Kent";\n    }\n  }\n  return "";\n}\n\n\n解决\n\n将函数本体替换为另一个算法。\n\nString foundPerson(String[] people){\n  List candidates =\n    Arrays.asList(new String[] {"Don", "John", "Kent"});\n  for (int i=0; i < people.length; i++) {\n    if (candidates.contains(people[i])) {\n      return people[i];\n    }\n  }\n  return "";\n}\n\n\n# 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 合并条件表达式(Consolidate Conditional Expression)\n\n问题\n\n你有一系列条件分支，都得到相同结果。\n\ndouble disabilityAmount() {\n  if (seniority < 2) {\n    return 0;\n  }\n  if (monthsDisabled > 12) {\n    return 0;\n  }\n  if (isPartTime) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n解决\n\n将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。\n\ndouble disabilityAmount() {\n  if (isNotEligableForDisability()) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n# 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)\n\n问题\n\n在条件表达式的每个分支上有着相同的一段代码。\n\nif (isSpecialDeal()) {\n  total = price * 0.95;\n  send();\n}\nelse {\n  total = price * 0.98;\n  send();\n}\n\n\n解决\n\n将这段重复代码搬移到条件表达式之外。\n\nif (isSpecialDeal()) {\n  total = price * 0.95;\n}\nelse {\n  total = price * 0.98;\n}\nsend();\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/dispensables\n> \n> 非必要的(dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n\n# 冗余类\n\n> 冗余类(lazy class)\n> \n> 理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。\n\n\n\n\n# 问题原因\n\n也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。 又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。\n\n\n# 解决方法\n\n * 没什么用的类可以运用 将类内联化(inline class) 来干掉。\n\n\n\n * 如果子类用处不大，试试 折叠继承体系(collapse hierarchy) 。\n\n\n# 收益\n\n * 减少代码量\n * 易于维护\n\n\n# 何时忽略\n\n * 有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。\n\n\n# 重构方法说明\n\n# 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 折叠继承体系(collapse hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n\n# 夸夸其谈未来性\n\n> 夸夸其谈未来性(speculative generality)\n> \n> 存在未被使用的类、函数、字段或参数。\n\n\n\n\n# 问题原因\n\n有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。\n\n\n# 解决方法\n\n * 如果你的某个抽象类其实没有太大作用，请运用 折叠继承体系(collapse hierarch) 。\n\n\n\n * 不必要的委托可运用 将类内联化(inline class) 消除。\n * 无用的函数可运用 内联函数(inline method) 消除。\n * 函数中有无用的参数应该运用 移除参数(remove parameter) 消除。\n * 无用字段可以直接删除。\n\n\n# 收益\n\n * 减少代码量。\n * 更易维护。\n\n\n# 何时忽略\n\n * 如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。\n * 删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。\n\n\n# 重构方法说明\n\n# 折叠继承体系(collapse hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n# 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 内联函数(inline method)\n\n问题\n\n一个函数的本体比函数名更清楚易懂。\n\nclass pizzadelivery {\n  //...\n  int getrating() {\n    return morethanfivelatedeliveries() ? 2 : 1;\n  }\n  boolean morethanfivelatedeliveries() {\n    return numberoflatedeliveries > 5;\n  }\n}\n\n\n解决\n\n在函数调用点插入函数本体，然后移除该函数。\n\nclass pizzadelivery {\n  //...\n  int getrating() {\n    return numberoflatedeliveries > 5 ? 2 : 1;\n  }\n}\n\n\n# 移除参数(remove parameter)\n\n问题\n\n函数本体不再需要某个参数。\n\n\n\n解决\n\n将该参数去除。\n\n\n\n\n# 纯稚的数据类\n\n> 纯稚的数据类(data class) 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。\n\n\n\n\n# 问题原因\n\n当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。\n\n\n# 解决方法\n\n * 如果一个类有公共字段，你应该运用 封装字段(encapsulated field) 来隐藏字段的直接访问方式。\n * 如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 封装集合(encapsulated collection) 把它们封装起来。\n * 找出这些 getter/setter 函数被其他类运用的地点。尝试以 搬移函数(move method) 把那些调用行为搬移到 纯稚的数据类(data class) 来。如果无法搬移这个函数，就运用 提炼函数(extract method) 产生一个可搬移的函数。\n\n\n\n * 在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 移除设置函数(remove setting method) 和 隐藏函数(hide method) 。\n\n\n# 收益\n\n * 提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。\n * 帮助你发现客户端代码的重复处。\n\n\n# 重构方法说明\n\n# 封装字段(encapsulated field)\n\n问题\n\n你的类中存在 public 字段。\n\nclass person {\n  public string name;\n}\n\n\n解决\n\n将它声明为 private，并提供相应的访问函数。\n\nclass person {\n  private string name;\n\n  public string getname() {\n    return name;\n  }\n  public void setname(string arg) {\n    name = arg;\n  }\n}\n\n\n# 封装集合(encapsulated collection)\n\n问题\n\n有个函数返回一个集合。\n\n\n\n解决\n\n让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。\n\n\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 移除设置函数(remove setting method)\n\n问题\n\n类中的某个字段应该在对象创建时被设值，然后就不再改变。\n\n\n\n解决\n\n去掉该字段的所有设值函数。\n\n\n\n# 隐藏函数(hide method)\n\n问题\n\n有一个函数，从来没有被其他任何类用到。\n\n\n\n解决\n\n将这个函数修改为 private。\n\n\n\n\n# 过多的注释\n\n> 过多的注释(comments)\n> \n> 注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。\n\n\n\n\n# 问题原因\n\n注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。\n\n> 最好的注释是为函数或类起一个恰当的名字。\n\n如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。\n\n\n# 解决方法\n\n * 如果一个注释是为了解释一个复杂的表达式，可以运用 提炼变量(extract variable) 将表达式切分为易理解的子表达式。\n * 如果你需要通过注释来解释一段代码做了什么，请试试 提炼函数(extract method) 。\n * 如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 函数改名(rename method) 来为函数起一个可以自解释的名字。\n * 如果需要对系统某状态进行断言，请运用 引入断言(introduce assertion) 。\n\n\n# 收益\n\n * 代码变得更直观和明显。\n\n\n# 何时忽略\n\n注释有时候很有用：\n\n * 当解释为什么某事物要以特殊方式实现时。\n * 当解释某种复杂算法时。\n * 当你实在不知可以做些什么时。\n\n\n# 重构方法说明\n\n# 提炼变量(extract variable)\n\n问题\n\n你有个难以理解的表达式。\n\nvoid renderbanner() {\n  if ((platform.touppercase().indexof("mac") > -1) &&\n       (browser.touppercase().indexof("ie") > -1) &&\n        wasinitialized() && resize > 0 )\n  {\n    // do something\n  }\n}\n\n\n解决\n\n将表达式的结果或它的子表达式的结果用不言自明的变量来替代。\n\nvoid renderbanner() {\n  final boolean ismacos = platform.touppercase().indexof("mac") > -1;\n  final boolean isie = browser.touppercase().indexof("ie") > -1;\n  final boolean wasresized = resize > 0;\n\n  if (ismacos && isie && wasinitialized() && wasresized) {\n    // do something\n  }\n}\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 函数改名(rename method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass person {\n  public string getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass person {\n  public string getsecondname();\n}\n\n\n# 引入断言(introduce assertion)\n\n问题\n\n某一段代码需要对程序状态做出某种假设。\n\ndouble getexpenselimit() {\n  // should have either expense limit or a primary project\n  return (expenselimit != null_expense) ?\n    expenselimit:\n    primaryproject.getmemberexpenselimit();\n}\n\n\n解决\n\n以断言明确表现这种假设。\n\ndouble getexpenselimit() {\n  assert.istrue(expenselimit != null_expense || primaryproject != null);\n\n  return (expenselimit != null_expense) ?\n    expenselimit:\n    primaryproject.getmemberexpenselimit();\n}\n\n\n注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。\n\n\n# 重复代码\n\n> 重复代码(duplicate code)\n> \n> 重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。\n\n\n\n\n# 问题原因\n\n重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。\n\n还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。\n\n有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。\n\n\n# 解决方法\n\n * 同一个类的两个函数含有相同的表达式，这时可以采用 提炼函数(extract method) 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。\n\n\n\n * 如果两个互为兄弟的子类含有重复代码：\n   * 首先对两个类都运用 提炼函数(extract method) ，然后对被提炼出来的函数运用 函数上移(pull up method) ，将它推入超类。\n   * 如果重复代码在构造函数中，运用 构造函数本体上移(pull up constructor body) 。\n   * 如果重复代码只是相似但不是完全相同，运用 塑造模板函数(form template method) 获得一个 模板方法模式(template method) 。\n   * 如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 替换算法(substitute algorithm) 将其他函数的算法替换掉。\n * 如果两个毫不相关的类中有重复代码：\n   * 请尝试运用 提炼超类(extract superclass) ，以便为维护所有先前功能的这些类创建一个超类。\n   * 如果创建超类十分困难，可以在一个类中运用 提炼类(extract class) ，并在另一个类中使用这个新的组件。\n * 如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 合并条件表达式(consolidate conditional expression) 将这些操作合并为单个条件，并运用 提炼函数(extract method) 将该条件放入一个名字容易理解的独立函数中。\n * 如果条件表达式的所有分支都有部分相同的代码片段：可以运用 合并重复的条件片段(consolidate duplicate conditional fragments) 将它们都存在的代码片段置于条件表达式外部。\n\n\n# 收益\n\n * 合并重复代码会简化代码的结构，并减少代码量。\n * 代码更简化、更易维护。\n\n\n# 重构方法说明\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 函数上移(pull up method)\n\n问题\n\n有些函数，在各个子类中产生完全相同的结果。\n\n\n\n解决\n\n将该函数移至超类。\n\n\n\n# 构造函数本体上移(pull up constructor body)\n\n问题\n\n你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。\n\nclass manager extends employee {\n  public manager(string name, string id, int grade) {\n    this.name = name;\n    this.id = id;\n    this.grade = grade;\n  }\n  //...\n}\n\n\n解决\n\n在超类中新建一个构造函数，并在子类构造函数中调用它。\n\nclass manager extends employee {\n  public manager(string name, string id, int grade) {\n    super(name, id);\n    this.grade = grade;\n  }\n  //...\n}\n\n\n# 塑造模板函数(form template method)\n\n问题\n\n你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。\n\n\n\n解决\n\n将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。\n\n\n\n注：这里只提到具体做法，建议了解一下模板方法设计模式。\n\n# 替换算法(substitute algorithm)\n\n问题\n\n你想要把某个算法替换为另一个更清晰的算法。\n\nstring foundperson(string[] people){\n  for (int i = 0; i < people.length; i++) {\n    if (people[i].equals("don")){\n      return "don";\n    }\n    if (people[i].equals("john")){\n      return "john";\n    }\n    if (people[i].equals("kent")){\n      return "kent";\n    }\n  }\n  return "";\n}\n\n\n解决\n\n将函数本体替换为另一个算法。\n\nstring foundperson(string[] people){\n  list candidates =\n    arrays.aslist(new string[] {"don", "john", "kent"});\n  for (int i=0; i < people.length; i++) {\n    if (candidates.contains(people[i])) {\n      return people[i];\n    }\n  }\n  return "";\n}\n\n\n# 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 合并条件表达式(consolidate conditional expression)\n\n问题\n\n你有一系列条件分支，都得到相同结果。\n\ndouble disabilityamount() {\n  if (seniority < 2) {\n    return 0;\n  }\n  if (monthsdisabled > 12) {\n    return 0;\n  }\n  if (isparttime) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n解决\n\n将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。\n\ndouble disabilityamount() {\n  if (isnoteligablefordisability()) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n# 合并重复的条件片段(consolidate duplicate conditional fragments)\n\n问题\n\n在条件表达式的每个分支上有着相同的一段代码。\n\nif (isspecialdeal()) {\n  total = price * 0.95;\n  send();\n}\nelse {\n  total = price * 0.98;\n  send();\n}\n\n\n解决\n\n将这段重复代码搬移到条件表达式之外。\n\nif (isspecialdeal()) {\n  total = price * 0.95;\n}\nelse {\n  total = price * 0.98;\n}\nsend();\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"代码坏味道之耦合",frontmatter:{title:"代码坏味道之耦合",date:"2018-10-13T22:48:00.000Z",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],permalink:"/pages/630e7a/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/06.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.html",relativePath:"03.设计/03.重构/06.代码坏味道之耦合.md",key:"v-3a98d9f2",path:"/pages/630e7a/",headers:[{level:2,title:"不完美的库类",slug:"不完美的库类",normalizedTitle:"不完美的库类",charIndex:100},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"引入外加函数(Introduce Foreign Method)",slug:"引入外加函数-introduce-foreign-method",normalizedTitle:"引入外加函数(introduce foreign method)",charIndex:319},{level:4,title:"引入本地扩展(Introduce Local Extension)",slug:"引入本地扩展-introduce-local-extension",normalizedTitle:"引入本地扩展(introduce local extension)",charIndex:375},{level:2,title:"中间人",slug:"中间人",normalizedTitle:"中间人",charIndex:1118},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-2",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"移除中间人(Remove Middle Man)",slug:"移除中间人-remove-middle-man",normalizedTitle:"移除中间人(remove middle man)",charIndex:1305},{level:2,title:"依恋情结",slug:"依恋情结",normalizedTitle:"依恋情结",charIndex:1540},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-3",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-3",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method",normalizedTitle:"提炼函数(extract method)",charIndex:1993},{level:2,title:"狎昵关系",slug:"狎昵关系",normalizedTitle:"狎昵关系",charIndex:2863},{level:3,title:"问题原因",slug:"问题原因-4",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-4",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-4",normalizedTitle:"收益",charIndex:415},{level:3,title:"重构方法说明",slug:"重构方法说明-4",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-2",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:4,title:"搬移字段(Move Field)",slug:"搬移字段-move-field",normalizedTitle:"搬移字段(move field)",charIndex:3019},{level:4,title:"将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)",slug:"将双向关联改为单向关联-change-bidirectional-association-to-unidirectional",normalizedTitle:"将双向关联改为单向关联(change bidirectional association to unidirectional)",charIndex:3065},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:3172},{level:4,title:"隐藏委托关系(Hide Delegate)",slug:"隐藏委托关系-hide-delegate",normalizedTitle:"隐藏委托关系(hide delegate)",charIndex:3226},{level:4,title:"以委托取代继承(Replace Inheritance with Delegation)",slug:"以委托取代继承-replace-inheritance-with-delegation",normalizedTitle:"以委托取代继承(replace inheritance with delegation)",charIndex:3323},{level:2,title:"过度耦合的消息链",slug:"过度耦合的消息链",normalizedTitle:"过度耦合的消息链",charIndex:4079},{level:3,title:"问题原因",slug:"问题原因-5",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-5",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-5",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-4",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-5",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"隐藏委托关系(Hide Delegate)",slug:"隐藏委托关系-hide-delegate-2",normalizedTitle:"隐藏委托关系(hide delegate)",charIndex:3226},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method-2",normalizedTitle:"提炼函数(extract method)",charIndex:1993},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-3",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:5224},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5318}],headersStr:"不完美的库类 问题原因 解决方法 收益 何时忽略 重构方法说明 引入外加函数(Introduce Foreign Method) 引入本地扩展(Introduce Local Extension) 中间人 问题原因 解决方法 收益 何时忽略 重构方法说明 移除中间人(Remove Middle Man) 依恋情结 问题原因 解决方法 收益 何时忽略 重构方法说明 搬移函数(Move Method) 提炼函数(Extract Method) 狎昵关系 问题原因 解决方法 收益 重构方法说明 搬移函数(Move Method) 搬移字段(Move Field) 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional) 提炼类(Extract Class) 隐藏委托关系(Hide Delegate) 以委托取代继承(Replace Inheritance with Delegation) 过度耦合的消息链 问题原因 解决方法 收益 何时忽略 重构方法说明 隐藏委托关系(Hide Delegate) 提炼函数(Extract Method) 搬移函数(Move Method) 扩展阅读 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/couplers\n> \n> 耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。\n\n\n# 不完美的库类\n\n> 不完美的库类(Incomplete Library Class)\n> \n> 当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。\n\n\n# 问题原因\n\n许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。\n\n\n# 解决方法\n\n * 如果你只想修改类库的一两个函数，可以运用 引入外加函数(Introduce Foreign Method)；\n * 如果想要添加一大堆额外行为，就得运用 引入本地扩展(Introduce Local Extension) 。\n\n\n# 收益\n\n * 减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）\n\n\n# 何时忽略\n\n * 如果扩展库会带来额外的工作量。\n\n\n# 重构方法说明\n\n# 引入外加函数(Introduce Foreign Method)\n\n问题\n\n你需要为提供服务的类增加一个函数，但你无法修改这个类。\n\nclass Report {\n  //...\n  void sendReport() {\n    Date nextDay = new Date(previousEnd.getYear(),\n      previousEnd.getMonth(), previousEnd.getDate() + 1);\n    //...\n  }\n}\n\n\n解决\n\n在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。\n\nclass Report {\n  //...\n  void sendReport() {\n    Date newStart = nextDay(previousEnd);\n    //...\n  }\n  private static Date nextDay(Date arg) {\n    return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);\n  }\n}\n\n\n# 引入本地扩展(Introduce Local Extension)\n\n问题\n\n你需要为服务类提供一些额外函数，但你无法修改这个类。\n\n\n\n解决\n\n建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。\n\n\n\n\n# 中间人\n\n> 中间人(Middle Man)\n> \n> 如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？\n\n\n\n\n# 问题原因\n\n对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。\n\n\n# 解决方法\n\n应该运用 移除中间人(Remove Middle Man)，直接和真正负责的对象打交道。\n\n\n# 收益\n\n * 减少笨重的代码。\n\n\n\n\n# 何时忽略\n\n如果是以下情况，不要删除已创建的中间人：\n\n * 添加中间人是为了避免类之间依赖关系。\n * 一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。\n\n\n# 重构方法说明\n\n# 移除中间人(Remove Middle Man)\n\n问题\n\n某个类做了过多的简单委托动作。\n\n\n\n解决\n\n让客户直接调用委托类。\n\n\n\n\n# 依恋情结\n\n> 依恋情结(Feature Envy)\n> \n> 一个函数访问其它对象的数据比访问自己的数据更多。\n\n\n\n\n# 问题原因\n\n这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。\n\n\n# 解决方法\n\nAs a basic rule, if things change at the same time, you should keep them in the same place. Usually data and functions that use this data are changed together (although exceptions are possible).\n\n有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。\n\n\n\n * 如果一个函数明显应该被移到另一个地方，可运用 搬移函数(Move Method) 。\n * 如果仅仅是函数的部分代码访问另一个对象的数据，运用 提炼函数(Extract Method) 将这部分代码移到独立的函数中。\n * 如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 提炼函数(Extract Method) 将方法拆分为几个部分，可以放置在不同类中的不同位置。\n\n\n# 收益\n\n * 减少重复代码（如果数据处理的代码放在中心位置）。\n * 更好的代码组织性（处理数据的函数靠近实际数据）。\n\n\n\n\n# 何时忽略\n\n * 有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n\n# 狎昵关系\n\n> 狎昵关系(Inappropriate Intimacy)\n> \n> 一个类大量使用另一个类的内部字段和方法。\n\n\n\n\n# 问题原因\n\n类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。\n\n\n# 解决方法\n\n * 最简单的解决方法是运用 搬移函数(Move Method) 和 搬移字段(Move Field) 来让类之间斩断羁绊。\n\n\n\n * 你也可以看看是否能运用 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional) 让其中一个类对另一个说分手。\n\n * 如果这两个类实在是情比金坚，难分难舍，可以运用 提炼类(Extract Class) 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 隐藏委托关系(Hide Delegate) 让另一个类来为它们牵线搭桥。\n\n * 继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 以委托取代继承(Replace Inheritance with Delegation) 来让超类和子类分家。\n\n\n# 收益\n\n * 提高代码组织性。\n * 提高代码复用性。\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)\n\n问题\n\n两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。\n\n\n\n解决\n\n去除不必要的关联。\n\n\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 隐藏委托关系(Hide Delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 以委托取代继承(Replace Inheritance with Delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。\n\n\n\n\n# 过度耦合的消息链\n\n> 过度耦合的消息链(Message Chains)\n> \n> 消息链的形式类似于：obj.getA().getB().getC()。\n\n\n\n\n# 问题原因\n\n如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。\n\n\n# 解决方法\n\n * 可以运用 隐藏委托关系(Hide Delegate) 删除一个消息链。\n\n\n\n * 有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 提炼函数(Extract Method)把使用该对象的代码提炼到一个独立函数中，再运用 搬移函数(Move Method) 把这个函数推入消息链。\n\n\n# 收益\n\n * 能减少链中类之间的依赖。\n * 能减少代码量。\n\n\n\n\n# 何时忽略\n\n * 过于侵略性的委托可能会使程序员难以理解功能是如何触发的。\n\n\n# 重构方法说明\n\n# 隐藏委托关系(Hide Delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/couplers\n> \n> 耦合(couplers)这组坏味道意味着：不同类之间过度耦合。\n\n\n# 不完美的库类\n\n> 不完美的库类(incomplete library class)\n> \n> 当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。\n\n\n# 问题原因\n\n许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。\n\n\n# 解决方法\n\n * 如果你只想修改类库的一两个函数，可以运用 引入外加函数(introduce foreign method)；\n * 如果想要添加一大堆额外行为，就得运用 引入本地扩展(introduce local extension) 。\n\n\n# 收益\n\n * 减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）\n\n\n# 何时忽略\n\n * 如果扩展库会带来额外的工作量。\n\n\n# 重构方法说明\n\n# 引入外加函数(introduce foreign method)\n\n问题\n\n你需要为提供服务的类增加一个函数，但你无法修改这个类。\n\nclass report {\n  //...\n  void sendreport() {\n    date nextday = new date(previousend.getyear(),\n      previousend.getmonth(), previousend.getdate() + 1);\n    //...\n  }\n}\n\n\n解决\n\n在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。\n\nclass report {\n  //...\n  void sendreport() {\n    date newstart = nextday(previousend);\n    //...\n  }\n  private static date nextday(date arg) {\n    return new date(arg.getyear(), arg.getmonth(), arg.getdate() + 1);\n  }\n}\n\n\n# 引入本地扩展(introduce local extension)\n\n问题\n\n你需要为服务类提供一些额外函数，但你无法修改这个类。\n\n\n\n解决\n\n建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。\n\n\n\n\n# 中间人\n\n> 中间人(middle man)\n> \n> 如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？\n\n\n\n\n# 问题原因\n\n对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。\n\n\n# 解决方法\n\n应该运用 移除中间人(remove middle man)，直接和真正负责的对象打交道。\n\n\n# 收益\n\n * 减少笨重的代码。\n\n\n\n\n# 何时忽略\n\n如果是以下情况，不要删除已创建的中间人：\n\n * 添加中间人是为了避免类之间依赖关系。\n * 一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。\n\n\n# 重构方法说明\n\n# 移除中间人(remove middle man)\n\n问题\n\n某个类做了过多的简单委托动作。\n\n\n\n解决\n\n让客户直接调用委托类。\n\n\n\n\n# 依恋情结\n\n> 依恋情结(feature envy)\n> \n> 一个函数访问其它对象的数据比访问自己的数据更多。\n\n\n\n\n# 问题原因\n\n这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。\n\n\n# 解决方法\n\nas a basic rule, if things change at the same time, you should keep them in the same place. usually data and functions that use this data are changed together (although exceptions are possible).\n\n有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。\n\n\n\n * 如果一个函数明显应该被移到另一个地方，可运用 搬移函数(move method) 。\n * 如果仅仅是函数的部分代码访问另一个对象的数据，运用 提炼函数(extract method) 将这部分代码移到独立的函数中。\n * 如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 提炼函数(extract method) 将方法拆分为几个部分，可以放置在不同类中的不同位置。\n\n\n# 收益\n\n * 减少重复代码（如果数据处理的代码放在中心位置）。\n * 更好的代码组织性（处理数据的函数靠近实际数据）。\n\n\n\n\n# 何时忽略\n\n * 有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n\n# 狎昵关系\n\n> 狎昵关系(inappropriate intimacy)\n> \n> 一个类大量使用另一个类的内部字段和方法。\n\n\n\n\n# 问题原因\n\n类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。\n\n\n# 解决方法\n\n * 最简单的解决方法是运用 搬移函数(move method) 和 搬移字段(move field) 来让类之间斩断羁绊。\n\n\n\n * 你也可以看看是否能运用 将双向关联改为单向关联(change bidirectional association to unidirectional) 让其中一个类对另一个说分手。\n\n * 如果这两个类实在是情比金坚，难分难舍，可以运用 提炼类(extract class) 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 隐藏委托关系(hide delegate) 让另一个类来为它们牵线搭桥。\n\n * 继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 以委托取代继承(replace inheritance with delegation) 来让超类和子类分家。\n\n\n# 收益\n\n * 提高代码组织性。\n * 提高代码复用性。\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将双向关联改为单向关联(change bidirectional association to unidirectional)\n\n问题\n\n两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。\n\n\n\n解决\n\n去除不必要的关联。\n\n\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 隐藏委托关系(hide delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 以委托取代继承(replace inheritance with delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。\n\n\n\n\n# 过度耦合的消息链\n\n> 过度耦合的消息链(message chains)\n> \n> 消息链的形式类似于：obj.geta().getb().getc()。\n\n\n\n\n# 问题原因\n\n如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getthis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。\n\n\n# 解决方法\n\n * 可以运用 隐藏委托关系(hide delegate) 删除一个消息链。\n\n\n\n * 有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 提炼函数(extract method)把使用该对象的代码提炼到一个独立函数中，再运用 搬移函数(move method) 把这个函数推入消息链。\n\n\n# 收益\n\n * 能减少链中类之间的依赖。\n * 能减少代码量。\n\n\n\n\n# 何时忽略\n\n * 过于侵略性的委托可能会使程序员难以理解功能是如何触发的。\n\n\n# 重构方法说明\n\n# 隐藏委托关系(hide delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"重构",frontmatter:{title:"重构",date:"2021-04-29T16:05:03.000Z",categories:["设计","重构"],tags:["设计","重构"],permalink:"/pages/d200c3/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/",relativePath:"03.设计/03.重构/README.md",key:"v-45cada9f",path:"/pages/d200c3/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:68},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:163},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:224}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 重构\n\n> 重构是不改变软件系统外部行为的前提下，改善它的内部结构。\n> \n> 重构的目的是为了提高代码的质量和性能。\n\n\n\n\n# 📖 内容\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * 重构教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 重构\n\n> 重构是不改变软件系统外部行为的前提下，改善它的内部结构。\n> \n> 重构的目的是为了提高代码的质量和性能。\n\n\n\n\n# 📖 内容\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * 重构教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"领域驱动设计简介",frontmatter:{title:"领域驱动设计简介",date:"2020-08-10T10:59:18.000Z",categories:["设计","DDD"],tags:["设计","DDD"],permalink:"/pages/86db92/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/04.DDD/01.%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B.html",relativePath:"03.设计/04.DDD/01.领域驱动设计简介.md",key:"v-1add83e9",path:"/pages/86db92/",headers:[{level:2,title:"DDD 简介",slug:"ddd-简介",normalizedTitle:"ddd 简介",charIndex:15},{level:3,title:"软件架构模式的演进",slug:"软件架构模式的演进",normalizedTitle:"软件架构模式的演进",charIndex:26},{level:3,title:"什么是 DDD",slug:"什么是-ddd",normalizedTitle:"什么是 ddd",charIndex:369},{level:3,title:"DDD 与微服务的关系",slug:"ddd-与微服务的关系",normalizedTitle:"ddd 与微服务的关系",charIndex:688},{level:2,title:"DDD 核心概念",slug:"ddd-核心概念",normalizedTitle:"ddd 核心概念",charIndex:931},{level:3,title:"域",slug:"域",normalizedTitle:"域",charIndex:3},{level:3,title:"通用语言和上下文边界",slug:"通用语言和上下文边界",normalizedTitle:"通用语言和上下文边界",charIndex:1351},{level:3,title:"实体和值对象",slug:"实体和值对象",normalizedTitle:"实体和值对象",charIndex:1605},{level:3,title:"聚合和聚合跟",slug:"聚合和聚合跟",normalizedTitle:"聚合和聚合跟",charIndex:1887},{level:4,title:"聚合设计步骤",slug:"聚合设计步骤",normalizedTitle:"聚合设计步骤",charIndex:2214},{level:4,title:"聚合设计原则",slug:"聚合设计原则",normalizedTitle:"聚合设计原则",charIndex:2512},{level:2,title:"架构模型",slug:"架构模型",normalizedTitle:"架构模型",charIndex:2609},{level:3,title:"DDD 架构",slug:"ddd-架构",normalizedTitle:"ddd 架构",charIndex:2618},{level:3,title:"整洁架构",slug:"整洁架构",normalizedTitle:"整洁架构",charIndex:2745},{level:3,title:"六边形架构",slug:"六边形架构",normalizedTitle:"六边形架构",charIndex:2906},{level:3,title:"三种架构对比",slug:"三种架构对比",normalizedTitle:"三种架构对比",charIndex:3249},{level:4,title:"架构模型和中台、微服务的联系",slug:"架构模型和中台、微服务的联系",normalizedTitle:"架构模型和中台、微服务的联系",charIndex:3296},{level:4,title:"中台建设要聚焦领域模型",slug:"中台建设要聚焦领域模型",normalizedTitle:"中台建设要聚焦领域模型",charIndex:3465},{level:4,title:"微服务要有合理的架构分层",slug:"微服务要有合理的架构分层",normalizedTitle:"微服务要有合理的架构分层",charIndex:3642},{level:4,title:"应用和资源的解耦与适配",slug:"应用和资源的解耦与适配",normalizedTitle:"应用和资源的解耦与适配",charIndex:3783},{level:2,title:"中台战略",slug:"中台战略",normalizedTitle:"中台战略",charIndex:3898},{level:3,title:"平台不是中台",slug:"平台不是中台",normalizedTitle:"平台不是中台",charIndex:3907},{level:3,title:"什么是中台",slug:"什么是中台",normalizedTitle:"什么是中台",charIndex:4222},{level:3,title:"数字化转型中台",slug:"数字化转型中台",normalizedTitle:"数字化转型中台",charIndex:4481},{level:3,title:"前中后台协同",slug:"前中后台协同",normalizedTitle:"前中后台协同",charIndex:4493},{level:4,title:"前台",slug:"前台",normalizedTitle:"前台",charIndex:4120},{level:4,title:"中台",slug:"中台",normalizedTitle:"中台",charIndex:3301},{level:4,title:"后台",slug:"后台",normalizedTitle:"后台",charIndex:4095},{level:3,title:"DDD、中台和微服务的协作",slug:"ddd、中台和微服务的协作",normalizedTitle:"ddd、中台和微服务的协作",charIndex:5273},{level:3,title:"如何构建中台",slug:"如何构建中台",normalizedTitle:"如何构建中台",charIndex:5368},{level:4,title:"自顶向下策略",slug:"自顶向下策略",normalizedTitle:"自顶向下策略",charIndex:5378},{level:4,title:"自顶向下策略",slug:"自顶向下策略-2",normalizedTitle:"自顶向下策略",charIndex:5378},{level:4,title:"构建步骤",slug:"构建步骤",normalizedTitle:"构建步骤",charIndex:5658},{level:2,title:"边界",slug:"边界",normalizedTitle:"边界",charIndex:478},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6021}],headersStr:"DDD 简介 软件架构模式的演进 什么是 DDD DDD 与微服务的关系 DDD 核心概念 域 通用语言和上下文边界 实体和值对象 聚合和聚合跟 聚合设计步骤 聚合设计原则 架构模型 DDD 架构 整洁架构 六边形架构 三种架构对比 架构模型和中台、微服务的联系 中台建设要聚焦领域模型 微服务要有合理的架构分层 应用和资源的解耦与适配 中台战略 平台不是中台 什么是中台 数字化转型中台 前中后台协同 前台 中台 后台 DDD、中台和微服务的协作 如何构建中台 自顶向下策略 自顶向下策略 构建步骤 边界 参考资料",content:"# 领域驱动设计简介\n\n\n# DDD 简介\n\n\n# 软件架构模式的演进\n\n**第一阶段是单机架构：**采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。\n\n**第二阶段是集中式架构：**采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。\n\n**第三阶段是分布式微服务架构：**随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。\n\n在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。\n\n\n# 什么是 DDD\n\nDDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。DDD 分为两个思维层面：\n\n * 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的上下文边界，上下文边界可以作为微服务设计的参考边界。\n * 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。\n\n\n# DDD 与微服务的关系\n\nDDD 是一种架构设计方法，微服务是一种架构风格。两者都是为了拆解业务复杂度：合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。\n\nDDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。\n\n微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。\n\n\n# DDD 核心概念\n\n\n\n\n# 域\n\n * 领域：领域具体指一种特定的范围。领域是用来限定业务边界的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。\n * 子域：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。\n * 核心域：决定产品和公司核心竞争力的子域是核心域。\n * 通用域：同时被多个子域使用的通用功能子域是通用域。\n * 支撑域：还有一种功能子域是必需的，但既非核心域也非通用域，它就是支撑域。\n\n> 领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。\n> \n> 核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。\n\n\n# 通用语言和上下文边界\n\n通用语言：通过团队交流达成共识性的，能够简单、清晰、准确描述业务涵义和规则的语言。\n\n上下文边界：限界就是领域的边界，而上下文则是语义环境。通过领域的上下文边界，我们就可以在统一的领域边界内用统一的语言进行交流。综合一下，上下文边界的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。\n\n\n# 实体和值对象\n\n实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。\n\n本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。\n\n\n# 聚合和聚合跟\n\n领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。\n\n聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。\n\n聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。\n\n\n\n# 聚合设计步骤\n\n * 第 1 步：采用事件风暴，根据业务行为，梳理出所有的实体和值对象。\n * 第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体 是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？ 是否可以创建或修改其它对象？是否有专门的模块来管这个实体。\n * 第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值 对象。\n * 第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。\n * 第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。\n\n# 聚合设计原则\n\n * 在一致性边界内建模真正的不变条件。\n * 设计小聚合。\n * 通过唯一标识引用其它聚合。\n * 在边界之外使用最终一致性。\n * 通过应用层实现跨聚合的服务调用。\n\n\n# 架构模型\n\n\n# DDD 架构\n\n\n\n三层架构向 DDD 分层架构演进，主要发生在业务逻辑层和数据访问层。\n\nDDD 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。\n\n\n# 整洁架构\n\n在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。\n\n整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。\n\n\n\n\n# 六边形架构\n\n六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 API 网关盛行的主要原因吧。\n\n也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 APP、Web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。\n\n六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：\n\n红圈内的六边形实现应用的核心业务逻辑；\n\n外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 API 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。\n\n\n# 三种架构对比\n\n这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现。\n\n\n\n# 架构模型和中台、微服务的联系\n\n中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 DDD 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。\n\nDDD、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为 一个理论体系用于你的中台和微服务设计。\n\n# 中台建设要聚焦领域模型\n\n中台需要站在全企业的高度考虑能力的共享和复用。\n\n中台设计时，我们需要建立中台内所有限界上下文的领域模型，DDD 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。\n\n# 微服务要有合理的架构分层\n\n微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。\n\n不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。\n\n# 应用和资源的解耦与适配\n\n传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。\n\n正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。\n\n\n# 中台战略\n\n\n# 平台不是中台\n\n中台源于平台，但它的战略高度要比平台高很多。\n\n平台只是将部分通用的公共能力独立为共享平台。虽然可以通过 API 或者数据对外提供公共共享服务，解决系统重复建设的问题，但这类平台并没有和企业内的其它平台或应用，实现页面、业务流程和数据从前端到后端的全面融合，并且没有将核心业务服务链路作为一个整体方案考虑，各平台仍然是分离且独立的。\n\n简单的理解就是把传统的前后台体系中的后台进行了细分。阿里巴巴提出了大中台小前台的战略。就是强化业务和技术中台，把前端的应用变得更小更灵活。当中台越强大，能力就越强，越能更好的快速响应前台的业务需求。打个比喻，就是土壤越肥沃，越适合生长不同的生物，打造好的生态系统。\n\n\n\n\n# 什么是中台\n\n中台是一个基础的理念和架构，我们要把所有的基础服务用中台的思路建设，进行联通，共同支持上端的业务。业务中台更多的是支持在线业务，数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用。业务中台、数据中台、算法中台等等一起提供对上层业务的支撑。\n\n中台的关键词：共享、联通、融合和创新。联通是前台以及中台之间的联通，融合是前台流程和数据的融合，并以共享的方式支持前端一线业务的发展和创新。其中最关键的是快速响应能力和企业级的无缝联通和融合能力，尤其是对于跨业经营的超大型企业来说至关重要。\n\n\n# 数字化转型中台\n\n\n# 前中后台协同\n\n# 前台\n\n在前台设计中我们可以借鉴微前端的设计思想，在企业内不仅实现前端解耦和复用，还可以根据核心链路和业务流程，通过对微前端页面的动态组合和流程编排，实现前台业务的融合。\n\n前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中，实现前端页面、流程和功能复用。\n\n# 中台\n\n业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。\n\n同样的，我们可以将核心能力用微服务架构模式，建设成为可面向不同渠道和场景的可复用的核心能力中台。 业务中台向前台、第三方和其它中台提供 API 服务，实现通用能力和核心能力的复用。\n\n数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：\n\n * 一是完成企业全域数据的采集与存储，实现各不同业务类别中台数据的汇总和集中管理。\n * 二是按照标准的数据规范或数据模型，将数据按照不同主题域或场景进行加工和处理，形成面向不同主题和场景的数据应用，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系。\n * 三是建立业务需求驱动的数据体系，基于各个维度的数据，深度萃取数据价值，支持业务和商业模式的创新。\n\n相应的，数据中台的建设就可分为三步走：\n\n * 第一步实现各中台业务数据的汇集，解决数据孤岛和初级数据共享问题。\n * 第二步实现企业级实时或非实时全维度数据的深度融合、加工和共享。\n * 第三步萃取数据价值，支持业务创新，加速从数据转换为业务价值的过程。\n\n# 后台\n\n前台主要面向客户以及终端销售者，实现营销推广以及交易转化；中台主要面向运营人员，完成运营支撑；后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 OA 等系统。\n\n\n# DDD、中台和微服务的协作\n\n传统企业可以将需要共享的公共能力进行领域建模，建设可共享的通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的核心中台。\n\n\n# 如何构建中台\n\n# 自顶向下策略\n\n自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。\n\n# 自顶向下策略\n\n自底向上策略适用于遗留系统业务模型的演进式重构。这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。\n\n# 构建步骤\n\n第一步：锁定系统所在业务域，构建领域模型。\n\n\n\n第二步：对齐业务域，构建中台业务模型。\n\n第三步：中台归类，根据领域模型设计微服务。\n\n\n# 边界\n\n逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。\n\n物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。\n\n代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。\n\n通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。\n\n\n# 参考资料\n\n * DDD 实战课",normalizedContent:"# 领域驱动设计简介\n\n\n# ddd 简介\n\n\n# 软件架构模式的演进\n\n**第一阶段是单机架构：**采用面向过程的设计方法，系统包括客户端 ui 层和数据库两层，采用 c/s 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。\n\n**第二阶段是集中式架构：**采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 soa 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。\n\n**第三阶段是分布式微服务架构：**随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。\n\n在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。\n\n\n# 什么是 ddd\n\nddd 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。ddd 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。ddd 分为两个思维层面：\n\n * 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的上下文边界，上下文边界可以作为微服务设计的参考边界。\n * 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。\n\n\n# ddd 与微服务的关系\n\nddd 是一种架构设计方法，微服务是一种架构风格。两者都是为了拆解业务复杂度：合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。\n\nddd 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。\n\n微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。\n\n\n# ddd 核心概念\n\n\n\n\n# 域\n\n * 领域：领域具体指一种特定的范围。领域是用来限定业务边界的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。\n * 子域：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。\n * 核心域：决定产品和公司核心竞争力的子域是核心域。\n * 通用域：同时被多个子域使用的通用功能子域是通用域。\n * 支撑域：还有一种功能子域是必需的，但既非核心域也非通用域，它就是支撑域。\n\n> 领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。\n> \n> 核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。\n\n\n# 通用语言和上下文边界\n\n通用语言：通过团队交流达成共识性的，能够简单、清晰、准确描述业务涵义和规则的语言。\n\n上下文边界：限界就是领域的边界，而上下文则是语义环境。通过领域的上下文边界，我们就可以在统一的领域边界内用统一的语言进行交流。综合一下，上下文边界的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。\n\n\n# 实体和值对象\n\n实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。\n\n本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。\n\n\n# 聚合和聚合跟\n\n领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。\n\n聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。\n\n聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。\n\n\n\n# 聚合设计步骤\n\n * 第 1 步：采用事件风暴，根据业务行为，梳理出所有的实体和值对象。\n * 第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体 是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 id？ 是否可以创建或修改其它对象？是否有专门的模块来管这个实体。\n * 第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值 对象。\n * 第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。\n * 第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。\n\n# 聚合设计原则\n\n * 在一致性边界内建模真正的不变条件。\n * 设计小聚合。\n * 通过唯一标识引用其它聚合。\n * 在边界之外使用最终一致性。\n * 通过应用层实现跨聚合的服务调用。\n\n\n# 架构模型\n\n\n# ddd 架构\n\n\n\n三层架构向 ddd 分层架构演进，主要发生在业务逻辑层和数据访问层。\n\nddd 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。\n\n\n# 整洁架构\n\n在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。\n\n整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。\n\n\n\n\n# 六边形架构\n\n六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 api 网关盛行的主要原因吧。\n\n也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 app、web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。\n\n六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：\n\n红圈内的六边形实现应用的核心业务逻辑；\n\n外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 api 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。\n\n\n# 三种架构对比\n\n这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现。\n\n\n\n# 架构模型和中台、微服务的联系\n\n中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 ddd 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。\n\nddd、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为 一个理论体系用于你的中台和微服务设计。\n\n# 中台建设要聚焦领域模型\n\n中台需要站在全企业的高度考虑能力的共享和复用。\n\n中台设计时，我们需要建立中台内所有限界上下文的领域模型，ddd 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。\n\n# 微服务要有合理的架构分层\n\n微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。\n\n不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。\n\n# 应用和资源的解耦与适配\n\n传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。\n\n正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。\n\n\n# 中台战略\n\n\n# 平台不是中台\n\n中台源于平台，但它的战略高度要比平台高很多。\n\n平台只是将部分通用的公共能力独立为共享平台。虽然可以通过 api 或者数据对外提供公共共享服务，解决系统重复建设的问题，但这类平台并没有和企业内的其它平台或应用，实现页面、业务流程和数据从前端到后端的全面融合，并且没有将核心业务服务链路作为一个整体方案考虑，各平台仍然是分离且独立的。\n\n简单的理解就是把传统的前后台体系中的后台进行了细分。阿里巴巴提出了大中台小前台的战略。就是强化业务和技术中台，把前端的应用变得更小更灵活。当中台越强大，能力就越强，越能更好的快速响应前台的业务需求。打个比喻，就是土壤越肥沃，越适合生长不同的生物，打造好的生态系统。\n\n\n\n\n# 什么是中台\n\n中台是一个基础的理念和架构，我们要把所有的基础服务用中台的思路建设，进行联通，共同支持上端的业务。业务中台更多的是支持在线业务，数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用。业务中台、数据中台、算法中台等等一起提供对上层业务的支撑。\n\n中台的关键词：共享、联通、融合和创新。联通是前台以及中台之间的联通，融合是前台流程和数据的融合，并以共享的方式支持前端一线业务的发展和创新。其中最关键的是快速响应能力和企业级的无缝联通和融合能力，尤其是对于跨业经营的超大型企业来说至关重要。\n\n\n# 数字化转型中台\n\n\n# 前中后台协同\n\n# 前台\n\n在前台设计中我们可以借鉴微前端的设计思想，在企业内不仅实现前端解耦和复用，还可以根据核心链路和业务流程，通过对微前端页面的动态组合和流程编排，实现前台业务的融合。\n\n前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中，实现前端页面、流程和功能复用。\n\n# 中台\n\n业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。\n\n同样的，我们可以将核心能力用微服务架构模式，建设成为可面向不同渠道和场景的可复用的核心能力中台。 业务中台向前台、第三方和其它中台提供 api 服务，实现通用能力和核心能力的复用。\n\n数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：\n\n * 一是完成企业全域数据的采集与存储，实现各不同业务类别中台数据的汇总和集中管理。\n * 二是按照标准的数据规范或数据模型，将数据按照不同主题域或场景进行加工和处理，形成面向不同主题和场景的数据应用，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系。\n * 三是建立业务需求驱动的数据体系，基于各个维度的数据，深度萃取数据价值，支持业务和商业模式的创新。\n\n相应的，数据中台的建设就可分为三步走：\n\n * 第一步实现各中台业务数据的汇集，解决数据孤岛和初级数据共享问题。\n * 第二步实现企业级实时或非实时全维度数据的深度融合、加工和共享。\n * 第三步萃取数据价值，支持业务创新，加速从数据转换为业务价值的过程。\n\n# 后台\n\n前台主要面向客户以及终端销售者，实现营销推广以及交易转化；中台主要面向运营人员，完成运营支撑；后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 oa 等系统。\n\n\n# ddd、中台和微服务的协作\n\n传统企业可以将需要共享的公共能力进行领域建模，建设可共享的通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的核心中台。\n\n\n# 如何构建中台\n\n# 自顶向下策略\n\n自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。\n\n# 自顶向下策略\n\n自底向上策略适用于遗留系统业务模型的演进式重构。这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。\n\n# 构建步骤\n\n第一步：锁定系统所在业务域，构建领域模型。\n\n\n\n第二步：对齐业务域，构建中台业务模型。\n\n第三步：中台归类，根据领域模型设计微服务。\n\n\n# 边界\n\n逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。\n\n物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。\n\n代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。\n\n通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。\n\n\n# 参考资料\n\n * ddd 实战课",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"UML 快速入门",frontmatter:{title:"UML 快速入门",date:"2019-03-06T00:00:00.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/ae1396/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/11.UML/01.UML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"03.设计/11.UML/01.UML快速入门.md",key:"v-90dacde0",path:"/pages/ae1396/",headers:[{level:2,title:"UML 简介",slug:"uml-简介",normalizedTitle:"uml 简介",charIndex:15},{level:3,title:"UML 图类型",slug:"uml-图类型",normalizedTitle:"uml 图类型",charIndex:26},{level:4,title:"结构式建模图",slug:"结构式建模图",normalizedTitle:"结构式建模图",charIndex:54},{level:4,title:"行为式建模图",slug:"行为式建模图",normalizedTitle:"行为式建模图",charIndex:227},{level:3,title:"UML 概念",slug:"uml-概念",normalizedTitle:"uml 概念",charIndex:410},{level:2,title:"UML 工具",slug:"uml-工具",normalizedTitle:"uml 工具",charIndex:680},{level:3,title:"亿图",slug:"亿图",normalizedTitle:"亿图",charIndex:742},{level:3,title:"Visio",slug:"visio",normalizedTitle:"visio",charIndex:816},{level:3,title:"StarUML",slug:"staruml",normalizedTitle:"staruml",charIndex:868},{level:3,title:"Astah",slug:"astah",normalizedTitle:"astah",charIndex:920},{level:3,title:"ArgoUML",slug:"argouml",normalizedTitle:"argouml",charIndex:965},{level:3,title:"ProcessOn",slug:"processon",normalizedTitle:"processon",charIndex:1006},{level:3,title:"drawio",slug:"drawio",normalizedTitle:"drawio",charIndex:1058},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1107}],headersStr:"UML 简介 UML 图类型 结构式建模图 行为式建模图 UML 概念 UML 工具 亿图 Visio StarUML Astah ArgoUML ProcessOn drawio 参考资料",content:"# UML 快速入门\n\n\n# UML 简介\n\n\n# UML 图类型\n\nUML 图类型如下图所示：\n\n\n\n# 结构式建模图\n\n> 结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n\n * 类图\n * 对象图\n * 包图\n * 组件图\n * 部署图\n * 复合结构图\n\n# 行为式建模图\n\n> 行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n\n * 活动图\n * 状态图\n * 用例图\n * 通信图\n * 交互概述图\n * 时序图\n * 时间图\n\n\n# UML 概念\n\nUML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。\n\n * 对于结构而言 - 执行者，属性，类，元件，接口，对象，包。\n * 对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。\n * 对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。\n * 其他概念\n   * 构造型—这规范符号应用到的模型\n   * 多重性—多重性标记法与资料库建模基数对应，例如：1, 0..1, 1..*\n\n\n# UML 工具\n\nUML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：\n\n\n# 亿图\n\n> 国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。\n> \n> 亿图官网\n\n\n\n\n# Visio\n\n> Office 的绘图工具，特点是简单、清晰。\n> \n> Visio 官网\n\n\n\n\n# StarUML\n\n> 样式精美，功能全面的 UML 工具。\n> \n> StarUML 官网\n\n\n\n\n# Astah\n\n> 样式不错，功能全面的绘图工具。\n> \n> Astah 官网\n\n\n\n\n# ArgoUML\n\n> UML 工具。\n> \n> ArgoUML 官网\n\n\n\n\n# ProcessOn\n\n> 在线绘图工具，特点是简洁、清晰。\n> \n> ProcessOn 官网\n\n\n# drawio\n\n> 开源的在线绘图工具，特点是简洁、清晰。\n> \n> drawio 官网\n\n\n# 参考资料\n\n * Wiki-UML\n * Sparx UML 教程\n * OMG UML\n * UML Tutorial\n * W3Cschool UML 教程\n * UML 学习入门就这一篇文章\n * http://www.cnblogs.com/ywqu/category/223486.html",normalizedContent:"# uml 快速入门\n\n\n# uml 简介\n\n\n# uml 图类型\n\numl 图类型如下图所示：\n\n\n\n# 结构式建模图\n\n> 结构式建模图（structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n\n * 类图\n * 对象图\n * 包图\n * 组件图\n * 部署图\n * 复合结构图\n\n# 行为式建模图\n\n> 行为式建模图（behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n\n * 活动图\n * 状态图\n * 用例图\n * 通信图\n * 交互概述图\n * 时序图\n * 时间图\n\n\n# uml 概念\n\numl 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。\n\n * 对于结构而言 - 执行者，属性，类，元件，接口，对象，包。\n * 对于行为而言 - 活动（uml），事件（uml），消息（uml），方法（uml），操作（uml），状态（uml），用例（uml）。\n * 对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。\n * 其他概念\n   * 构造型—这规范符号应用到的模型\n   * 多重性—多重性标记法与资料库建模基数对应，例如：1, 0..1, 1..*\n\n\n# uml 工具\n\numl 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 uml 工具：\n\n\n# 亿图\n\n> 国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。\n> \n> 亿图官网\n\n\n\n\n# visio\n\n> office 的绘图工具，特点是简单、清晰。\n> \n> visio 官网\n\n\n\n\n# staruml\n\n> 样式精美，功能全面的 uml 工具。\n> \n> staruml 官网\n\n\n\n\n# astah\n\n> 样式不错，功能全面的绘图工具。\n> \n> astah 官网\n\n\n\n\n# argouml\n\n> uml 工具。\n> \n> argouml 官网\n\n\n\n\n# processon\n\n> 在线绘图工具，特点是简洁、清晰。\n> \n> processon 官网\n\n\n# drawio\n\n> 开源的在线绘图工具，特点是简洁、清晰。\n> \n> drawio 官网\n\n\n# 参考资料\n\n * wiki-uml\n * sparx uml 教程\n * omg uml\n * uml tutorial\n * w3cschool uml 教程\n * uml 学习入门就这一篇文章\n * http://www.cnblogs.com/ywqu/category/223486.html",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"UML 结构建模图",frontmatter:{title:"UML 结构建模图",date:"2018-10-26T17:39:34.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/dd5922/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/11.UML/02.UML%E7%BB%93%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9B%BE.html",relativePath:"03.设计/11.UML/02.UML结构建模图.md",key:"v-7781c0b6",path:"/pages/dd5922/",headers:[{level:2,title:"部署图",slug:"部署图",normalizedTitle:"部署图",charIndex:104},{level:3,title:"节点",slug:"节点",normalizedTitle:"节点",charIndex:223},{level:3,title:"节点实例",slug:"节点实例",normalizedTitle:"节点实例",charIndex:270},{level:3,title:"节点构造型",slug:"节点构造型",normalizedTitle:"节点构造型",charIndex:365},{level:3,title:"工件",slug:"工件",normalizedTitle:"工件",charIndex:552},{level:3,title:"关联",slug:"关联",normalizedTitle:"关联",charIndex:82},{level:3,title:"作为容器的节点",slug:"作为容器的节点",normalizedTitle:"作为容器的节点",charIndex:740},{level:2,title:"组件图",slug:"组件图",normalizedTitle:"组件图",charIndex:109},{level:3,title:"表现组件",slug:"表现组件",normalizedTitle:"表现组件",charIndex:1168},{level:3,title:"装配连接器",slug:"装配连接器",normalizedTitle:"装配连接器",charIndex:949},{level:3,title:"带端口组件",slug:"带端口组件",normalizedTitle:"带端口组件",charIndex:1323},{level:2,title:"包图",slug:"包图",normalizedTitle:"包图",charIndex:114},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:118},{level:3,title:"类（Classes）",slug:"类-classes",normalizedTitle:"类（classes）",charIndex:2371},{level:3,title:"类的标柱（Class Notation）",slug:"类的标柱-class-notation",normalizedTitle:"类的标柱（class notation）",charIndex:2452},{level:3,title:"接口（Interfaces）",slug:"接口-interfaces",normalizedTitle:"接口（interfaces）",charIndex:2746},{level:3,title:"表（Tables）",slug:"表-tables",normalizedTitle:"表（tables）",charIndex:2918},{level:3,title:"关联（Associations）",slug:"关联-associations",normalizedTitle:"关联（associations）",charIndex:3119},{level:3,title:"泛化（Generalizations）",slug:"泛化-generalizations",normalizedTitle:"泛化（generalizations）",charIndex:2143},{level:3,title:"聚合（Aggregations）",slug:"聚合-aggregations",normalizedTitle:"聚合（aggregations）",charIndex:3518},{level:3,title:"关联类（Association Classes）",slug:"关联类-association-classes",normalizedTitle:"关联类（association classes）",charIndex:3963},{level:3,title:"依赖（Dependencies）",slug:"依赖-dependencies",normalizedTitle:"依赖（dependencies）",charIndex:4169},{level:3,title:"跟踪（Traces）",slug:"跟踪-traces",normalizedTitle:"跟踪（traces）",charIndex:4352},{level:3,title:"实现（Realizations）",slug:"实现-realizations",normalizedTitle:"实现（realizations）",charIndex:4490},{level:3,title:"嵌套（Nestings）",slug:"嵌套-nestings",normalizedTitle:"嵌套（nestings）",charIndex:4667},{level:2,title:"复合结构图",slug:"复合结构图",normalizedTitle:"复合结构图",charIndex:122},{level:3,title:"部件",slug:"部件",normalizedTitle:"部件",charIndex:3667},{level:3,title:"端口",slug:"端口",normalizedTitle:"端口",charIndex:1324},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:61},{level:3,title:"委托",slug:"委托",normalizedTitle:"委托",charIndex:5559},{level:3,title:"协作",slug:"协作",normalizedTitle:"协作",charIndex:1703},{level:3,title:"角色绑定",slug:"角色绑定",normalizedTitle:"角色绑定",charIndex:5773},{level:3,title:"表现",slug:"表现",normalizedTitle:"表现",charIndex:1168},{level:2,title:"对象图",slug:"对象图",normalizedTitle:"对象图",charIndex:129},{level:3,title:"类和对象元素",slug:"类和对象元素",normalizedTitle:"类和对象元素",charIndex:6074},{level:3,title:"运行状态",slug:"运行状态",normalizedTitle:"运行状态",charIndex:6188},{level:3,title:"类和对象图示例",slug:"类和对象图示例",normalizedTitle:"类和对象图示例",charIndex:6259},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6392}],headersStr:"部署图 节点 节点实例 节点构造型 工件 关联 作为容器的节点 组件图 表现组件 装配连接器 带端口组件 包图 类图 类（Classes） 类的标柱（Class Notation） 接口（Interfaces） 表（Tables） 关联（Associations） 泛化（Generalizations） 聚合（Aggregations） 关联类（Association Classes） 依赖（Dependencies） 跟踪（Traces） 实现（Realizations） 嵌套（Nestings） 复合结构图 部件 端口 接口 委托 协作 角色绑定 表现 对象图 类和对象元素 运行状态 类和对象图示例 参考资料",content:'# UML 结构建模图\n\n> 结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素\'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n> \n> 关键词：部署图, 组件图, 包图, 类图, 复合结构图, 对象图\n\n\n# 部署图\n\n> 部署图（Deployment Diagram）用于对系统的物理结构建模。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。\n\n\n\n\n# 节点\n\n节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。\n\n\n\n\n# 节点实例\n\n图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。\n\n\n\n\n# 节点构造型\n\n为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。\n\n\n\n\n# 工件\n\n工件是软件开发过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。\n\n工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。\n\n\n\n\n# 关联\n\n在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，\n\n\n\n\n# 作为容器的节点\n\n节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。\n\n\n\n\n# 组件图\n\n> 组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。\n\n\n\n上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由"Product"和"Customer"的提供接口到由 "Order"指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 "Payment"需求接口。\n\n实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。\n\n\n# 表现组件\n\n组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。\n\n\n\n\n# 装配连接器\n\n装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。\n\n\n\n\n# 带端口组件\n\n使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。\n\n\n\n\n# 包图\n\n> 包图（Package Diagram）用来表现包和它所包含元素的组织。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。\n\n下面是一个包图的例子。\n\n\n\n包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。\n\n包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。\n\n\n\n在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。\n\n * 包的合并 - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。\n * 包的导入 - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。\n * 嵌套连接符 - 源包和目标包间的嵌套连接符说明目标包完全包含源包。\n\n\n# 类图\n\n> 类图（Class Diagram）展示了面向对象系统的构造模块。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。\n\n下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 "Account" 使用 "AddressBook"，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，"Contact" 和 "ContactGroup"值被包含在 "AddressBook"中。\n\n\n\n\n# 类（Classes）\n\n类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。\n\n\n# 类的标柱（Class Notation）\n\n类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。\n\n在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如："center" 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 "+"号，这个属性或操作是公共的 ; "-" 号则代表这个属性或操作是私有的。 "#"号是这个属性或操作被定义为保护的，" ~" 号代表包的可见性。\n\n\n\n\n# 接口（Interfaces）\n\n接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。\n\n\n\n接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。\n\n\n\n\n# 表（Tables）\n\n表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。\n\n\n\n\n# 关联（Associations）\n\n关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 "playsFor" 将变成"Player"类中的实例变量。\n\n\n\n\n# 泛化（Generalizations）\n\n泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 "Shape" 是抽象的，类名显示为斜体。\n\n\n\n下图显示了与上图相同信息的视图。\n\n\n\n\n# 聚合（Aggregations）\n\n聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。\n\n聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。\n\n下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。\n\n\n\n\n# 关联类（Association Classes）\n\n关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。\n\n\n\n\n# 依赖（Dependencies）\n\n依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。\n\n\n# 跟踪（Traces）\n\n跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。\n\n\n# 实现（Realizations）\n\n是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。\n\n\n\n\n# 嵌套（Nestings）\n\n嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。\n\n\n\n\n# 复合结构图\n\n> 复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。\n\n类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。\n\n\n\n\n# 部件\n\n部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。 部件在类或组件内部显示为不加修饰的方框。\n\n\n\n\n# 端口\n\n端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。 端口显示为所属类元边界指定的方框。\n\n\n\n\n# 接口\n\n接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。 当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。\n\n\n\n注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。 提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。\n\n\n\n\n# 委托\n\n委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。\n\n\n\n\n# 协作\n\n协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。 协作元素显示为椭圆。\n\n\n\n\n# 角色绑定\n\n角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。\n\n\n\n\n# 表现\n\n表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。\n\n\n\n发生 发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。\n\n\n\n\n# 对象图\n\n> 对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。\n\n\n# 类和对象元素\n\n下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。\n\n\n\n\n# 运行状态\n\n类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。\n\n\n\n\n# 类和对象图示例\n\n下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html\n * http://www.cnblogs.com/ywqu/category/223486.html',normalizedContent:'# uml 结构建模图\n\n> 结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素\'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n> \n> 关键词：部署图, 组件图, 包图, 类图, 复合结构图, 对象图\n\n\n# 部署图\n\n> 部署图（deployment diagram）用于对系统的物理结构建模。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。\n\n\n\n\n# 节点\n\n节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。\n\n\n\n\n# 节点实例\n\n图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。\n\n\n\n\n# 节点构造型\n\n为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。\n\n\n\n\n# 工件\n\n工件是软件开发过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。\n\n工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。\n\n\n\n\n# 关联\n\n在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，\n\n\n\n\n# 作为容器的节点\n\n节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。\n\n\n\n\n# 组件图\n\n> 组件图（component diagram）描绘了组成一个软件系统的模块和嵌入控件。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。\n\n\n\n上图演示了一些组件和它们的内部关系。装配连接器（assembly connectors）“连接”由"product"和"customer"的提供接口到由 "order"指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“order”需要的 "payment"需求接口。\n\n实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。\n\n\n# 表现组件\n\n组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。\n\n\n\n\n# 装配连接器\n\n装配连接器在组件 “component1”的需求接口和另一个组件 “component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。\n\n\n\n\n# 带端口组件\n\n使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。\n\n\n\n\n# 包图\n\n> 包图（package diagram）用来表现包和它所包含元素的组织。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 uml 元素。\n\n下面是一个包图的例子。\n\n\n\n包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。\n\n包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。\n\n\n\n在 uml2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。\n\n * 包的合并 - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。\n * 包的导入 - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。\n * 嵌套连接符 - 源包和目标包间的嵌套连接符说明目标包完全包含源包。\n\n\n# 类图\n\n> 类图（class diagram）展示了面向对象系统的构造模块。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。\n\n下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 "account" 使用 "addressbook"，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，"contact" 和 "contactgroup"值被包含在 "addressbook"中。\n\n\n\n\n# 类（classes）\n\n类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。\n\n\n# 类的标柱（class notation）\n\n类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。\n\n在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如："center" 属性显示初始化的值。最后面的分栏显示操作，如： setwidth，setlength 和 setposition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 "+"号，这个属性或操作是公共的 ; "-" 号则代表这个属性或操作是私有的。 "#"号是这个属性或操作被定义为保护的，" ~" 号代表包的可见性。\n\n\n\n\n# 接口（interfaces）\n\n接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。\n\n\n\n接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。\n\n\n\n\n# 表（tables）\n\n表尽管不是基本 uml 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«pk»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«fk»。\n\n\n\n\n# 关联（associations）\n\n关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 "playsfor" 将变成"player"类中的实例变量。\n\n\n\n\n# 泛化（generalizations）\n\n泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 "shape" 是抽象的，类名显示为斜体。\n\n\n\n下图显示了与上图相同信息的视图。\n\n\n\n\n# 聚合（aggregations）\n\n聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。\n\n聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。\n\n下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。\n\n\n\n\n# 关联类（association classes）\n\n关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。\n\n\n\n\n# 依赖（dependencies）\n\n依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。\n\n\n# 跟踪（traces）\n\n跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。\n\n\n# 实现（realizations）\n\n是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。\n\n\n\n\n# 嵌套（nestings）\n\n嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 ea 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。\n\n\n\n\n# 复合结构图\n\n> 复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。\n\n类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。\n\n\n\n\n# 部件\n\n部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。 部件在类或组件内部显示为不加修饰的方框。\n\n\n\n\n# 端口\n\n端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。 端口显示为所属类元边界指定的方框。\n\n\n\n\n# 接口\n\n接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。 当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。\n\n\n\n注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。 提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。\n\n\n\n\n# 委托\n\n委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。\n\n\n\n\n# 协作\n\n协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。 协作元素显示为椭圆。\n\n\n\n\n# 角色绑定\n\n角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。\n\n\n\n\n# 表现\n\n表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。\n\n\n\n发生 发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。\n\n\n\n\n# 对象图\n\n> 对象图（object diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。\n\n\n# 类和对象元素\n\n下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。\n\n\n\n\n# 运行状态\n\n类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。\n\n\n\n\n# 类和对象图示例\n\n下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html\n * http://www.cnblogs.com/ywqu/category/223486.html',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"UML 行为建模图",frontmatter:{title:"UML 行为建模图",date:"2018-10-17T13:25:36.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/0b8e4b/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/11.UML/03.UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.html",relativePath:"03.设计/11.UML/03.UML行为建模图.md",key:"v-5f40daea",path:"/pages/0b8e4b/",headers:[{level:2,title:"活动图",slug:"活动图",normalizedTitle:"活动图",charIndex:104},{level:3,title:"活动",slug:"活动",normalizedTitle:"活动",charIndex:104},{level:3,title:"动作",slug:"动作",normalizedTitle:"动作",charIndex:336},{level:3,title:"动作约束",slug:"动作约束",normalizedTitle:"动作约束",charIndex:396},{level:3,title:"控制流",slug:"控制流",normalizedTitle:"控制流",charIndex:439},{level:3,title:"初始节点",slug:"初始节点",normalizedTitle:"初始节点",charIndex:477},{level:3,title:"结束节点",slug:"结束节点",normalizedTitle:"结束节点",charIndex:510},{level:3,title:"对象和对象流",slug:"对象和对象流",normalizedTitle:"对象和对象流",charIndex:638},{level:3,title:"判断节点和合并节点",slug:"判断节点和合并节点",normalizedTitle:"判断节点和合并节点",charIndex:785},{level:3,title:"分叉和结合节点",slug:"分叉和结合节点",normalizedTitle:"分叉和结合节点",charIndex:880},{level:3,title:"扩展域",slug:"扩展域",normalizedTitle:"扩展域",charIndex:1091},{level:3,title:"异常处理器",slug:"异常处理器",normalizedTitle:"异常处理器",charIndex:1194},{level:3,title:"可中断活动区",slug:"可中断活动区",normalizedTitle:"可中断活动区",charIndex:1223},{level:3,title:"分割",slug:"分割",normalizedTitle:"分割",charIndex:1381},{level:2,title:"状态机图",slug:"状态机图",normalizedTitle:"状态机图",charIndex:109},{level:3,title:"状态",slug:"状态",normalizedTitle:"状态",charIndex:50},{level:3,title:"起始和结束状态",slug:"起始和结束状态",normalizedTitle:"起始和结束状态",charIndex:1882},{level:3,title:"转移",slug:"转移",normalizedTitle:"转移",charIndex:1762},{level:3,title:"状态活动",slug:"状态活动",normalizedTitle:"状态活动",charIndex:2155},{level:3,title:"自转移",slug:"自转移",normalizedTitle:"自转移",charIndex:2335},{level:3,title:"复合状态",slug:"复合状态",normalizedTitle:"复合状态",charIndex:2383},{level:3,title:"入口点",slug:"入口点",normalizedTitle:"入口点",charIndex:2478},{level:3,title:"出口点",slug:"出口点",normalizedTitle:"出口点",charIndex:2600},{level:3,title:"选择伪状态",slug:"选择伪状态",normalizedTitle:"选择伪状态",charIndex:2677},{level:3,title:"连接伪状态",slug:"连接伪状态",normalizedTitle:"连接伪状态",charIndex:2764},{level:3,title:"终止伪状态",slug:"终止伪状态",normalizedTitle:"终止伪状态",charIndex:2900},{level:3,title:"历史状态",slug:"历史状态",normalizedTitle:"历史状态",charIndex:2945},{level:3,title:"并发区",slug:"并发区",normalizedTitle:"并发区",charIndex:3150},{level:2,title:"用例图",slug:"用例图",normalizedTitle:"用例图",charIndex:115},{level:3,title:"执行者",slug:"执行者",normalizedTitle:"执行者",charIndex:3343},{level:3,title:"用例",slug:"用例",normalizedTitle:"用例",charIndex:115},{level:3,title:"用例定义",slug:"用例定义",normalizedTitle:"用例定义",charIndex:3690},{level:3,title:"包含用例",slug:"包含用例",normalizedTitle:"包含用例",charIndex:4053},{level:3,title:"扩展用例",slug:"扩展用例",normalizedTitle:"扩展用例",charIndex:4212},{level:2,title:"通信图",slug:"通信图",normalizedTitle:"通信图",charIndex:120},{level:2,title:"交互概述图",slug:"交互概述图",normalizedTitle:"交互概述图",charIndex:125},{level:3,title:"交互发生",slug:"交互发生",normalizedTitle:"交互发生",charIndex:4708},{level:3,title:"交互元素",slug:"交互元素",normalizedTitle:"交互元素",charIndex:4713},{level:3,title:"将它们放在一起",slug:"将它们放在一起",normalizedTitle:"将它们放在一起",charIndex:4851},{level:2,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:132},{level:3,title:"生命线",slug:"生命线",normalizedTitle:"生命线",charIndex:2919},{level:3,title:"消息",slug:"消息",normalizedTitle:"消息",charIndex:2752},{level:3,title:"执行发生",slug:"执行发生",normalizedTitle:"执行发生",charIndex:5357},{level:3,title:"内部通信",slug:"内部通信",normalizedTitle:"内部通信",charIndex:5474},{level:3,title:"迷路消息和拾取消息",slug:"迷路消息和拾取消息",normalizedTitle:"迷路消息和拾取消息",charIndex:5543},{level:3,title:"生命线开始与结束",slug:"生命线开始与结束",normalizedTitle:"生命线开始与结束",charIndex:5653},{level:3,title:"时间和期限约束",slug:"时间和期限约束",normalizedTitle:"时间和期限约束",charIndex:5780},{level:3,title:"复合片段",slug:"复合片段",normalizedTitle:"复合片段",charIndex:5898},{level:3,title:"门",slug:"门",normalizedTitle:"门",charIndex:1577},{level:3,title:"部分分解",slug:"部分分解",normalizedTitle:"部分分解",charIndex:6704},{level:3,title:"状态常量/延续",slug:"状态常量-延续",normalizedTitle:"状态常量/延续",charIndex:6753},{level:2,title:"时间图",slug:"时间图",normalizedTitle:"时间图",charIndex:137},{level:3,title:"状态生命线",slug:"状态生命线",normalizedTitle:"状态生命线",charIndex:6918},{level:3,title:"值生命线",slug:"值生命线",normalizedTitle:"值生命线",charIndex:7001},{level:3,title:"将它们放在一起",slug:"将它们放在一起-2",normalizedTitle:"将它们放在一起",charIndex:4851},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7234}],headersStr:"活动图 活动 动作 动作约束 控制流 初始节点 结束节点 对象和对象流 判断节点和合并节点 分叉和结合节点 扩展域 异常处理器 可中断活动区 分割 状态机图 状态 起始和结束状态 转移 状态活动 自转移 复合状态 入口点 出口点 选择伪状态 连接伪状态 终止伪状态 历史状态 并发区 用例图 执行者 用例 用例定义 包含用例 扩展用例 通信图 交互概述图 交互发生 交互元素 将它们放在一起 时序图 生命线 消息 执行发生 内部通信 迷路消息和拾取消息 生命线开始与结束 时间和期限约束 复合片段 门 部分分解 状态常量/延续 时间图 状态生命线 值生命线 将它们放在一起 参考资料",content:'# UML 行为建模图\n\n> 行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n> \n> 关键词：活动图, 状态机图, 用例图, 通信图, 交互概述图, 时序图, 时间图\n\n\n# 活动图\n\n> UML 中，活动图用来展示活动的顺序。显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。 一个活动图的示例如下所示。\n\n\n\n下面描述组成活动图的元素。\n\n\n# 活动\n\n活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。\n\n\n\n\n# 动作\n\n一个动作代表活动中的一个步骤。动作用圆角矩形表示。\n\n\n\n\n# 动作约束\n\n动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。\n\n\n\n\n# 控制流\n\n控制流显示一个动作到下一个动作的流。表示为带箭头实线\n\n\n\n\n# 初始节点\n\n一个开始或起始点用大黑圆点表示，如下图。\n\n\n\n\n# 结束节点\n\n结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。\n\n\n\n流结束节点表示为内部为叉号的圆环。\n\n\n\n这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。\n\n\n# 对象和对象流\n\n对象流是对象和数据转递的通道。对象显示为矩形。\n\n\n\n对象流显示为带箭头的连接器，表明方向和通过的对象。\n\n\n\n一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。\n\n\n\n数据存储显示为带 «datastore» 关键字的对象。\n\n\n\n\n# 判断节点和合并节点\n\n判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。\n\n\n\n\n# 分叉和结合节点\n\n分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。\n\n\n\n结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。\n\n\n# 扩展域\n\n扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 "iterative"， "parallel" 或 "stream"显示在区域的左上角\n\n\n\n\n# 异常处理器\n\n异常处理器在活动图中可以建模。\n\n\n\n\n# 可中断活动区\n\n可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 "Close Order" 动作，定单处理"Process Order" 动作会执行直到完成，除非"Cancel Request"取消请求中断被接受，这会将控制传递给"Cancel Order"动作。\n\n\n\n\n# 分割\n\n一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 "accounting department"中执行的，有在 "customer"中执行的。\n\n\n\n\n# 状态机图\n\n> 状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n\n如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。\n\n\n\n门可以处于以下的三种状态之一： "Opened"打开状态， "Closed"关闭状态，或者"Locked"锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay->isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。\n\n\n# 状态\n\n状态被表示为圆角矩形，状态名写在里面。\n\n\n\n\n# 起始和结束状态\n\n初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。\n\n\n\n\n# 转移\n\n一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：\n\n\n\n"Trigger"触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。"Guard"监护是一个条件，而且必须为真，以便于让触发器引起转移。效果"Effect"是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。\n\n\n# 状态活动\n\n在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。\n\n\n\n可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。\n\n\n# 自转移\n\n一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。\n\n\n\n\n# 复合状态\n\n一个状态机图可以有子状态机图，如下图所示：\n\n\n\n可选择不同方式显示相同信息，如下图所示：\n\n\n\n上面版本的标注说明"Check PIN"的子状态机图显示在单独的图中。\n\n\n# 入口点\n\n有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从"初始化"状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 "Ready" 状态开始。\n\n\n\n下图显示了状态机的上一层。\n\n\n\n\n# 出口点\n\n有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。\n\n\n\n\n# 选择伪状态\n\n选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。\n\n\n\n\n# 连接伪状态\n\n连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。\n\n\n\n\n# 终止伪状态\n\n进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。\n\n\n\n\n# 历史状态\n\n历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。\n\n在这个状态机中，当洗衣机运行时，它会按照"Washing" 到 Rinsing"再到"Spinning"来进行。如果电源被切断 ，洗衣机会停止运行并进入"Power Off" 状态。当电源恢复，运行状态在"History State"符号处进入，表示它会从上次离开的地方恢复。\n\n\n# 并发区\n\n一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 "Applying Brakes"， "front brake"和"rear brakes" 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。\n\n\n\n\n# 用例图\n\n> 用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。\n\n\n# 执行者\n\n用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。\n\n\n\n在下图中，执行者可以详细的泛化其他执行者:\n\n\n\n\n# 用例\n\n用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。\n\n\n\n使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 "Customer"使用 "Withdraw"用例。\n\n\n\n用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。\n\n\n\n\n# 用例定义\n\n一个典型的用例包括:\n\n * 名称和描述 - 用例通常用一个动词词组定义，而且有一个简短的文字说明。\n * 需求 - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。\n * 约束 - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为"真"。不变化条件说明用例整个执行过程中该条件始终为"真"。\n * 情形 - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。\n * 情形图\n * 附加信息\n\n\n# 包含用例\n\n用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认” 在运行时，被用例“取钱”当作一个子部分。\n\n\n\n用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。\n\n\n# 扩展用例\n\n一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”用例将有选择的扩展常规的“修改订单”用例。\n\n\n\n扩展点 - 扩展用例的加入点被定义为扩展点。\n\n\n\n系统边界 - 它用来显示用例在系统内部，执行者在系统的外部。\n\n\n\n\n# 通信图\n\n> 通信图，以前称之为协作图，是一种交互图，所显示消息与时序图相似，但是它更侧重于对象间的联系。\n\n在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。\n\n下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。\n\n\n\n\n\n# 交互概述图\n\n> 一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。\n\n\n# 交互发生\n\n交互发生引用现有的交互图。显示为一个引用框，左上角显示 "ref" 。被引用的图名显示在框的中央。\n\n\n\n\n# 交互元素\n\n交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。\n\n\n\n\n# 将它们放在一起\n\n所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。\n\n\n\n\n# 时序图\n\n> 时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。\n\n\n# 生命线\n\n一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是"self"，则说明该生命线代表控制带时序图的类元。\n\n\n\n有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。\n\n\n\n\n# 消息\n\n消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。\n\n\n\n\n# 执行发生\n\n向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。\n\n\n# 内部通信\n\n内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。\n\n\n\n\n# 迷路消息和拾取消息\n\n迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。\n\n\n\n\n# 生命线开始与结束\n\n生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。\n\n\n\n\n# 时间和期限约束\n\n消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。\n\n\n\n\n# 复合片段\n\n如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:\n\n * 选择性片段 (显示 “alt”) 为 if…then…else 结构建模。\n * 选项片段 (显示 “opt”) 为 "switch"(开关) 结构建模。\n * 中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。\n * 并行片段(显示 “par”) 为并发处理建模。\n * 弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。\n * 严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。\n * 非片段 (显示 “neg”) 包含了一系列不可用的消息。\n * 关键片段 具有关键部分。\n * 忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。\n * 考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。\n * 断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。\n * 循环片段 包含一系列被重复的消息。\n\n下图显示的是循环片段：\n\n\n\n这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带"ref"，将被参考图名显示在方框的中间。\n\n\n# 门\n\n门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：" top level diagram"中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。\n\n\n\n\n\n# 部分分解\n\n一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。\n\n\n\n\n# 状态常量/延续\n\n状态常量是生命线的约束，运行时始终为"真"。显示为两侧半圆的矩形，如下图：\n\n\n\n延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。\n\n\n# 时间图\n\n> UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n\n\n# 状态生命线\n\n状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：\n\n\n\n\n# 值生命线\n\n值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。\n\n\n\n\n# 将它们放在一起\n\n状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html',normalizedContent:'# uml 行为建模图\n\n> 行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n> \n> 关键词：活动图, 状态机图, 用例图, 通信图, 交互概述图, 时序图, 时间图\n\n\n# 活动图\n\n> uml 中，活动图用来展示活动的顺序。显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。 一个活动图的示例如下所示。\n\n\n\n下面描述组成活动图的元素。\n\n\n# 活动\n\n活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。\n\n\n\n\n# 动作\n\n一个动作代表活动中的一个步骤。动作用圆角矩形表示。\n\n\n\n\n# 动作约束\n\n动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。\n\n\n\n\n# 控制流\n\n控制流显示一个动作到下一个动作的流。表示为带箭头实线\n\n\n\n\n# 初始节点\n\n一个开始或起始点用大黑圆点表示，如下图。\n\n\n\n\n# 结束节点\n\n结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。\n\n\n\n流结束节点表示为内部为叉号的圆环。\n\n\n\n这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。\n\n\n# 对象和对象流\n\n对象流是对象和数据转递的通道。对象显示为矩形。\n\n\n\n对象流显示为带箭头的连接器，表明方向和通过的对象。\n\n\n\n一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。\n\n\n\n数据存储显示为带 «datastore» 关键字的对象。\n\n\n\n\n# 判断节点和合并节点\n\n判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。\n\n\n\n\n# 分叉和结合节点\n\n分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。\n\n\n\n结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。\n\n\n# 扩展域\n\n扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 "iterative"， "parallel" 或 "stream"显示在区域的左上角\n\n\n\n\n# 异常处理器\n\n异常处理器在活动图中可以建模。\n\n\n\n\n# 可中断活动区\n\n可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 "close order" 动作，定单处理"process order" 动作会执行直到完成，除非"cancel request"取消请求中断被接受，这会将控制传递给"cancel order"动作。\n\n\n\n\n# 分割\n\n一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 "accounting department"中执行的，有在 "customer"中执行的。\n\n\n\n\n# 状态机图\n\n> 状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n\n如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。\n\n\n\n门可以处于以下的三种状态之一： "opened"打开状态， "closed"关闭状态，或者"locked"锁定状态。 它分别响应事件：“open”开门， “close”关门， “lock”锁门 和 “unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorway->isempty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。\n\n\n# 状态\n\n状态被表示为圆角矩形，状态名写在里面。\n\n\n\n\n# 起始和结束状态\n\n初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。\n\n\n\n\n# 转移\n\n一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“trigger”触发器，一个“guard”监护条件和一个“effect”效果。如下所示：\n\n\n\n"trigger"触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。"guard"监护是一个条件，而且必须为真，以便于让触发器引起转移。效果"effect"是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。\n\n\n# 状态活动\n\n在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。\n\n\n\n可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。\n\n\n# 自转移\n\n一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。\n\n\n\n\n# 复合状态\n\n一个状态机图可以有子状态机图，如下图所示：\n\n\n\n可选择不同方式显示相同信息，如下图所示：\n\n\n\n上面版本的标注说明"check pin"的子状态机图显示在单独的图中。\n\n\n# 入口点\n\n有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从"初始化"状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 "ready" 状态开始。\n\n\n\n下图显示了状态机的上一层。\n\n\n\n\n# 出口点\n\n有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。\n\n\n\n\n# 选择伪状态\n\n选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。\n\n\n\n\n# 连接伪状态\n\n连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。\n\n\n\n\n# 终止伪状态\n\n进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。\n\n\n\n\n# 历史状态\n\n历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。\n\n在这个状态机中，当洗衣机运行时，它会按照"washing" 到 rinsing"再到"spinning"来进行。如果电源被切断 ，洗衣机会停止运行并进入"power off" 状态。当电源恢复，运行状态在"history state"符号处进入，表示它会从上次离开的地方恢复。\n\n\n# 并发区\n\n一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 "applying brakes"， "front brake"和"rear brakes" 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。\n\n\n\n\n# 用例图\n\n> 用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。\n\n\n# 执行者\n\n用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。\n\n\n\n在下图中，执行者可以详细的泛化其他执行者:\n\n\n\n\n# 用例\n\n用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。\n\n\n\n使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 "customer"使用 "withdraw"用例。\n\n\n\n用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。\n\n\n\n\n# 用例定义\n\n一个典型的用例包括:\n\n * 名称和描述 - 用例通常用一个动词词组定义，而且有一个简短的文字说明。\n * 需求 - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。\n * 约束 - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为"真"。不变化条件说明用例整个执行过程中该条件始终为"真"。\n * 情形 - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。\n * 情形图\n * 附加信息\n\n\n# 包含用例\n\n用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认” 在运行时，被用例“取钱”当作一个子部分。\n\n\n\n用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。\n\n\n# 扩展用例\n\n一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”用例将有选择的扩展常规的“修改订单”用例。\n\n\n\n扩展点 - 扩展用例的加入点被定义为扩展点。\n\n\n\n系统边界 - 它用来显示用例在系统内部，执行者在系统的外部。\n\n\n\n\n# 通信图\n\n> 通信图，以前称之为协作图，是一种交互图，所显示消息与时序图相似，但是它更侧重于对象间的联系。\n\n在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。\n\n下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。\n\n\n\n\n\n# 交互概述图\n\n> 一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。\n\n\n# 交互发生\n\n交互发生引用现有的交互图。显示为一个引用框，左上角显示 "ref" 。被引用的图名显示在框的中央。\n\n\n\n\n# 交互元素\n\n交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。\n\n\n\n\n# 将它们放在一起\n\n所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。\n\n\n\n\n# 时序图\n\n> 时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。\n\n\n# 生命线\n\n一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是"self"，则说明该生命线代表控制带时序图的类元。\n\n\n\n有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。\n\n\n\n\n# 消息\n\n消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。\n\n\n\n\n# 执行发生\n\n向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。\n\n\n# 内部通信\n\n内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。\n\n\n\n\n# 迷路消息和拾取消息\n\n迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。\n\n\n\n\n# 生命线开始与结束\n\n生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。\n\n\n\n\n# 时间和期限约束\n\n消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。\n\n\n\n\n# 复合片段\n\n如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:\n\n * 选择性片段 (显示 “alt”) 为 if…then…else 结构建模。\n * 选项片段 (显示 “opt”) 为 "switch"(开关) 结构建模。\n * 中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。\n * 并行片段(显示 “par”) 为并发处理建模。\n * 弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。\n * 严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。\n * 非片段 (显示 “neg”) 包含了一系列不可用的消息。\n * 关键片段 具有关键部分。\n * 忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。\n * 考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。\n * 断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。\n * 循环片段 包含一系列被重复的消息。\n\n下图显示的是循环片段：\n\n\n\n这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带"ref"，将被参考图名显示在方框的中间。\n\n\n# 门\n\n门是连接片段内消息和片段外消息的连接点。 在 ea 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：" top level diagram"中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。\n\n\n\n\n\n# 部分分解\n\n一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。\n\n\n\n\n# 状态常量/延续\n\n状态常量是生命线的约束，运行时始终为"真"。显示为两侧半圆的矩形，如下图：\n\n\n\n延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。\n\n\n# 时间图\n\n> uml 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n\n\n# 状态生命线\n\n状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，x 轴显示经过的时间，y 轴被标为给出状态的列表。状态生命线如下所示：\n\n\n\n\n# 值生命线\n\n值生命线显示随时间变化，一个单项的值的变化。x 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。\n\n\n\n\n# 将它们放在一起\n\n状态和值的生命线能叠加组合。它们必须有相同的 x 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html',charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"UML",frontmatter:{title:"UML",date:"2020-08-10T10:59:18.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/13ccb0/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/11.UML/",relativePath:"03.设计/11.UML/README.md",key:"v-de1804e0",path:"/pages/13ccb0/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:189},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:238},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:342}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# UML\n\n> 统一建模语言（英语 - Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n\n# 📖 内容\n\n * UML 快速入门\n * UML 结构建模图\n * UML 行为建模图\n\n\n# 📚 资料\n\n * Wiki-UML\n * Sparx UML 教程\n * OMG UML\n * UML Tutorial\n * W3Cschool UML 教程\n * UML 学习入门就这一篇文章\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# uml\n\n> 统一建模语言（英语 - unified modeling language，缩写 uml）是非专利的第三代建模和规约语言。uml 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。uml 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n\n# 📖 内容\n\n * uml 快速入门\n * uml 结构建模图\n * uml 行为建模图\n\n\n# 📚 资料\n\n * wiki-uml\n * sparx uml 教程\n * omg uml\n * uml tutorial\n * w3cschool uml 教程\n * uml 学习入门就这一篇文章\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"设计",frontmatter:{title:"设计",date:"2022-04-27T17:26:27.000Z",categories:["设计"],tags:["编程"],permalink:"/pages/8ea43c/",hidden:!0},regularPath:"/03.%E8%AE%BE%E8%AE%A1/",relativePath:"03.设计/README.md",key:"v-34e3a8ae",path:"/pages/8ea43c/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:9},{level:3,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:19},{level:4,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:25},{level:4,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:141},{level:4,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:110},{level:3,title:"设计模式",slug:"设计模式",normalizedTitle:"设计模式",charIndex:198},{level:4,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:217},{level:4,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:408},{level:4,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:589},{level:3,title:"重构",slug:"重构",normalizedTitle:"重构",charIndex:861},{level:3,title:"UML",slug:"uml",normalizedTitle:"uml",charIndex:953},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1e3},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1244}],headersStr:"📖 内容 架构 综合 微服务 安全 设计模式 创建型模式 结构型模式 行为型模式 重构 UML 📚 资料 🚪 传送",content:"# 设计\n\n\n# 📖 内容\n\n\n# 架构\n\n# 综合\n\n * 如何设计系统\n * 系统架构面试总结\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 系统测试架构\n\n# 微服务\n\n * 微服务简介\n * 微服务基本原理\n\n# 安全\n\n * 认证和授权\n * OAuth2.0\n\n\n# 设计模式\n\n * 面向对象原则\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n * 单例模式 (Singleton)\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 组合模式 (Composite)\n * 装饰模式 (Decorator)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)\n\n\n# 重构\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# UML\n\n * UML 快速入门\n * UML 结构建模图\n * UML 行为建模图\n\n\n# 📚 资料\n\n * UML\n   * Wiki-UML\n   * Sparx UML 教程\n   * OMG UML\n   * UML Tutorial\n   * W3Cschool UML 教程\n   * UML 学习入门就这一篇文章\n * 设计模式\n   * 《Head First 设计模式》\n   * 《大话设计模式》\n   * 设计模式教程\n * 重构\n   * 《代码整洁之道》\n   * 《重构 - 改善既有代码的设计》\n   * 《代码大全》\n   * 重构教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"# 设计\n\n\n# 📖 内容\n\n\n# 架构\n\n# 综合\n\n * 如何设计系统\n * 系统架构面试总结\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 系统测试架构\n\n# 微服务\n\n * 微服务简介\n * 微服务基本原理\n\n# 安全\n\n * 认证和授权\n * oauth2.0\n\n\n# 设计模式\n\n * 面向对象原则\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n * 单例模式 (singleton)\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 组合模式 (composite)\n * 装饰模式 (decorator)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)\n\n\n# 重构\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# uml\n\n * uml 快速入门\n * uml 结构建模图\n * uml 行为建模图\n\n\n# 📚 资料\n\n * uml\n   * wiki-uml\n   * sparx uml 教程\n   * omg uml\n   * uml tutorial\n   * w3cschool uml 教程\n   * uml 学习入门就这一篇文章\n * 设计模式\n   * 《head first 设计模式》\n   * 《大话设计模式》\n   * 设计模式教程\n * 重构\n   * 《代码整洁之道》\n   * 《重构 - 改善既有代码的设计》\n   * 《代码大全》\n   * 重构教程\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-02e2a776",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-20b770b6",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-0480d1c5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"Design",tagline:"Design 是个人对于架构的心得和总结。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-7e5bbd14",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:134},{level:3,title:"设计步骤",slug:"设计步骤",normalizedTitle:"设计步骤",charIndex:144},{level:4,title:"第一步：需求分析",slug:"第一步-需求分析",normalizedTitle:"第一步：需求分析",charIndex:296},{level:4,title:"第二步：顶层设计",slug:"第二步-顶层设计",normalizedTitle:"第二步：顶层设计",charIndex:638},{level:4,title:"第三步：组件设计",slug:"第三步-组件设计",normalizedTitle:"第三步：组件设计",charIndex:699},{level:4,title:"第四步：扩展设计",slug:"第四步-扩展设计",normalizedTitle:"第四步：扩展设计",charIndex:731},{level:3,title:"分布式",slug:"分布式",normalizedTitle:"分布式",charIndex:817},{level:4,title:"分布式综合",slug:"分布式综合",normalizedTitle:"分布式综合",charIndex:824},{level:4,title:"分布式理论",slug:"分布式理论",normalizedTitle:"分布式理论",charIndex:845},{level:4,title:"分布式关键技术",slug:"分布式关键技术",normalizedTitle:"分布式关键技术",charIndex:974},{level:5,title:"流量调度",slug:"流量调度",normalizedTitle:"流量调度",charIndex:1010},{level:5,title:"数据调度",slug:"数据调度",normalizedTitle:"数据调度",charIndex:1205},{level:5,title:"资源调度",slug:"资源调度",normalizedTitle:"资源调度",charIndex:1442},{level:5,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:1459},{level:5,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:1501},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1712},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:2254}],headersStr:"📖 内容 设计步骤 第一步：需求分析 第二步：顶层设计 第三步：组件设计 第四步：扩展设计 分布式 分布式综合 分布式理论 分布式关键技术 流量调度 数据调度 资源调度 通信 服务治理 📚 资料 🚪 传送",content:"> ☕ DESIGN 是个人对于软件系统架构的心得和总结。\n> \n> 架构之道，在于权衡；权衡之术，在于取舍。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n# 设计步骤\n\n解决方案（Solution），就是针对某些已经体现出的，或者可以预期的问题、不足、缺陷、需求等等，所提出的一个解决整体问题的可行性方案。就软件系统而言，解决方案就是一个可以解决具体业务问题，并且可以落地的软件系统。\n\n解决方案，毫无疑问是顶层系统设计，这需要设计者既懂技术，也懂业务。\n\n# 第一步：需求分析\n\n把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。\n\n * What：系统的作用是什么？系统的目标是什么？\n * Who：系统的用户群体是谁？\n * How：用户希望怎样使用系统？系统如何为用户提供服务？\n * How many：有多少用户？日活/月活有多少？——用户体量会极大的影响系统的性能要求，从而影响系统的规模和复杂度。\n * 容量：系统需要处理多少数据？\n * 并发量、吞吐量：系统需要每秒钟处理多少请求？\n * 读写比率：系统的读写比率是多少？——读多写少或写多读少决定了不同的架构方案。\n * How much：系统的预算是多少（包括物料、人力成本等）？\n * 输入输出：系统的输入输出分别是什么？\n\n# 第二步：顶层设计\n\n使用所有重要的组件来描绘出一个高层级的设计。\n\n * 画出主要的组件和连接\n * 证明你的想法\n\n# 第三步：组件设计\n\n对每一个核心组件进行详细深入的分析。\n\n# 第四步：扩展设计\n\n确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？\n\n * 负载均衡\n * 水平扩展\n * 缓存\n * 数据库分片\n\n\n# 分布式\n\n# 分布式综合\n\n * 分布式面试总结\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、CAP、BASE、错误的分布式假设\n * 分布式算法 Paxos - 关键词：共识性算法\n * 分布式算法 Raft - 关键词：共识性算法\n * 分布式算法 Gossip - 关键词：数据传播\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 Session、Session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 ID - 关键词：UUID、自增序列、雪花算法、Leaf\n * 分布式事务 - 关键词：2PC、3PC、TCC、本地消息表、MQ 消息、SAGA\n * 分布式锁 - 关键词：数据库、Redis、ZooKeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 大型网站系统与 Java 中间件实践\n   * 企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n   * 《Head First 设计模式》\n   * 《大话设计模式》\n   * 《重构——改善既有代码的设计》\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * RPC 实战与核心原理\n   * 微服务架构核心 20 讲\n   * DDD 实战课\n   * Sparx UML 教程\n   * UML Tutorial\n   * W3Cschool UML 教程\n   * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 钝悟的博客 ◾\n\n> 你可能会感兴趣：\n\n * Java 教程 📚\n * JavaCore 教程 📚\n * JavaTech 教程 📚\n * Spring 教程 📚\n * Spring Boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * Linux 教程 📚\n * Nginx 教程 📚",normalizedContent:"> ☕ design 是个人对于软件系统架构的心得和总结。\n> \n> 架构之道，在于权衡；权衡之术，在于取舍。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n# 设计步骤\n\n解决方案（solution），就是针对某些已经体现出的，或者可以预期的问题、不足、缺陷、需求等等，所提出的一个解决整体问题的可行性方案。就软件系统而言，解决方案就是一个可以解决具体业务问题，并且可以落地的软件系统。\n\n解决方案，毫无疑问是顶层系统设计，这需要设计者既懂技术，也懂业务。\n\n# 第一步：需求分析\n\n把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。\n\n * what：系统的作用是什么？系统的目标是什么？\n * who：系统的用户群体是谁？\n * how：用户希望怎样使用系统？系统如何为用户提供服务？\n * how many：有多少用户？日活/月活有多少？——用户体量会极大的影响系统的性能要求，从而影响系统的规模和复杂度。\n * 容量：系统需要处理多少数据？\n * 并发量、吞吐量：系统需要每秒钟处理多少请求？\n * 读写比率：系统的读写比率是多少？——读多写少或写多读少决定了不同的架构方案。\n * how much：系统的预算是多少（包括物料、人力成本等）？\n * 输入输出：系统的输入输出分别是什么？\n\n# 第二步：顶层设计\n\n使用所有重要的组件来描绘出一个高层级的设计。\n\n * 画出主要的组件和连接\n * 证明你的想法\n\n# 第三步：组件设计\n\n对每一个核心组件进行详细深入的分析。\n\n# 第四步：扩展设计\n\n确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？\n\n * 负载均衡\n * 水平扩展\n * 缓存\n * 数据库分片\n\n\n# 分布式\n\n# 分布式综合\n\n * 分布式面试总结\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、cap、base、错误的分布式假设\n * 分布式算法 paxos - 关键词：共识性算法\n * 分布式算法 raft - 关键词：共识性算法\n * 分布式算法 gossip - 关键词：数据传播\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 session、session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 id - 关键词：uuid、自增序列、雪花算法、leaf\n * 分布式事务 - 关键词：2pc、3pc、tcc、本地消息表、mq 消息、saga\n * 分布式锁 - 关键词：数据库、redis、zookeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 大型网站系统与 java 中间件实践\n   * 企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n   * 《head first 设计模式》\n   * 《大话设计模式》\n   * 《重构——改善既有代码的设计》\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * rpc 实战与核心原理\n   * 微服务架构核心 20 讲\n   * ddd 实战课\n   * sparx uml 教程\n   * uml tutorial\n   * w3cschool uml 教程\n   * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 钝悟的博客 ◾\n\n> 你可能会感兴趣：\n\n * java 教程 📚\n * javacore 教程 📚\n * javatech 教程 📚\n * spring 教程 📚\n * spring boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * linux 教程 📚\n * nginx 教程 📚",charsets:{cjk:!0},lastUpdated:"2023/02/10, 11:41:17",lastUpdatedTimestamp:1676000477e3}],themeConfig:{nav:[{text:"设计",link:"/03.设计/",items:[{text:"架构",link:"/03.设计/01.架构/"},{text:"设计模式",link:"/03.设计/02.设计模式/"},{text:"重构",link:"/03.设计/03.重构/"},{text:"UML",link:"/03.设计/11.UML/"}]}],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/dev/common/dunwu-logo.png",repo:"dunwu/design",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/03.设计/":[{title:"架构",collapsable:!0,children:[{title:"综合",collapsable:!0,children:[["01.架构/00.综合/00.如何设计系统.md","如何设计系统","/pages/0a89f3/"],["01.架构/00.综合/01.系统架构面试.md","系统架构面试","/pages/000a7b/"],["01.架构/00.综合/02.系统架构概述.md","系统架构概述","/pages/db2390/"],["01.架构/00.综合/03.系统高性能架构.md","系统高性能架构","/pages/a49605/"],["01.架构/00.综合/04.系统高可用架构.md","系统高可用架构","/pages/9a462f/"],["01.架构/00.综合/05.系统伸缩性架构.md","系统伸缩性架构","/pages/1e5251/"],["01.架构/00.综合/06.系统扩展性架构.md","系统扩展性架构","/pages/943670/"],["01.架构/00.综合/07.系统安全性架构.md","系统安全性架构","/pages/a1adcf/"],["01.架构/00.综合/08.大型系统核心技术.md","大型系统核心技术","/pages/8cbae8/"],["01.架构/00.综合/09.系统测试架构.md","系统测试架构","/pages/641e5c/"]]},{title:"微服务",collapsable:!0,children:[["01.架构/01.微服务/01.微服务简介.md","微服务简介","/pages/012075/"],["01.架构/01.微服务/02.微服务基本原理.md","微服务基本原理","/pages/aa7497/"]]},{title:"安全",collapsable:!0,children:[["01.架构/02.安全/01.认证和授权.md","认证和授权","/pages/7ac4c5/"],["01.架构/02.安全/02.OAuth2.0.md","OAuth 2.0","/pages/21bd0a/"]]},{title:"解决方案",collapsable:!0,children:[]}]},{title:"设计模式",collapsable:!0,children:[["02.设计模式/00.设计模式概述.md","设计模式概述","/pages/9a2452/"],["02.设计模式/01.简单工厂模式.md","设计模式之简单工厂模式","/pages/ff930b/"],["02.设计模式/02.工厂方法模式.md","设计模式之工厂方法模式","/pages/65724c/"],["02.设计模式/03.抽象工厂模式.md","设计模式之抽象工厂模式","/pages/340aa0/"],["02.设计模式/04.建造者模式.md","设计模式之建造者模式","/pages/bf03f3/"],["02.设计模式/05.原型模式.md","设计模式之原型模式","/pages/1af8ee/"],["02.设计模式/06.单例模式.md","设计模式之单例模式","/pages/cf046f/"],["02.设计模式/07.适配器模式.md","设计模式之适配器模式","/pages/2115cf/"],["02.设计模式/08.桥接模式.md","设计模式之桥接模式","/pages/b05f5f/"],["02.设计模式/09.组合模式.md","设计模式之组合模式","/pages/85c0a3/"],["02.设计模式/10.装饰模式.md","设计模式之装饰模式","/pages/2e24a8/"],["02.设计模式/11.外观模式.md","设计模式之外观模式","/pages/ea331b/"],["02.设计模式/12.享元模式.md","设计模式之享元模式","/pages/9147e7/"],["02.设计模式/13.代理模式.md","设计模式之代理模式","/pages/5a865c/"],["02.设计模式/14.模板方法模式.md","设计模式之模板方法模式","/pages/6eaeb4/"],["02.设计模式/15.命令模式.md","设计模式之命令模式","/pages/22353c/"],["02.设计模式/16.迭代器模式.md","设计模式之迭代器模式","/pages/09d5af/"],["02.设计模式/17.观察者模式.md","设计模式之观察者模式","/pages/056e1d/"],["02.设计模式/18.解释器模式.md","设计模式之解释器模式","/pages/48e5aa/"],["02.设计模式/19.中介者模式.md","设计模式之中介者模式","/pages/3b1f47/"],["02.设计模式/20.职责链模式.md","设计模式之职责链模式","/pages/b25735/"],["02.设计模式/21.备忘录模式.md","设计模式之备忘录模式","/pages/5ae0d5/"],["02.设计模式/22.策略模式.md","设计模式之策略模式","/pages/dc8ecd/"],["02.设计模式/23.访问者模式.md","设计模式之访问者模式","/pages/671352/"],["02.设计模式/24.状态模式.md","设计模式之状态模式","/pages/d77095/"],["02.设计模式/25.面向对象原则.md","面向对象原则","/pages/9703b1/"]]},{title:"重构",collapsable:!0,children:[["03.重构/01.代码的坏味道和重构.md","代码的坏味道和重构","/pages/d86872/"],["03.重构/02.代码坏味道之代码臃肿.md","代码坏味道之代码臃肿","/pages/49d5ae/"],["03.重构/03.代码坏味道之滥用面向对象.md","代码坏味道之滥用面向对象","/pages/65ee05/"],["03.重构/04.代码坏味道之变革的障碍.md","代码坏味道之变革的障碍","/pages/56ca63/"],["03.重构/05.代码坏味道之非必要的.md","代码坏味道之非必要的","/pages/47acb5/"],["03.重构/06.代码坏味道之耦合.md","代码坏味道之耦合","/pages/630e7a/"]]},{title:"DDD",collapsable:!0,children:[["04.DDD/01.领域驱动设计简介.md","领域驱动设计简介","/pages/86db92/"]]},{title:"UML",collapsable:!0,children:[["11.UML/01.UML快速入门.md","UML 快速入门","/pages/ae1396/"],["11.UML/02.UML结构建模图.md","UML 结构建模图","/pages/dd5922/"],["11.UML/03.UML行为建模图.md","UML 行为建模图","/pages/0b8e4b/"]]}],catalogue:{}},sidebarOpen:!0,updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{pageB:'\n  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ',windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};var ws=t(96),Ts=t(97),Cs=t(11);var Is={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Cs.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Cs.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Cs.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(Cs.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(Cs.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(ws.default),Vt.component(Ts.default);function Es(n){return n.toString().padStart(2,"0")}t(244);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,407))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,96))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,97)));t(245),t(246);var Ss=t(95),ks=t.n(Ss),zs=t(27);let As,_s;var Ps;"valine"===(Ps="gitalk")?t.e(75).then(t.t.bind(null,334,7)).then(n=>_s=n.default):"gitalk"===Ps&&Promise.all([t.e(0),t.e(74)]).then(t.t.bind(null,335,7)).then(()=>t.e(73).then(t.t.bind(null,336,7))).then(n=>As=n.default);function js(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=ks.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${zs.name}@v${zs.version}:`,zs.homepage);const Bs={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new As(js({clientID:"e14ca3cdac2f448d544e",clientSecret:"75f09b9dede044939cf0ff690bc93c225bcb4063",repo:"design",owner:"dunwu",admin:["dunwu"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new _s({...js({clientID:"e14ca3cdac2f448d544e",clientSecret:"75f09b9dede044939cf0ff690bc93c225bcb4063",repo:"design",owner:"dunwu",admin:["dunwu"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Os="vuepress-plugin-comment";let Ds=null;function Ms(n){return Bs.gitalk.clear(Os)}function Rs(n){return!1!==n.comment&&!1!==n.comments}function Ls(n){clearTimeout(Ds);if(document.querySelector("main.page"))return Bs.gitalk.render(n,Os);Ds=setTimeout(()=>Ls(n),200)}var Us={mounted(){Ds=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Ms()&&Rs(n)&&Ls(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Ms()&&Rs(t)&&Ls(t)})}},Fs=Object(fs.a)(Us,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,qs=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Es(n.getUTCMonth()+1)}-${Es(n.getUTCDate())} ${Es(n.getUTCHours())}:${Es(n.getUTCMinutes())}:${Es(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Is)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",i.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<i.length;t++)i[t].alpha<=0?(e.body.removeChild(i[t].el),i.splice(t,1)):(i[t].y--,i[t].scale+=.004,i[t].alpha-=.013,i[t].el.style.cssText="left:"+i[t].x+"px;top:"+i[t].y+"px;opacity:"+i[t].alpha+";transform:scale("+i[t].scale+","+i[t].scale+") rotate(45deg);background:"+i[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({Vue:n})=>{n.component("Comment",Fs)}],Ns=["Comment"];class $s extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign($s.prototype,{getPageAsyncComponent:ol,getLayoutAsyncComponent:ll,getAsyncComponent:sl,getVueComponent:cl});var Hs={install(n){const e=new $s;n.$vuepress=e,n.prototype.$vuepress=e}};function Ws(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Vs={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ul("pageKey",e),Vt.component(e)||Vt.component(e,ol(e)),Vt.component(e)?n(e):n("")}},Gs={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Js={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Qs=(t(252),t(253),Object(fs.a)(Js,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Zs={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Ho),Vt.use(Hs),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xs)),Vt.component("Content",Vs),Vt.component("ContentSlotsDistributor",Gs),Vt.component("OutboundLink",Qs),Vt.component("ClientOnly",Zs),Vt.component("Layout",ll("Layout")),Vt.component("NotFound",ll("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"e2e3bff"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xs.routerBase||xs.base,t=new Ho({base:e,mode:"history",fallback:!1,routes:ys,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Ws(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Ws(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";Ws(n,i)?r(i):Ws(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(qs.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:r,router:t,siteData:xs,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ns.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);